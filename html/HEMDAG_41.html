<div class="container">

<table style="width: 100%;"><tr>
<td>find.best.f</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Best hierarchical F-score</h2>

<h3>Description</h3>

<p>Select the best hierarchical F-score by choosing an appropriate threshold in the scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find.best.f(
  target,
  predicted,
  n.round = 3,
  verbose = TRUE,
  b.per.example = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>matrix with the target multilabel: rows correspond to examples and columns to classes.
<code class="reqn">target[i,j]=1</code> if example <code class="reqn">i</code> belongs to class <code class="reqn">j</code>, <code class="reqn">target[i,j]=0</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicted</code></td>
<td>
<p>a numeric matrix with continuous predicted values (scores): rows correspond to examples and columns to classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.round</code></td>
<td>
<p>number of rounding digits to be applied to predicted (<code>default=3</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a boolean value. If <code>TRUE</code> (def.) the number of iterations are printed on stdout.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.per.example</code></td>
<td>
<p>a boolean value.
</p>

<ul>
<li> <p><code>TRUE</code>: results are returned for each example;
</p>
</li>
<li> <p><code>FALSE</code>: only the average results are returned;
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All the examples having no positive annotations are discarded. The predicted scores matrix (<code>predicted</code>) is rounded
according to parameter <code>n.round</code> and all the values of <code>predicted</code> are divided by <code>max(predicted)</code>.
Then all the thresholds corresponding to all the different values included in <code>predicted</code> are attempted, and the threshold
leading to the maximum F-measure is selected.
</p>
<p>Names of rows and columns of <code>target</code> and <code>predicted</code> matrix must be provided in the same order, otherwise a stop message is returned.
</p>


<h3>Value</h3>

<p>Two different outputs respect to the input parameter <code>b.per.example</code>:
</p>

<ul>
<li> <p><code>b.per.example==FALSE</code>: a list with a single element average. A named vector with 7 elements relative to the best result in terms
of the F.measure: Precision (P), Recall (R), Specificity (S), F.measure (F), av.F.measure (av.F), Accuracy (A) and the best selected Threshold (T).
F is the F-measure computed as the harmonic mean between the average precision and recall; av.F is the F-measure computed as the average across
examples and T is the best selected threshold;
</p>
</li>
<li> <p><code>b.per.example==FALSE</code>: a list with two elements:
</p>

<ol>
<li>
<p> average: a named vector with with 7 elements relative to the best result in terms of the F.measure: Precision (P), Recall (R),
Specificity (S), F.measure (F), av.F.measure (av.F), Accuracy (A) and the best selected Threshold (T);
</p>
</li>
<li>
<p> per.example: a named matrix with the Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F), av.F-measure (av.F)
and the best selected Threshold (T) for each example. Row names correspond to examples, column names correspond respectively
to Precision (P), Recall (R), Specificity (S), Accuracy (A), F-measure (F), av.F-measure (av.F) and the best selected Threshold (T);
</p>
</li>
</ol>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">data(graph);
data(labels);
data(scores);
root &lt;- root.node(g);
L &lt;- L[,-which(colnames(L)==root)];
S &lt;- S[,-which(colnames(S)==root)];
fscore &lt;- find.best.f(L, S, n.round=3, verbose=TRUE, b.per.example=TRUE);
</code></pre>


</div>