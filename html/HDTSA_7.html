<div class="container">

<table style="width: 100%;"><tr>
<td>PCA_TS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Principal component analysis for time serise</h2>

<h3>Description</h3>

<p><code>PCA_TS()</code> seeks for a contemporaneous linear
transformation for a multivariate time series such that the transformed
series is segmented into several lower-dimensional subseries: </p>
<p style="text-align: center;"><code class="reqn">{\bf
  y}_t={\bf Ax}_t,</code>
</p>
<p> where <code class="reqn">{\bf x}_t</code> is an unobservable <code class="reqn">p \times 1</code>
weakly stationary time series consisting of <code class="reqn">q\ (\geq 1)</code> both
contemporaneously and serially uncorrelated subseries. See Chang, Guo and
Yao (2018).
</p>


<h3>Usage</h3>

<pre><code class="language-R">PCA_TS(
  Y,
  lag.k = 5,
  thresh = FALSE,
  tuning.vec = NULL,
  K = 5,
  prewhiten = TRUE,
  permutation = c("max", "fdr"),
  m = NULL,
  beta,
  just4pre = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code class="reqn">{\bf Y} = \{{\bf y}_1, \dots , {\bf y}_n \}'</code>, a data matrix
with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">n</code> is the sample size and
<code class="reqn">p</code> is the dimension of <code class="reqn">{\bf y}_t</code>. The procedure will first
normalize <code class="reqn">{\bf y}_t</code> as <code class="reqn">\widehat{{\bf V}}^{-1/2}{\bf y}_t</code>, where
<code class="reqn">\widehat{{\bf V}}</code> is an estimator for covariance of <code class="reqn">{\bf y}_t</code>.
See details below for the selection of <code class="reqn">\widehat{{\bf V}}^{-1}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.k</code></td>
<td>
<p>Time lag <code class="reqn">k_0</code> used to calculate the nonnegative definte
matrix <code class="reqn">\widehat{{\bf W}}_y</code>: </p>
<p style="text-align: center;"><code class="reqn">\widehat{\mathbf{W}}_y\ =\
\sum_{k=0}^{k_0}\widehat{\mathbf{\Sigma}}_y(k)\widehat{\mathbf{\Sigma}}_y(k)'=\mathbf{I}_p+\sum_{k=1}^{k_0}\widehat{\mathbf{\Sigma}}_y(k)\widehat{\mathbf{\Sigma}}_y(k)',
 </code>
</p>
<p> where <code class="reqn">\widehat{\bf \Sigma}_y(k)</code> is the sample autocovariance of
<code class="reqn"> \widehat{{\bf V}}^{-1/2}{\bf y}_t</code> at lag <code class="reqn">k</code>. See (2.5) in
Chang, Guo and Yao (2018).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), no thresholding will
be applied to estimate <code class="reqn">\widehat{{\bf W}}_y</code>. If <code>TRUE</code>, a
thresholding method will be applied first to estimate <code class="reqn">\widehat{{\bf
W}}_y</code>, see (3.5) in Chang, Guo and Yao (2018).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning.vec</code></td>
<td>
<p>The value of the tuning parameter <code class="reqn">\lambda</code> in the
thresholding level <code class="reqn"> u = \lambda \sqrt{n^{-1}\log p}</code>, where default
value is 2. If <code>tuning.vec</code> is a vector, then a cross validation
method proposed in Cai and Liu (2011) will be used to choose the best
tuning parameter <code class="reqn">\lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>The number of folders used in the cross validation for the
selection of <code class="reqn">\lambda</code>, the default is 5. It is required when
<code>thresh = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prewhiten</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), we prewhiten each
transformed component series of <code class="reqn">\hat{\bf z}_t</code> [See Section 2.2.1 in
Chang, Guo and Yao (2018)] by fitting a univariate AR model with the order
between 0 and 5 determined by AIC. If <code>FALSE</code>, then prewhiten
procedure will not be performed to <code class="reqn">\hat{\bf z}_t</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>permutation</code></td>
<td>
<p>The method of permutation procedure to assign the
components of <code class="reqn">\hat{\bf z}_t</code> to different groups [See Section 2.2.1 in
Chang, Guo and Yao (2018)]. Option is <code>'max'</code> (Maximum cross
correlation method) or <code>'fdr'</code> (False discovery rate procedure based
on multiple tests), default is <code>permutation = 'max'</code>. See Sections
2.2.2 and 2.2.3 in Chang, Guo and Yao (2018) for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A positive constant used in the permutation procedure [See (2.10) in
Chang, Guo and Yao (2018)]. If <code class="reqn">m</code> is not specified, then default
option is <code>m = </code>10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The error rate used in the permutation procedure when
<code>permutation = 'fdr'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>just4pre</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the procedure outputs <code class="reqn">\hat{\bf
z}_t</code>, otherwise outputs <code class="reqn">\hat{\bf x}_t</code> (the permutated version of
<code class="reqn">\hat{\bf z}_t</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the main results of the permutation 
procedure will be output on the console. Otherwise, the result will not be 
output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code class="reqn">p&gt;n^{1/2}</code>, the procedure use package <span class="pkg">clime</span> to
estimate the precision matrix <code class="reqn">\widehat{{\bf V}}^{-1}</code>, otherwise uses
function <code>cov()</code> to estimate <code class="reqn">\widehat{{\bf V}}</code> and calculate its
inverse. When <code class="reqn">p&gt;n^{1/2}</code>, we recommend to use the thresholding method
to calculate <code class="reqn">\widehat{{\bf W}}_y</code>, see more information in Chang, Guo
and Yao (2018).
</p>


<h3>Value</h3>

<p>The output of the segment procedure is a list containing the
following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>The <code class="reqn">p\times p</code> transformation matrix
such that <code class="reqn">\hat{\bf z}_t = \widehat{\bf B}{\bf y}_t</code>, where
<code class="reqn">\widehat{\bf B}=\widehat{\bf \Gamma}_y\widehat{{\bf V}}^{-1/2}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p><code class="reqn">\hat{\bf Z}=\{\hat{\bf z}_1,\dots,\hat{\bf z}_n\}'</code>, the
transformed series with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.</p>
</td>
</tr>
</table>
<p>The output of the permutation procedure is a list containing the
following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>NoGroups</code></td>
<td>
<p>number of groups with at least two components series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>No_of_Members</code></td>
<td>
<p>The cardinalities of different groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Groups</code></td>
<td>
<p>The indices of the components in <code class="reqn">\hat{\bf z}_t</code> that
belongs to a group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string indicating what method was performed.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Chang, J., Guo, B. &amp; Yao, Q. (2018). <em>Principal component
analysis for second-order stationary vector time series</em>, The Annals of
Statistics, Vol. 46, pp. 2094–2124.
</p>
<p>Cai, T. &amp; Liu, W. (2011). <em>Adaptive thresholding for sparse covariance
matrix estimation</em>,  Journal of the American Statistical Association, Vol.
106, pp. 672–684.
</p>
<p>Cai, T., Liu, W., &amp; Luo, X. (2011). <em>A constrained l1 minimization
approach for sparse precision matrix estimation</em>, Journal of the American
Statistical Association, Vol. 106, pp. 594–607.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example 1 (Example 5 of Chang Guo and Yao (2018)).
## p=6, x_t consists of 3 independent subseries with 3, 2 and 1 components.

p &lt;- 6;n &lt;- 1500
# Generate x_t
X &lt;- mat.or.vec(p,n)
x &lt;- arima.sim(model=list(ar=c(0.5, 0.3), ma=c(-0.9, 0.3, 1.2,1.3)),
n=n+2,sd=1)
for(i in 1:3) X[i,] &lt;- x[i:(n+i-1)]
x &lt;- arima.sim(model=list(ar=c(0.8,-0.5),ma=c(1,0.8,1.8) ),n=n+1,sd=1)
for(i in 4:5) X[i,] &lt;- x[(i-3):(n+i-4)]
x &lt;- arima.sim(model=list(ar=c(-0.7, -0.5), ma=c(-1, -0.8)),n=n,sd=1)
X[6,] &lt;- x
# Generate y_t
A &lt;- matrix(runif(p*p, -3, 3), ncol=p)
Y &lt;- A%*%X
Y &lt;- t(Y)
res &lt;- PCA_TS(Y, lag.k=5,permutation = "max")
res1=PCA_TS(Y, lag.k=5,permutation = "fdr", beta=10^(-10))
# The transformed series z_t
Z &lt;- res$Z
# Plot the cross correlogram of z_t and y_t
Y &lt;- data.frame(Y);Z=data.frame(Z)
names(Y) &lt;- c("Y1","Y2","Y3","Y4","Y5","Y6")
names(Z) &lt;- c("Z1","Z2","Z3","Z4","Z5","Z6")
# The cross correlogram of y_t shows no block pattern
acfY &lt;- acf(Y)
# The cross correlogram of z_t shows 3-2-1 block pattern
acfZ &lt;- acf(Z)

## Example 2 (Example 6 of Chang Guo and Yao (2018)).
## p=20, x_t consists of 5 independent subseries with 6, 5, 4, 3 and 2 components.
p &lt;- 20;n &lt;- 3000
# Generate x_t
X &lt;- mat.or.vec(p,n)
x &lt;- arima.sim(model=list(ar=c(0.5, 0.3), ma=c(-0.9, 0.3, 1.2,1.3)),n.start=500,
n=n+5,sd=1)
for(i in 1:6) X[i,] &lt;- x[i:(n+i-1)]
x &lt;- arima.sim(model=list(ar=c(-0.4,0.5),ma=c(1,0.8,1.5,1.8)),n.start=500,n=n+4,sd=1)
for(i in 7:11) X[i,] &lt;- x[(i-6):(n+i-7)]
x &lt;- arima.sim(model=list(ar=c(0.85,-0.3),ma=c(1,0.5,1.2)), n.start=500,n=n+3,sd=1)
for(i in 12:15) X[i,] &lt;- x[(i-11):(n+i-12)]
x &lt;- arima.sim(model=list(ar=c(0.8,-0.5),ma=c(1,0.8,1.8)),n.start=500,n=n+2,sd=1)
for(i in 16:18) X[i,] &lt;- x[(i-15):(n+i-16)]
x &lt;- arima.sim(model=list(ar=c(-0.7, -0.5), ma=c(-1, -0.8)),n.start=500,n=n+1,sd=1)
for(i in 19:20) X[i,] &lt;- x[(i-18):(n+i-19)]
# Generate y_t
A &lt;- matrix(runif(p*p, -3, 3), ncol=p)
Y &lt;- A%*%X
Y &lt;- t(Y)
res &lt;- PCA_TS(Y, lag.k=5,permutation = "max")
res1 &lt;- PCA_TS(Y, lag.k=5,permutation = "fdr",beta=10^(-200))
# The transformed series z_t
Z &lt;- res$Z
# Plot the cross correlogram of x_t and y_t
Y &lt;- data.frame(Y);Z &lt;- data.frame(Z)
namesY=NULL;namesZ=NULL
for(i in 1:p)
{
   namesY &lt;- c(namesY,paste0("Y",i))
   namesZ &lt;- c(namesZ,paste0("Z",i))
}
names(Y) &lt;- namesY;names(Z) &lt;- namesZ
# The cross correlogram of y_t shows no block pattern
acfY &lt;- acf(Y, plot=FALSE)
plot(acfY, max.mfrow=6, xlab='', ylab='',  mar=c(1.8,1.3,1.6,0.5),
     oma=c(1,1.2,1.2,1), mgp=c(0.8,0.4,0),cex.main=1)
# The cross correlogram of z_t shows 6-5-4-3-2 block pattern
acfZ &lt;- acf(Z, plot=FALSE)
plot(acfZ, max.mfrow=6, xlab='', ylab='',  mar=c(1.8,1.3,1.6,0.5),
     oma=c(1,1.2,1.2,1), mgp=c(0.8,0.4,0),cex.main=1)
# Identify the permutation mechanism
permutation &lt;- res
permutation$Groups  
</code></pre>


</div>