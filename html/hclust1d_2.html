<div class="container">

<table style="width: 100%;"><tr>
<td>hclust1d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hierarchical Clustering for 1D</h2>

<h3>Description</h3>

<p>Univariate hierarchical agglomerative clustering routine with a few possible choices of a linkage function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hclust1d(x, distance = FALSE, squared = FALSE, method = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a vector of 1D points to be clustered, or a distance structure as produced by <code>dist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>a logical value indicating, whether <code>x</code> is a vector of 1D points to be clustered (<code>distance = FALSE</code>, the default), or a distance structure (<code>distance = TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>squared</code></td>
<td>
<p>a logical value indicating, whether <code>distance</code> is squared (<code>squared = TRUE</code>) or not (<code>squared = FALSE</code>, the default). Its value is irrelevant for <code>distance = FALSE</code> setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>linkage method, with <code>"complete"</code> as a default. See <code>supported_methods</code> for the complete list.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>x</code> is a distance matrix, the first step of the algorithm is computing a conforming vector of 1D points (with arbitrary shift and sign choices).
</p>
<p>Univariate hierarchical clustering is performed
for the provided or calculated vector of points: initially, each point is assigned its own <em>singleton</em> cluster, and
then the clusters get merged with their nearest neighbors, two at a time.
</p>
<p>For <code>method = "single"</code>, there is no need to recompute distances,
since the original inter-point distances are also the inter-cluster distances, so the algorithm requires
only sorting the original points and then sorting the distances.
</p>
<p>For other linkage methods, two distances (between the merged cluster and the preceding and the following clusters) get recomputed at each merge, and the resulting
distance structure gets updated in an efficiently implemented heap providing a priority queue functionality (the access to the current minimum distance) in O(log n) time at each step.
The resulting algorithm has O(n*log n) time complexity.
</p>


<h3>Value</h3>

<p>A list object with S3 class <code>"hclust"</code>, compatible with a regular <code>stats::hclust</code> output:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>merge</code></td>
<td>
<p>a matrix with n-1 rows and 2 columns. Each i-th row of the matrix details merging performed at the i-th step of the algorithm. If the <em>singleton</em> cluster was merged
at this step, the value of the element is negative and its absolute value equals the index of this point.
Otherwise, a positive value, say j, of an element in i-th row, indicates that at the stage i a cluster created at a previous stage j was merged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>height</code></td>
<td>
<p>a vector with n-1 values, with the i-th value indicating the distance between the two clusters merged at the i-th step of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>a permutation of the input points sorting them in an increasing order. Since the sign of points computed from the distance structure can be arbitrarily chosen, in the case of a distance structure input, the order can be increasing or decreasing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>either point names, or point values, or point indices, in the order of availability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the call which produced the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the linkage method used for clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.method</code></td>
<td>
<p>the distance method used in building the distance matrix; or <code>"euclidean"</code>, if <code>x</code> is a vector of 1D points</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Please note that in <code>stats::hclust</code>, the inter-cluster distances for ward.D, centroid and median linkages (returned as <code>height</code>)
are <em>squared</em> euclidean distances
between the relevant clusters' centroids, although that behavior is not well documented. This behavior is also in odds with other linkage methods, for which <em>unsquared</em> euclidean distances are returned.
The implementation in <code>hclust1d::hclust1d</code> follows that behavior in full.
</p>
<p>Also,
<code>stats::hclust</code> expects <em>squared</em> euclidean distance structure as input for <code>method="ward.D"</code>, <code>method="centroid"</code> and <code>method="median"</code>, although the latter is not well documented, either. Squared
distance is not a proper distance (a triangle inequality may not be maintained), so it should be considered <em>dissimilarity</em> instead.
</p>
<p>To retain compatibility, <code>hlust1d::hclust1d</code> accepts <code>x</code> in a form of a squared euclidean distance structure between points as well
(indicated by both <code>distance</code> and <code>squared</code> arguments set to <code>TRUE</code>). Also, note that
<code>hlust1d::hclust1d</code> returns the same heights for unsquared proper distances in <code>x</code> (with <code>distance=TRUE</code> setting and the default <code>squared=FALSE</code> argument)
and for <code>x</code> in a form of a vector of 1D points (with the default <code>distance=FALSE</code> argument). Please consult the <code>Examples</code> section below for further reference on that behavior.
</p>


<h3>See Also</h3>

<p><code>supported_methods</code> for listing of all currently supported linkage methods, <code>supported_dist.methods</code> for listing of all currently supported distance methods.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Faster replacements for
# stats::hclust(dist(rnorm(100))) with a default complete linkage
dendrogram &lt;- hclust1d(rnorm(100))
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE)

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "average")
dendrogram &lt;- hclust1d(rnorm(100), method = "average")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "average")

# Faster replacements for
# stats::hclust(dist(rnorm(100))^2, method = "centroid")
# Note that stats::hclust expects squared euclidean distance input for centroid linkage
# While in case of hclust1d, 3 below calls result in the equivalent output
dendrogram &lt;- hclust1d(rnorm(100), method = "centroid")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "centroid")
dendrogram &lt;- hclust1d(dist(rnorm(100))^2, distance = TRUE, squared = TRUE, method = "centroid")

# Faster replacements for
# stats::hclust(dist(rnorm(100))^2, method = "median")
# Note that stats::hclust expects squared euclidean distance input for median linkage
# While in case of hclust1d, 3 below calls result in the equivalent output
dendrogram &lt;- hclust1d(rnorm(100), method = "median")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "median")
dendrogram &lt;- hclust1d(dist(rnorm(100))^2, distance = TRUE, squared = TRUE, method = "median")

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "mcquitty")
dendrogram &lt;- hclust1d(rnorm(100), method = "mcquitty")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "mcquitty")

# Faster replacements for
# stats::hclust(dist(rnorm(100))^2, method = "ward.D")
# Note that stats::hclust expects squared euclidean distance input for ward.D linkage
# While in case of hclust1d, 3 below calls result in the equivalent output
dendrogram &lt;- hclust1d(rnorm(100), method = "ward.D")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "ward.D")
dendrogram &lt;- hclust1d(dist(rnorm(100))^2, distance = TRUE, squared = TRUE, method = "ward.D")

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "ward.D2")
dendrogram &lt;- hclust1d(rnorm(100), method = "ward.D2")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "ward.D2")

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "single")
dendrogram &lt;- hclust1d(rnorm(100), method = "single")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "single")

# A 1D-specific true median linkage
dendrogram &lt;- hclust1d(rnorm(100), method = "true_median")

# Plotting the resulting dendrogram
plot(dendrogram)

</code></pre>


</div>