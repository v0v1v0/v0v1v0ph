<div class="container">

<table style="width: 100%;"><tr>
<td>htlr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit a HTLR Model</h2>

<h3>Description</h3>

<p>This function trains linear logistic regression models with HMC in restricted Gibbs sampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">htlr(
  X,
  y,
  fsel = 1:ncol(X),
  stdx = TRUE,
  prior = "t",
  df = 1,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  init = "lasso",
  leap = 50,
  leap.warm = floor(leap/10),
  leap.stepsize = 0.3,
  cut = 0.05,
  verbose = FALSE,
  rep.legacy = FALSE,
  keep.warmup.hist = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Input matrix, of dimension nobs by nvars; each row is an observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of response variables. Must be coded as non-negative integers, 
e.g., 1,2,...,C for C classes, label 0 is also allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsel</code></td>
<td>
<p>Subsets of features selected before fitting, such as by univariate screening.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stdx</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the original feature values are standardized to have <code>mean = 0</code> 
and <code>sd = 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>The prior to be applied to the model. Either a list of hyperparameter settings 
returned by <code>htlr_prior</code> or a character string from "t" (student-t), "ghs" (horseshoe), 
and "neg" (normal-exponential-gamma).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The degree freedom of t/ghs/neg prior for coefficients. Will be ignored if the 
configuration list from <code>htlr_prior</code> is passed to <code>prior</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>A positive integer specifying the number of iterations (including warmup).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup (aka burnin). 
The number of warmup iterations should not be larger than iter and the default is <code>iter / 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>A positive integer specifying the period for saving samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>The initial state of Markov Chain; it accepts three forms:
</p>
 
<ul>
<li>
<p> a previously fitted <code>fithtlr</code> object, 
</p>
</li>
<li>
<p>  a user supplied initial coeficient matrix of (p+1)*K, where p is the number of features, K is the number of classes in y minus 1, 
</p>
</li>
<li>
<p> a character string matches the following:  
</p>

<ul>
<li>
<p> "lasso" - (Default) Use Lasso initial state with <code>lambda</code> chosen by 
cross-validation. Users may specify their own candidate <code>lambda</code> values via 
optional argument <code>lasso.lambda</code>. Further customized Lasso initial 
states can be generated by <code>lasso_deltas</code>.    
</p>
</li>
<li>
<p> "bcbc" - Use initial state generated by package <code>BCBCSF</code> 
(Bias-corrected Bayesian classification). Further customized BCBCSF initial 
states can be generated by <code>bcbcsf_deltas</code>. WARNING: This type of 
initial states can be used for continuous features such as gene expression profiles, 
but it should not be used for categorical features such as SNP profiles.
</p>
</li>
<li>
<p> "random" - Use random initial values sampled from N(0, 1).     
</p>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap</code></td>
<td>
<p>The length of leapfrog trajectory in sampling phase.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap.warm</code></td>
<td>
<p>The length of leapfrog trajectory in burnin phase.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leap.stepsize</code></td>
<td>
<p>The integrator step size used in the Hamiltonian simulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut</code></td>
<td>
<p>The coefficients smaller than this criteria will be fixed in each HMC updating step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; setting it to <code>TRUE</code> for tracking MCMC sampling iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep.legacy</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the output produced in <code>HTLR</code> versions up to 
legacy-3.1-1 is reproduced. The speed will be typically slower than non-legacy mode on
multi-core machine. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.warmup.hist</code></td>
<td>
<p>Warmup iterations are not recorded by default, set <code>TRUE</code> to enable it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li>
<p> rda.alpha - A user supplied alpha value for <code>bcbcsf_deltas</code>. Default: 0.2.
</p>
</li>
<li>
<p> lasso.lambda - A user supplied lambda sequence for <code>lasso_deltas</code>. 
Default: {.01, .02, ..., .05}. Will be ignored if <code>rep.legacy</code> is set to <code>TRUE</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with S3 class <code>htlr.fit</code>.
</p>


<h3>References</h3>

<p>Longhai Li and Weixin Yao (2018). Fully Bayesian Logistic Regression 
with Hyper-Lasso Priors for High-dimensional Feature Selection.
<em>Journal of Statistical Computation and Simulation</em> 2018, 88:14, 2827-2851.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(12345)
data("colon")

## fit HTLR models with selected features, note that the chain length setting is for demo only

## using t prior with 1 df and log-scale fixed to -10 
fit.t &lt;- htlr(X = colon$X, y = colon$y, fsel = 1:100,
              prior = htlr_prior("t", df = 1, logw = -10), 
              init = "bcbc", iter = 20, thin = 1)

## using NEG prior with 1 df and log-scale fixed to -10 
fit.neg &lt;- htlr(X = colon$X, y = colon$y, fsel = 1:100,
                prior = htlr_prior("neg", df = 1, logw = -10), 
                init = "bcbc", iter = 20, thin = 1)

## using horseshoe prior with 1 df and auto-selected log-scale   
fit.ghs &lt;- htlr(X = colon$X, y = colon$y, fsel = 1:100,
                prior = "ghs", df = 1, init = "bcbc",
                iter = 20, thin = 1)

</code></pre>


</div>