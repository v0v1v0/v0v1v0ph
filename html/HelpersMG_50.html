<div class="container">

<table style="width: 100%;"><tr>
<td>MHalgoGen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Monte-Carlo Markov-chain with Metropolis-Hastings algorithm</h2>

<h3>Description</h3>

<p>The parameters must be stored in a data.frame with named rows for each parameter with the following columns:<br></p>

<ul>
<li>
<p> Density. The density function name, example <code>dnorm</code>, <code>dlnorm</code>, <code>dunif</code>, <code>dbeta</code>
</p>
</li>
<li>
<p> Prior1. The first parameter to send to the <code>Density</code> function
</p>
</li>
<li>
<p> Prior2. The second parameter to send to the <code>Density</code> function
</p>
</li>
<li>
<p> SDProp. The standard error from new proposition value of this parameter
</p>
</li>
<li>
<p> Min. The minimum value for this parameter
</p>
</li>
<li>
<p> Max. The maximum value for this parameter
</p>
</li>
<li>
<p> Init. The initial value for this parameter
</p>
</li>
</ul>
<p>This script has been deeply modified from a MCMC script provided by Olivier Martin (INRA, Paris-Grignon).<br>
The likelihood function must use a parameter named parameters_name for the nammed parameters.<br>
For adaptive mcmc, see:<br>
Rosenthal, J. S. 2011. Optimal Proposal Distributions and Adaptive MCMC. Pages 93-112 in S. Brooks, A. Gelman,
G. Jones, and X.-L. Meng, editors. MCMC Handbook. Chapman and Hall/CRC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MHalgoGen(
  likelihood = stop("A likelihood function must be supplied"),
  parameters = stop("Priors  must be supplied"),
  ...,
  parameters_name = "x",
  n.iter = 10000,
  n.chains = 1,
  n.adapt = 100,
  thin = 30,
  trace = FALSE,
  traceML = FALSE,
  progress.bar.ini = NULL,
  progress.bar = NULL,
  adaptive = FALSE,
  adaptive.lag = 500,
  adaptive.fun = function(x) {
     ifelse(x &gt; 0.234, 1.3, 0.7)
 },
  intermediate = NULL,
  filename = "intermediate.Rdata",
  previous = NULL,
  session = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>likelihood</code></td>
<td>
<p>The function that returns -ln likelihood using data and parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>A data.frame with priors; see description and examples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Parameters to be transmitted to likelihood function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters_name</code></td>
<td>
<p>The name of the parameters in the likelihood function, default is "x"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>Number of iterations for each chain</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.chains</code></td>
<td>
<p>Number of chains</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.adapt</code></td>
<td>
<p>Number of iteration to stabilize likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Interval for thinning likelihoods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Or FALSE or period to show progress</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traceML</code></td>
<td>
<p>TRUE or FALSE to show ML</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress.bar.ini</code></td>
<td>
<p>The command to initialize progress bar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress.bar</code></td>
<td>
<p>The command to run the progress bar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive</code></td>
<td>
<p>Should an adaptive process for SDProp be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.lag</code></td>
<td>
<p>Lag to analyze the SDProp value in an adaptive context</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adaptive.fun</code></td>
<td>
<p>Function used to change the SDProp</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intermediate</code></td>
<td>
<p>Or NULL of period to save intermediate result</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>Name of file in which intermediate results are saved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>previous</code></td>
<td>
<p>The content of the file in which intermediate results are saved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>The shiny session</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>MHalgoGen is a function to use mcmc with Metropolis-Hastings algorithm
</p>


<h3>Value</h3>

<p>A mcmcComposite object with all characteristics of the model and mcmc run
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code>as.mcmc.mcmcComposite()</code>,
<code>as.parameters()</code>,
<code>as.quantiles()</code>,
<code>merge.mcmcComposite()</code>,
<code>plot.PriorsmcmcComposite()</code>,
<code>plot.mcmcComposite()</code>,
<code>setPriors()</code>,
<code>summary.mcmcComposite()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(HelpersMG)
require(coda)
val &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(0.35, 0.2), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
# Use of trace and traceML parameters
# trace=1 : Only one likelihood is printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
# trace=10 : 10 likelihoods are printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=10)
# trace=TRUE : all likelihoods are printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=TRUE)
# trace=FALSE : No likelihood is printed
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=FALSE)
# traceML=TRUE : values when likelihood is better are shown
mcmc_run &lt;- MHalgoGen(n.iter=100, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=TRUE, traceML=TRUE)
mcmc_run &lt;- MHalgoGen(n.iter=100, parameters=parameters_mcmc, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=FALSE, traceML=TRUE)

plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
library(graphics)
library(fields)
# show a scatter plot of the result
x &lt;- mcmc_run$resultMCMC[[1]][, 1]
y &lt;- mcmc_run$resultMCMC[[1]][, 2]
marpre &lt;- par(mar=c(4, 4, 2, 6)+0.4)
smoothScatter(x, y)
# show a scale
n &lt;- matrix(0, ncol=128, nrow=128)
xrange &lt;- range(x)
yrange &lt;- range(y)
for (i in 1:length(x)) {
  posx &lt;- 1+floor(127*(x[i]-xrange[1])/(xrange[2]-xrange[1]))
  posy &lt;- 1+floor(127*(y[i]-yrange[1])/(yrange[2]-yrange[1]))
  n[posx, posy] &lt;- n[posx, posy]+1
}
image.plot(legend.only=TRUE, zlim= c(0, max(n)), nlevel=128, 
 col=colorRampPalette(c("white", blues9))(128))
# Compare with a heatmap
x &lt;- seq(from=8, to=12, by=0.2)
y &lt;- seq(from=1, to=4, by=0.2)
df &lt;- expand.grid(mean=x, sd=y)
df &lt;- cbind(df, L=rep(0, length(nrow(df))))
for (i in 1:nrow(df)) df[i, "L"] &lt;- -sum(dnorm(val, df[i, 1], df[i, 2], log = TRUE))
hm &lt;- matrix(df[, "L"], nrow=length(x))
par(mar = marpre)
image.plot(x=x, y=y, z=hm, las=1)
# Diagnostic function from coda library
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, x=x, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, x=x, data=val, 
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)
# Here is how to use adaptive mcmc
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, adaptive = FALSE, 
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
1-rejectionRate(as.mcmc(mcmc_run))
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, adaptive = TRUE,  
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
1-rejectionRate(as.mcmc(mcmc_run))
# To see the dynamics :
var &lt;- "mean"
par(mar=c(4, 4, 1, 1)+0.4)
plot(1:nrow(mcmc_run$resultMCMC[[1]]), mcmc_run$resultMCMC[[1]][, var], type="l", 
       xlab="Iterations", ylab=var, bty="n", las=1)
# Exemple with a progress bar

val &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(0.35, 0.2), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
# Set up the progress bar
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=val, 
                      likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=FALSE, 
                       progress.bar.ini=function(n.iter) {
                                 assign("pb", txtProgressBar(min=0, max=n.iter, style=3), 
                                        env = parent.frame())}, 
        progress.bar=function(iter) {setTxtProgressBar(get("pb", envir = parent.frame()), iter)})
 

## End(Not run)
</code></pre>


</div>