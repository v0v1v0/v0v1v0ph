<div class="container">

<table style="width: 100%;"><tr>
<td>glm.napp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior of normalized asymptotic power prior (NAPP)</h2>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the normalized asymptotic power prior (NAPP) by
Ibrahim et al. (2015) <a href="doi:10.1002/sim.6728">doi:10.1002/sim.6728</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glm.napp(
  formula,
  family,
  data.list,
  offset.list = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>an object of class <code>family</code>. See <code>?stats::family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical datasets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on a0 vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code> in
<code>sample()</code> method in cmdstanr package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method in
cmdstanr package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The normalized asymptotic power prior (NAPP) assumes that the regression coefficients and logarithm of the
dispersion parameter are a multivariate normal distribution with mean equal to the maximum likelihood
estimate of the historical data and covariance matrix equal to <code class="reqn">a_0^{-1}</code> multiplied by the inverse Fisher
information matrix of the historical data, where <code class="reqn">a_0</code> is the power prior parameter (treated as random).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Ibrahim, J. G., Chen, M., Gwon, Y., and Chen, F. (2015). The power prior: Theory and applications. Statistics in Medicine, 34(28), 3724â€“3749.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (instantiate::stan_cmdstan_exists()) {
  data(actg019)
  data(actg036)
  ## take subset for speed purposes
  actg019 = actg019[1:100, ]
  actg036 = actg036[1:50, ]
  data_list = list(currdata = actg019, histdata = actg036)
  glm.napp(
    formula = cd4 ~ treatment + age + race,
    family = poisson('log'),
    data.list = data_list,
    chains = 1, iter_warmup = 500, iter_sampling = 1000
  )
}
</code></pre>


</div>