<div class="container">

<table style="width: 100%;"><tr>
<td>hywavwn.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hybrid wavelet test of white noise.
</h2>

<h3>Description</h3>

<p>Combines the general wavelet test <code>genwwn.test</code>
at the medium-coarse scales and the Haar wavelet test at
fine scales.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hywavwn.test(x, away.from = "standard", lowlev = 0, plot.it = FALSE,
	stopeveryscale = FALSE, filter.number = 10,
	family = "DaubExPhase", mc.method = p.adjust.methods,
	verbose = FALSE, n.cdf.grid = 1000, mac.spread = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The time series you wish to test (of dyadic length).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>away.from</code></td>
<td>
<p>Number of fine scales to stay away from, see details below.
If "standard" then this is automatically computed for sample sizes
up to length of 1024. If you have a longer series then the test
will still work but might not be quite as powerful (but probably
not too bad either).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowlev</code></td>
<td>
<p>The coarsest coefficient to evaluate. This should
always be left at 0. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>
<p>If TRUE then a series of plots similar to the ones produced
in the <code>hwwn.test</code> function is produced. See that help
page for further details on what the plots show.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopeveryscale</code></td>
<td>
<p>If TRUE then if <code>plot.it=TRUE</code> then a
‘scan’ is issued after every plot. Just hit RETURN to continue.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.number</code></td>
<td>
<p>The number of vanishing moments of the wavelet
used to compute coefficients that are then evaluated to see whether
they are zero. In principle, best compression for a sparse evaluation
of the normalized spectrum should mean we use the smoothest wavelets
with the highest number of vanishing moments which is ten. The
other components of the function are optimized for ten vanishing
moments. The function will still work for other numbers of vanishing
moments but maybe with slightly reduced power.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Wavelet family to go with <code>filter.number</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.method</code></td>
<td>
<p>The type of multiple hypothesis correction, see
<code>p.adjust</code> for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> some information messages are printed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.cdf.grid</code></td>
<td>
<p>The CDF of the Macdonald distribution is evaluated
numerically. This argument controls the resolution of that
grid: it controls the number of grid points there are between
<code>-mac.spread</code> and <code>mac.spread</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mac.spread</code></td>
<td>
<p>Horizontal range for plotting of wavelet coefficients,
only used if <code>plot.it=TRUE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>genwwn.test</code> performs pretty well, but does
not pick up departures from the null at the finest scale of
wavelet coefficients because it does not look at those scales
(because of the ‘away.from’ argument and the asymptotic normality
that <code>genwwn.test</code> does not kick in at those finer
scales). So, this test augments the <code>genwwn.test</code>
with the finest scales results from <code>hwwn.test</code>.
Those scales finer than <code>away.from</code> use the Haar wavelet
and those coarser than <code>away.from</code> use the general wavelet.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code> with the following components.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p.val.collector</code></td>
<td>
<p>All the of unadjusted p-values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.val.adjust</code></td>
<td>
<p>All of the adjusted p-values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>The overall p-value of the test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>A text string describing the test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.val.collector.hw</code></td>
<td>
<p>The of unadjusted p-values from the Haar wavelet levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.val.collector.gw</code></td>
<td>
<p>The of unadjusted p-values from the general wavelet levels</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Delyan Savchev and Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. and Savchev, D. (2014) White noise testing using
wavelets. <em>Stat</em>, <b>3</b>, 351-362.
<a href="https://doi.org/10.1002/sta4.69">doi:10.1002/sta4.69</a>
</p>


<h3>See Also</h3>

 <p><code>genwwn.test</code>, <code>hwwn.test</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#
# Test data
#
x &lt;- rnorm(64)
#
# Do the test
#
answer &lt;- hywavwn.test(x)
#
# The result in my case was:
#
#answer
#
#	Hybrid Wavelet Test of White Noise
#
#data:  
#p-value = 0.02305
</code></pre>


</div>