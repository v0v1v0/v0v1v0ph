<div class="container">

<table style="width: 100%;"><tr>
<td>testdata</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Description of the testdata</h2>

<h3>Description</h3>

<p>The data set contains paternal haplotypes, maternal LD and
genetic map positions that are required to calculate the covariance between
pairs of markers.
</p>

<p>The raw data can be downloaded at the source given below. Then,
executing the following R code leads to the data that have been provided as
<code>testdata.RData</code>.
</p>
<dl>
<dt>H.sire</dt>
<dd>
<p>(2N x p) haplotype matrix for sires for all chromosomes
(2 lines per sire)</p>
</dd>
<dt>matLD</dt>
<dd>
<p>(p x p) matrix of maternal LD between pairs of p markers;
matrix is block diagonal in case of multiple chromosomes</p>
</dd>
<dt>pos.chr</dt>
<dd>
<p>list of vectors of genetic map positions per chromosome</p>
</dd>
</dl>
<h3>Source</h3>

<p>The data are available from RADAR doi: <a href="https://doi.org/10.22000/280">10.22000/280</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## data.frame of estimates of paternal recombination rate and maternal LD
load('Result.RData')
## list of haplotypes of sires for each chromosome
load('sire_haplotypes.RData')
## physical map
map &lt;- read.table('map50K_ARS_reordered.txt', header = T)
## select target region
chr &lt;- 1
window &lt;- 301:600
## map information of target region
map.target &lt;- map[map$Chr == chr, ][window, ]
Result.target &lt;- Result[(Result$Chr == chr) &amp; (Result$SNP1 %in% window) &amp;
  (Result$SNP2 %in% window), ]
## SNP position in Morgan approximated from recombination rate
part &lt;- Result.target[Result.target$SNP1 == window[1], ]
sp &lt;- smooth.spline(x = map.target$locus_Mb[part$SNP2 - window[1] + 1], y = part$Theta, df = 4)
pos.snp &lt;- predict(sp, x =  map.target$locus_Mb[window - window[1] + 1])$y
## list of SNPs positions
pos.chr &lt;- list(pos.snp)
## haplotypes of sires (mating candidates) in target region
H.sire &lt;- rlist::list.rbind(haps[[chr]])[, window]
## matrix of maternal LD (block diagonal if multiple chromosome)
matLD &lt;- matrix(0, ncol = length(window), nrow = length(window))
## off-diagonal elements
for(l in 1:nrow(Result.target)){
  id1 &lt;- Result.target$SNP1[l] - window[1] + 1
  id2 &lt;- Result.target$SNP2[l] - window[1] + 1
  matLD[id1, id2] &lt;- matLD[id2, id1] &lt;- Result.target$D[l]
}
## diagonal elements
for(k in unique(Result.target$SNP1)){
  id &lt;- k - window[1] + 1
  p &lt;- Result.target$fAA[Result.target$SNP1 == k] + Result.target$fAB[Result.target$SNP1 == k]
  matLD[id, id] &lt;- max(p * (1 - p))
}

## End(Not run)
</code></pre>


</div>