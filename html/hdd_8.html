<div class="container">

<table style="width: 100%;"><tr>
<td>hdd_merge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Merges data to a HDD file</h2>

<h3>Description</h3>

<p>This function merges in-memory/HDD data to a HDD file.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hdd_merge(
  x,
  y,
  newfile,
  chunkMB,
  rowsPerChunk,
  all = FALSE,
  all.x = all,
  all.y = all,
  allow.cartesian = FALSE,
  replace = FALSE,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A HDD object or a <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A data set either a data.frame of a HDD object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newfile</code></td>
<td>
<p>Destination of the result, i.e., a destination folder that will
receive the HDD data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunkMB</code></td>
<td>
<p>Numeric, default is missing. If provided, the data 'x' is split
in chunks of 'chunkMB' MB and the merge is applied chunkwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowsPerChunk</code></td>
<td>
<p>Integer, default is missing. If provided, the data 'x' is
split in chunks of 'rowsPerChunk' rows and the merge is applied chunkwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.x</code></td>
<td>
<p>Default is <code>all</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.y</code></td>
<td>
<p>Default is <code>all</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow.cartesian</code></td>
<td>
<p>Logical: whether to allow cartesian merge. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Default is <code>FALSE</code>: if the destination folder already contains
data, whether to replace it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Numeric. Whether information on the advancement should be displayed.
If equal to 0, nothing is displayed. By default it is equal to 1 if the size
of <code>x</code> is greater than 1GB.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>x</code> (resp <code>y</code>) is a HDD object, then the merging will be operated
chunkwise, with the original chunks of the objects. To change the size of the
chunks for <code>x</code>: you can use the argument <code>chunkMB</code> or <code>rowsPerChunk.</code>
</p>
<p>To change the chunk size of <code>y</code>, you can rewrite <code>y</code> with a new chunk
size using <code>write_hdd</code>.
</p>
<p>Note that the merging operation could also be achieved with <code>hdd_slice</code>
(although it would require setting up an ad hoc function).
</p>


<h3>Value</h3>

<p>This function does not return anything. It applies the merging between
two potentially large (out of memory) data set and saves them on disk at the location
of <code>newfile</code>, the destination folder which will be populated with .fst files
representing chunks of the resulting merge.
</p>
<p>To interact with the data (on disk) newly created, use the function <code>hdd()</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See <code>hdd</code>, <code>sub-.hdd</code> and <code>cash-.hdd</code>
for the extraction and manipulation of out of memory data. For importation of
HDD data sets from text files: see <code>txt2hdd</code>.
</p>
<p>See <code>hdd_slice</code> to apply functions to chunks of data (and create
HDD objects) and <code>hdd_merge</code> to merge large files.
</p>
<p>To create/reshape HDD objects from memory or from other HDD objects, see
<code>write_hdd</code>.
</p>
<p>To display general information from HDD objects: <code>origin</code>,
<code>summary.hdd</code>, <code>print.hdd</code>,
<code>dim.hdd</code> and <code>names.hdd</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Toy example with iris data

# Cartesian merge example
iris_bis = iris
names(iris_bis) = c(paste0("x_", 1:4), "species_bis")
# We must have a common key on which to merge
iris_bis$id = iris$id = 1

# merge, we chunk 'x' by 50 rows
hdd_path = tempfile()
hdd_merge(iris, iris_bis, newfile = hdd_path,
		  rowsPerChunk = 50, allow.cartesian = TRUE)

base_merged = hdd(hdd_path)
summary(base_merged)
print(base_merged)

</code></pre>


</div>