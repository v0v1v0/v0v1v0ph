<div class="container">

<table style="width: 100%;"><tr>
<td>higlasso</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hierarchical Integrative Group LASSO</h2>

<h3>Description</h3>

<p>HiGLASSO is a regularization based selection method designed to detect
non-linear interactions between variables, particularly exposures in
environmental health studies.
</p>


<h3>Usage</h3>

<pre><code class="language-R">higlasso(
  Y,
  X,
  Z,
  method = c("aenet", "gglasso"),
  lambda1 = NULL,
  lambda2 = NULL,
  nlambda1 = 10,
  nlambda2 = 10,
  lambda.min.ratio = 0.05,
  sigma = 1,
  degree = 2,
  maxit = 5000,
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>A length n numeric response vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A n x p numeric matrix of covariates to basis expand</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>A n x m numeric matrix of non basis expanded and non
regularized covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Type of initialization to use. Possible choices are <code>gglasso</code>
for group LASSO and <code>aenet</code> for adaptive elastic net. Default is
<code>aenet</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p>A numeric vector of main effect penalties on which to tune
By default, <code>lambda1 = NULL</code> and higlasso generates a length
<code>nlambda1</code> sequence of lambda1s based off of the data and
<code>min.lambda.ratio</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p>A numeric vector of interaction effects penalties on which to
tune. By default, <code>lambda2 = NULL</code> and generates a sequence (length
<code>nlambda2</code>) of lambda2s based off of the data and
<code>min.lambda.ratio</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda1</code></td>
<td>
<p>The number of lambda1 values to generate. Default is 10,
minimum is 2. If <code>lambda1 != NULL</code>, this parameter is ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda2</code></td>
<td>
<p>The number of lambda2 values to generate. Default is 10,
minimum is 2. If <code>lambda2 != NULL</code>, this parameter is ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>
<p>Ratio that calculates min lambda from max lambda.
Ignored if 'lambda1' or 'lambda2' is non NULL. Default is 0.05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Scale parameter for integrative weights. Technically a third
tuning parameter but defaults to 1 for computational tractability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>Degree of <code>bs</code> basis expansion. Default is 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations. Default is 5000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance for convergence. Default is 1e-5</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>There are a few things to keep in mind when using <code>higlasso</code>
</p>

<ul>
<li>
<p><code>higlasso</code> uses the strong heredity principle. That is,
<code>X_1</code> and <code>X_2</code> must included as main effects before the
interaction <code>X_1 X_2</code> can be included.

</p>
</li>
<li>
<p>While <code>higlasso</code> uses integrative weights to help with
estimation, <code>higlasso</code> is more of a selection method.
As a result, <code>higlasso</code> does not output coefficient estimates,
only which variables are selected.

</p>
</li>
<li>
<p>Simulation studies suggest that <code>higlasso</code> is a very
conservative method when it comes to selecting interactions.
That is, <code>higlasso</code> has a low false positive rate and the
identification of a nonlinear interaction is a good indicator that
further investigation is worthwhile.

</p>
</li>
<li>
<p><code>higlasso</code> can be slow, so it may may be beneficial to
tweak some of its settings (for example, <code>nlambda1</code> and
<code>nlambda2</code>) to get a handle on how long the method will take
before running the full model.
</p>
</li>
</ul>
<h3>Value</h3>

<p>An object of type "higlasso" with 4 elements:
</p>

<dl>
<dt>lambda</dt>
<dd>
<p>An <code>nlambda1 x nlambda2 x 2</code> array containing each
pair <code>(lambda1, lambda2)</code> pair.</p>
</dd>
<dt>selected</dt>
<dd>
<p>An <code>nlambda1 x nlambda2 x ncol(X)</code> array containing
higlasso's selections for each lambda pair.</p>
</dd>
<dt>df</dt>
<dd>
<p>The number of nonzero selections for each lambda pair.</p>
</dd>
<dt>call</dt>
<dd>
<p>The call that generated the output.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Alexander Rix
</p>


<h3>References</h3>

<p>A Hierarchical Integrative Group LASSO (HiGLASSO) Framework for Analyzing
Environmental Mixtures. Jonathan Boss, Alexander Rix, Yin-Hsiu Chen, Naveen N.
Narisetty, Zhenke Wu, Kelly K. Ferguson, Thomas F. McElrath, John D. Meeker,
Bhramar Mukherjee. 2020.
arXiv:2003.12844
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(higlasso)

X &lt;- as.matrix(higlasso.df[, paste0("V", 1:7)])
Y &lt;- higlasso.df$Y
Z &lt;- matrix(1, nrow(X))


# This can take a bit of time
higlasso.fit &lt;- higlasso(Y, X, Z)

</code></pre>


</div>