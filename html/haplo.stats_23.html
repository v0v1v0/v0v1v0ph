<div class="container">

<table style="width: 100%;"><tr>
<td>haplo.em</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
EM Computation of Haplotype Probabilities, with Progressive Insertion
of Loci
</h2>

<h3>Description</h3>

<p>For genetic marker phenotypes measured on unrelated subjects, with 
linkage phase unknown, compute maximum likelihood estimates of
haplotype probabilities.  Because linkage phase is unknown, there 
may be  more than one pair of haplotypes that are consistent with 
the oberved marker phenotypes, so posterior probabilities of pairs 
of haplotypes for each subject are also computed. Unlike the usual EM
which attempts to enumerate all possible pairs of haplotypes before
iterating over the EM steps,  this "progressive insertion" algorithm 
progressively inserts batches of loci into haplotypes of growing
lengths, runs the EM steps, trims off
pairs of haplotypes per subject when the posterior probability of the
pair is below a specified threshold, and then continues these
insertion, EM, and trimming steps until all loci are inserted into the
haplotype. The user can choose the batch size. If the batch size
is chosen to be all loci, and the threshold for trimming is set to
0, then this algorithm reduces to the usual EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">haplo.em(geno, locus.label=NA, miss.val=c(0, NA), weight, control= 
           haplo.em.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>geno</code></td>
<td>

<p>matrix of alleles, such that each locus has a pair of adjacent 
columns of alleles, and the order of columns corresponds to 
the order of loci on a chromosome.  If there are K loci, then 
ncol(geno) = 2*K. Rows represent the alleles for each subject.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locus.label </code></td>
<td>

<p>vector of labels for loci.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>miss.val </code></td>
<td>

<p>vector of values that represent missing alleles in geno.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>weights for observations (rows of geno matrix).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>list of control parameters. The default is constructed by the function
haplo.em.control. The default behavior of this function results in the
following parameter settings:  loci.insert.order=1:n.loci, 
insert.batch.size=min(4,n.loci), min.posterior= 0.0001, tol=0.00001,
max.iter=500, random.start=0 (no random start), iseed=NULL (no saved
seed to start random start), verbose=0 (no printout during EM
iterations). See haplo.em.control for more details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The basis of this progressive insertion algorithm is from the sofware
snphap by David Clayton. Although some of the features and control
parameters of this S-PLUS version are modeled after snphap, there are
substantial differences, such as extension to allow for more than two
alleles per locus, and some other nuances on how the alogrithm is implemented.
</p>


<h3>Value</h3>

<p>list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>converge</code></td>
<td>

<p>indicator of convergence of the EM algorithm
(1 = converge, 0 = failed).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lnlike</code></td>
<td>

<p>value of lnlike at last EM iteration (maximum lnlike if converged).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lnlike.noLD</code></td>
<td>

<p>value of lnlike under the null of linkage equilibrium at all loci.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr</code></td>
<td>

<p>likelihood ratio statistic to test the final lnlike against the
lnlike that assumes complete linkage equilibrium among all loci
(i.e., haplotype frequencies are products of allele frequencies).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.lr</code></td>
<td>

<p>degrees of freedom for likelihood ratio statistic. The df for the
unconstrained final model is the  number of non-zero haplotype frequencies
minus 1, and the df for the null model of complete linkage 
equilibrium is the sum, over all loci, of (number of alleles - 1). The
df for the lr statistic is df[unconstrained] - df[null]. This can
result in negative df, if many haplotypes are estimated to have zero 
frequency, or if a large amount of trimming occurs, when using large
values of min.posterior in the list of control parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hap.prob</code></td>
<td>

<p>vector of mle's of haplotype probabilities.  The ith
element of hap.prob corresponds to the ith row of 
haplotype.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>locus.label</code></td>
<td>

<p>vector of labels for loci, of length K 
(see definition of input values).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subj.id</code></td>
<td>

<p>vector of id's for subjects used in the analysis, based on row number
of input geno matrix. If subjects are removed, then their id will be
missing from subj.id.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows.rem</code></td>
<td>

<p>now defunct, but set equal to a vector of length 0, to be compatible 
with other functions that check for rows.rem.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indx.subj</code></td>
<td>

<p>vector for row index of subjects after expanding to all 
possible pairs of haplotypes for each person.  If indx.subj=i, 
then i is the ith row of  geno.  If the ith 
subject has n possible pairs of haplotypes that correspond 
to their marker genotype, then i is repeated n times.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nreps</code></td>
<td>

<p>vector for the count of haplotype pairs that map to
each subject's marker genotypes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.pairs</code></td>
<td>

<p>vector of maximum number of pairs of haplotypes per subject that are
consistent with their marker data in the matrix geno. The
length of max.pairs  = nrow(geno). This vector is computed by  
geno.count.pairs.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hap1code</code></td>
<td>

<p>vector of codes for each subject's first haplotype.
The values in hap1code are the row numbers of the unique
haplotypes in the returned matrix haplotype.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hap2code</code></td>
<td>

<p>similar to hap1code, but for each subject's second haplotype.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post</code></td>
<td>

<p>vector of posterior probabilities of pairs of haplotypes for 
a person, given their marker phenotypes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>haplotype</code></td>
<td>

<p>matrix of unique haplotypes. Each row represents a unique 
haplotype, and the number of columns is the number of loci.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>list of control parameters for algorithm. See haplo.em.control
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Sorted order of haplotypes with character alleles is system-dependent,
and can be controlled via the LC_COLLATE locale environment
variable. Different locale settings can cause results to be
non-reproducible even when controlling the random seed. 
</p>


<h3>See Also</h3>

<p><code>setupGeno</code>,
<code>haplo.em.control</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(hla.demo)
attach(hla.demo)
geno &lt;- hla.demo[,c(17,18,21:24)]
label &lt;-c("DQB","DRB","B")
keep &lt;- !apply(is.na(geno) | geno==0, 1, any)

save.em.keep &lt;- haplo.em(geno=geno[keep,], locus.label=label)

# warning: output will not exactly match

print.haplo.em(save.em.keep)
</code></pre>


</div>