<div class="container">

<table style="width: 100%;"><tr>
<td>aggregate.hac</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregation of variables
</h2>

<h3>Description</h3>

<p><code>aggregate</code> tests, whether the absolute difference of the parameters of two subsequent nodes is smaller than a constant, i.e. <code class="reqn">\vert \theta_{2} - \theta_{1} \vert &lt; \epsilon</code>, where <code class="reqn">\theta_{i}</code> denotes the dependency parameter with <code class="reqn">\theta_{2} &lt; \theta_{1}</code>, <code class="reqn">\epsilon \geq 0</code>. If the absolute difference is smaller than the constant, the variables of the nodes are aggregated in a single node with new dependency parameter, e.g. <code class="reqn"> \theta_{new} = (\theta_{1} + \theta_{2})/2</code>. This procedure is applied to all consecutive nodes of the HAC <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'hac'
aggregate(x, epsilon = 0, method = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an object of the class <span class="env">hac</span>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>

<p>scalar <code class="reqn">\geq 0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>determines, whether the new parameter is the <code>"mean"</code>, <code>"min"</code> or <code>"max"</code> of the fused parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of the class <span class="env">hac</span>.
</p>


<h3>See Also</h3>

<p><code>hac</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1:
# an object of the class hac is constructed, whose parameters are close
copula = hac(type = 1, tree = list("X1", list("X2", "X3", 2.05), 2))

# the function aggregate returns a simple Archimedean copula

copula_ag = aggregate(copula, epsilon = 0.1)
tree2str(copula_ag) # [1] "(X1.X2.X3)_{2.02}"

# the structure does not change for a smaller epsilon

copula_ag = aggregate(copula, epsilon = 0.01)
tree2str(copula_ag) # [1] "((X2.X3)_{2.05}.X1)_{2}"

# Example 2:
# consider the binary tree

Object = hac.full(type = 1, y = c("X1", "X2", "X3", "X4", "X5"), 
theta = c(1.01, 1.02, 2, 2.01))

tree2str(Object) # [1] "((((X5.X4)_{2.01}.X3)_{2}.X2)_{1.02}.X1)_{1.01}"

# applying aggregate.hac with epsilon = 0.02 leads to

Object_ag = aggregate(Object, 0.02)
tree2str(Object_ag) # [1] "((X3.X5.X4)_{2}.X1.X2)_{1.02}"
</code></pre>


</div>