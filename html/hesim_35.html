<div class="container">

<table style="width: 100%;"><tr>
<td>CohortDtstm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cohort discrete time state transition model</h2>

<h3>Description</h3>

<p>Simulate outcomes from a cohort discrete time state transition model.
</p>


<h3>Format</h3>

<p>An R6::R6Class object.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>trans_model</code></dt>
<dd>
<p>The model for health state transitions. Must be an object
of class <code>CohortDtstmTrans</code>.</p>
</dd>
<dt><code>utility_model</code></dt>
<dd>
<p>The model for health state utility. Must be an object of
class <code>StateVals</code>.</p>
</dd>
<dt><code>cost_models</code></dt>
<dd>
<p>The models used to predict costs by health state.
Must be a list of objects of class <code>StateVals</code>, where each element of the
list represents a different cost category.</p>
</dd>
<dt><code>stateprobs_</code></dt>
<dd>
<p>An object of class <code>stateprobs</code> simulated using <code style="white-space: pre;">⁠$sim_stateprobs()⁠</code>.</p>
</dd>
<dt><code>qalys_</code></dt>
<dd>
<p>An object of class <code>qalys</code> simulated using <code style="white-space: pre;">⁠$sim_qalys()⁠</code>.</p>
</dd>
<dt><code>costs_</code></dt>
<dd>
<p>An object of class <code>costs</code> simulated using <code style="white-space: pre;">⁠$sim_costs()⁠</code>.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CohortDtstm-new"><code>CohortDtstm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-sim_stateprobs"><code>CohortDtstm$sim_stateprobs()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-sim_qalys"><code>CohortDtstm$sim_qalys()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-sim_costs"><code>CohortDtstm$sim_costs()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-summarize"><code>CohortDtstm$summarize()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortDtstm-clone"><code>CohortDtstm$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-CohortDtstm-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>CohortDtstm</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$new(trans_model = NULL, utility_model = NULL, cost_models = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>trans_model</code></dt>
<dd>
<p>The <code>trans_model</code> field.</p>
</dd>
<dt><code>utility_model</code></dt>
<dd>
<p>The <code>utility_model</code> field.</p>
</dd>
<dt><code>cost_models</code></dt>
<dd>
<p>The <code>cost_models</code> field.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>CohortDtstm</code> object.
</p>


<hr>
<a id="method-CohortDtstm-sim_stateprobs"></a>



<h4>Method <code>sim_stateprobs()</code>
</h4>

<p>Simulate health state probabilities using <code>CohortDtstmTrans$sim_stateprobs()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$sim_stateprobs(n_cycles)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_cycles</code></dt>
<dd>
<p>The number of model cycles to simulate the model for.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class stateprobs
stored in <code>stateprobs_</code>.
</p>


<hr>
<a id="method-CohortDtstm-sim_qalys"></a>



<h4>Method <code>sim_qalys()</code>
</h4>

<p>Simulate quality-adjusted life-years (QALYs) as a function of <code>stateprobs_</code> and
<code>utility_model</code>. See <code>sim_qalys()</code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$sim_qalys(
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  lys = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt>
<dd>
<p>Discount rate.</p>
</dd>
<dt><code>integrate_method</code></dt>
<dd>
<p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> for the trapezoid rule,
<code>riemann_left</code> for a left Riemann sum, and
<code>riemann_right</code> for a right Riemann sum.</p>
</dd>
<dt><code>lys</code></dt>
<dd>
<p>If <code>TRUE</code>, then life-years are simulated in addition to QALYs.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class qalys stored
in <code>qalys_</code>.
</p>


<hr>
<a id="method-CohortDtstm-sim_costs"></a>



<h4>Method <code>sim_costs()</code>
</h4>

<p>Simulate costs as a function of <code>stateprobs_</code> and <code>cost_models</code>.
See <code>sim_costs()</code> for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$sim_costs(
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dr</code></dt>
<dd>
<p>Discount rate.</p>
</dd>
<dt><code>integrate_method</code></dt>
<dd>
<p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> for the trapezoid rule,
<code>riemann_left</code> for a left Riemann sum, and
<code>riemann_right</code> for a right Riemann sum.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An instance of <code>self</code> with simulated output of class costs stored
in <code>costs_</code>.
</p>


<hr>
<a id="method-CohortDtstm-summarize"></a>



<h4>Method <code>summarize()</code>
</h4>

<p>Summarize costs and QALYs so that cost-effectiveness analysis can be performed.
See <code>summarize_ce()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$summarize(by_grp = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>by_grp</code></dt>
<dd>
<p>If <code>TRUE</code>, then costs and QALYs are computed by subgroup. If
<code>FALSE</code>, then costs and QALYs are aggregated across all patients (and subgroups).</p>
</dd>
</dl>
</div>


<hr>
<a id="method-CohortDtstm-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortDtstm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p><a href="https://arxiv.org/abs/2102.09437">Incerti and Jansen (2021)</a>.
See Section 2.1 for a description of a cohort DTSTM and details on
simulating costs and QALYs from state probabilities. An example in oncology
is provided in Section 4.3.
</p>


<h3>See Also</h3>

<p><code>CohortDtstm</code> objects can be created from model objects as
documented in <code>create_CohortDtstm()</code>. The <code>CohortDtstmTrans</code> documentation
describes the class for the transition model and the <code>StateVals</code> documentation
describes the class for the cost and utility models. A <code>CohortDtstmTrans</code>
object is typically created using <code>create_CohortDtstmTrans()</code>.
</p>
<p>There are currently three relevant vignettes. <code>vignette("markov-cohort")</code>
details a relatively simple Markov model and
<code>vignette("markov-inhomogeneous-cohort")</code> describes a more complex time
inhomogeneous model in which transition probabilities vary in every model
cycle. The <code>vignette("mlogit")</code> shows how a transition model can be parameterized
using a multinomial logistic regression model when transition data is collected
at evenly spaced intervals.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("data.table")
library("ggplot2")
theme_set(theme_bw())
set.seed(102)

# NOTE: This example replicates the "Simple Markov cohort model" 
# vignette using a different approach. Here, we explicitly construct
# the transition probabilities "by hand". In the vignette, the transition 
# probabilities are defined using expressions (i.e., by using 
# `define_model()`). The `define_model()` approach does (more or less) what 
# is done here under the hood.

# (0) Model setup
hesim_dat &lt;- hesim_data(
  strategies = data.table(
    strategy_id = 1:2,
    strategy_name = c("Monotherapy", "Combination therapy")
  ),
  patients &lt;- data.table(patient_id = 1),
  states = data.table(
    state_id = 1:3,
    state_name = c("State A", "State B", "State C")
  )
)
n_states &lt;- nrow(hesim_dat$states) + 1
labs &lt;- get_labels(hesim_dat)

# (1) Parameters
n_samples &lt;- 10 # Number of samples for PSA

## Transition matrix
### Input data (one transition matrix for each parameter sample,
###             treatment strategy, patient, and time interval)
p_id &lt;- tpmatrix_id(expand(hesim_dat, times = c(0, 2)), n_samples)
N &lt;- nrow(p_id)

### Transition matrices (one for each row in p_id)
p &lt;- array(NA, dim = c(n_states, n_states, nrow(p_id)))

#### Baseline risk
trans_mono &lt;- rbind(
  c(1251, 350, 116, 17),
  c(0, 731, 512, 15),
  c(0, 0, 1312, 437),
  c(0, 0, 0, 469)
)
mono_ind &lt;- which(p_id$strategy_id == 1 | p_id$time_id == 2)
p[,, mono_ind] &lt;- rdirichlet_mat(n = 2, trans_mono)

#### Apply relative risks
combo_ind &lt;- setdiff(1:nrow(p_id), mono_ind)
lrr_se &lt;- (log(.710) - log(.365))/(2 * qnorm(.975))
rr &lt;- rlnorm(n_samples, meanlog = log(.509), sdlog = lrr_se)
rr_indices &lt;- list( # Indices of transition matrix to apply RR to
  c(1, 2), c(1, 3), c(1, 4),
  c(2, 3), c(2, 4),
  c(3, 4)
)
rr_mat &lt;- matrix(rr, nrow = n_samples, ncol = length(rr_indices))
p[,, combo_ind] &lt;- apply_rr(p[, , mono_ind],
                            rr = rr_mat,
                            index = rr_indices)
tp &lt;- tparams_transprobs(p, p_id)

## Utility
utility_tbl &lt;- stateval_tbl(
  data.table(
    state_id = 1:3,
    est = c(1, 1, 1)
  ),
  dist = "fixed"
)

## Costs
drugcost_tbl &lt;- stateval_tbl(
  data.table(
    strategy_id = c(1, 1, 2, 2),
    time_start = c(0, 2, 0, 2),
    est = c(2278, 2278, 2278 + 2086.50, 2278)
  ),
  dist = "fixed"
)

dmedcost_tbl &lt;- stateval_tbl(
  data.table(
    state_id = 1:3,
    mean = c(A = 1701, B = 1774, C = 6948),
    se = c(A = 1701, B = 1774, C = 6948)
  ),
  dist = "gamma"
)

cmedcost_tbl &lt;- stateval_tbl(
  data.table(
    state_id = 1:3,
    mean = c(A = 1055, B = 1278, C = 2059),
    se = c(A = 1055, B = 1278, C = 2059)
  ),
  dist = "gamma"
)

# (2) Simulation
## Constructing the economic model
### Transition probabilities
transmod &lt;- CohortDtstmTrans$new(params = tp)

### Utility
utilitymod &lt;- create_StateVals(utility_tbl,
                               hesim_data = hesim_dat,
                               n = n_samples)

### Costs
drugcostmod &lt;- create_StateVals(drugcost_tbl,
                                hesim_data = hesim_dat,
                                n = n_samples)
dmedcostmod &lt;- create_StateVals(dmedcost_tbl,
                                hesim_data = hesim_dat,
                                n = n_samples)
cmedcostmod &lt;- create_StateVals(cmedcost_tbl,
                                hesim_data = hesim_dat,
                                n = n_samples)
costmods &lt;- list(drug = drugcostmod,
                 direct_medical = dmedcostmod,
                 community_medical = cmedcostmod)

### Economic model
econmod &lt;- CohortDtstm$new(trans_model = transmod,
                           utility_model = utilitymod,
                           cost_models = costmods)

## Simulating outcomes
econmod$sim_stateprobs(n_cycles = 20)
autoplot(econmod$stateprobs_, ci = TRUE, ci_style = "ribbon",
         labels = labs)
econmod$sim_qalys(dr = 0, integrate_method = "riemann_right")
econmod$sim_costs(dr = 0.06, integrate_method = "riemann_right")

# (3) Decision analysis
ce_sim &lt;- econmod$summarize()
wtp &lt;- seq(0, 25000, 500)
cea_pw_out &lt;- cea_pw(ce_sim, comparator = 1, dr_qalys = 0, dr_costs = .06,
                     k = wtp)
format(icer(cea_pw_out))
</code></pre>


</div>