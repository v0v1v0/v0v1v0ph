<div class="container">

<table style="width: 100%;"><tr>
<td>shakeandbake</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
"Shake and Bake" sampler
</h2>

<h3>Description</h3>

<p>The "Shake and Bake" method generates a Markov Chain whose stable state converges on the uniform distribution over a the boundary of a convex polytope defined by a set of linear inequality constraints. <code>shakeandbake</code> further uses the Moore-Penrose pseudo-inverse to eliminate an arbitrary set of linear equality constraints before applying the "Shake and Bake" sampler.
</p>
<p><code>sab.init</code> and <code>sab.run</code> together provide a re-entrant version of <code>shakeandbake</code> so that the Markov chain can be continued if convergence is not satisfactory.
</p>


<h3>Usage</h3>

<pre><code class="language-R">shakeandbake(constr, n.samples=1E4,
    thin.fn = function(n) { ceiling(log(n + 1)/4 * n^3) }, thin = NULL,
    x0.randomize=FALSE, x0.method="slacklp", x0 = NULL, eliminate = TRUE)

sab.init(constr,
    thin.fn = function(n) { ceiling(log(n + 1)/4 * n^3) }, thin = NULL,
    x0.randomize=FALSE, x0.method="slacklp", x0 = NULL, eliminate = TRUE)

sab.run(state, n.samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>constr</code></td>
<td>
<p>Linear constraints that define the sampling space (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.samples</code></td>
<td>
<p>The desired number of samples to return. The sampler is run for <code>n.samples * thin</code> iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin.fn</code></td>
<td>
<p>Function that specifies a thinning factor depending on the dimension of the sampling space after equality constraints have been eliminated. Will only be invoked if <code>thin</code> is <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>Seed point for the Markov Chain. The seed point is specified in the original space, and transformed to the sampling space automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0.method</code></td>
<td>
<p>Method to generate the seed point if <code>x0</code> is unspecified, see <code>createSeedPoint</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0.randomize</code></td>
<td>
<p>Whether to generate a random seed point if <code>x0</code> is unspecified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eliminate</code></td>
<td>
<p>Whether to eliminate redundant constraints before constructing the transformation to the sampling space and (optionally) calculating the seed point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>A state object, as generated by <code>har.init</code> (see value)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The constraints are given as a list with the elements <code>constr</code>, <code>dir</code> and <code>rhs</code>. <code>dir</code> is a vector with values <code>'='</code> or <code>'&lt;='</code>. <code>constr</code> is a matrix and <code>rhs</code> a vector, which encode the standard linear programming constraint froms <code class="reqn">Ax = b</code> and <code class="reqn">Ax \leq b</code> (depending on <code>dir</code>). The lengths of <code>rhs</code> and <code>dir</code> must match the number of rows of <code>constr</code>.
</p>
<p><code>shakeandbake</code> applies <code>solution.basis</code> to generate a basis of the (translated) solution space of the linear constraints (if any). An affine transformation is generated using <code>createTransform</code> and applied to the constraints. Then, a seed point satisfying the inequality constraints is generated using <code>createSeedPoint</code>. The closest face to this point is found using <code>findFace</code>. Finally, <code>sab</code> is used to generate the samples.
</p>


<h3>Value</h3>

<p>For <code>shakeandbake</code>, a matrix containing the generated samples as rows.
</p>
<p>For <code>sab.init</code>, a state object, containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>basis</code></td>
<td>
<p>The basis for the sampling space. See <code>solution.basis</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>The sampling space transformation. See <code>createTransform</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constr</code></td>
<td>
<p>The linear inequality constraints translated to the sampling space. See <code>transformConstraints</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x0</code></td>
<td>
<p>The generated seed point. See <code>createSeedPoint</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i0</code></td>
<td>
<p>The index of the closest face. See <code>findFace</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The thinning factor to be used.</p>
</td>
</tr>
</table>
<p>For <code>sab.run</code>, a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>samples</code></td>
<td>
<p>A matrix containing the generated samples as rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>A state object that can be used to continue sampling from the Markov chain (i.e. <code>x0</code> and <code>i0</code> have been modified).</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>"Shake and Bake" is a Markov Chain Monte Carlo (MCMC) method, so generated samples form a correlated time series.
</p>


<h3>Author(s)</h3>

<p>Gert van Valkenhoef
</p>


<h3>See Also</h3>

<p><code>harConstraints</code>
<code>sab</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sample from the 3-simplex with the additional constraint that w_1/w_2 = 2
# Three inequality constraints, two equality constraints
constr &lt;- mergeConstraints(simplexConstraints(3), exactRatioConstraint(3, 1, 2, 2))
samples &lt;- shakeandbake(constr, n.samples=1000)
stopifnot(dim(samples) == c(1000, 3))
stopifnot(all.equal(apply(samples, 1, sum), rep(1, 1000)))

sel &lt;- samples[,3] &gt; 0.5 # detect which side we're on
stopifnot(all.equal(samples[sel,], matrix(rep(c(0,0,1), each=sum(sel)), ncol=3)))
stopifnot(all.equal(samples[!sel,], matrix(rep(c(2/3,1/3,0), each=sum(sel)), ncol=3)))

# Sample from the unit rectangle (no equality constraints)
constr &lt;- list(
  constr = rbind(c(1,0), c(0,1), c(-1,0), c(0,-1)),
  dir=rep('&lt;=', 4),
  rhs=c(1, 1, 0, 0))
state &lt;- sab.init(constr)
result &lt;- sab.run(state, n.samples=1000)
faces &lt;- result$faces
samples &lt;- result$samples
stopifnot(all(samples &gt;= -1e-15 &amp; samples &lt;= 1 + 1e-15))

stopifnot(all.equal(samples[faces==1,1], rep(1, sum(faces==1))))
stopifnot(all.equal(samples[faces==2,2], rep(1, sum(faces==2))))
stopifnot(all.equal(samples[faces==3,1], rep(0, sum(faces==3))))
stopifnot(all.equal(samples[faces==4,2], rep(0, sum(faces==4))))

# Continue sampling from the same chain:
result &lt;- sab.run(result$state, n.samples=1000)
samples &lt;- rbind(samples, result$samples)
</code></pre>


</div>