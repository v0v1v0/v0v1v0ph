<div class="container">

<table style="width: 100%;"><tr>
<td>hexbin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bivariate Binning into Hexagon Cells</h2>

<h3>Description</h3>

<p>Creates a <code>"hexbin"</code> object.  Basic components are a cell id and
a count of points falling in each occupied cell.
</p>
<p>Basic methods are <code>show()</code>, <code>plot()</code> 
and <code>summary()</code>, but also <code>erode</code>.

</p>


<h3>Usage</h3>

<pre><code class="language-R">hexbin(x, y, xbins = 30, shape = 1,
       xbnds = range(x), ybnds = range(y),
       xlab = NULL, ylab = NULL, IDs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>vectors giving the coordinates of the bivariate data
points to be binned.  Alternatively a single plotting structure can
be specified: see <code>xy.coords</code>.  <code>NA</code>'s are
allowed and silently omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xbins</code></td>
<td>
<p>the number of bins partitioning the range of xbnds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>the <em>shape</em> = yheight/xwidth of the plotting regions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xbnds, ybnds</code></td>
<td>
<p>horizontal and vertical limits of the binning
region in x or y units respectively; must be numeric vector of length 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab</code></td>
<td>
<p>optional character strings used as labels for
<code>x</code> and <code>y</code>.  If <code>NULL</code>, sensible defaults are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDs</code></td>
<td>
<p>logical indicating if the individual cell “IDs”
should be returned, see also below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Returns counts for non-empty cells only.  The plot shape must be maintained for
hexagons to appear with equal sides.  Some calculations are in single
precision.
</p>
<p>Note that when plotting a <code>hexbin</code> object, the
<span class="pkg">grid</span> package is used.
You must use its graphics (or those from package <span class="pkg">lattice</span> if you
know how) to add to such plots.
</p>


<h3>Value</h3>

<p>an S4 object of class <code>"hexbin"</code>.
It has the following slots:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cell</code></td>
<td>
<p>vector of cell ids that can be mapped into the (x,y)
bin centers in data units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>vector of counts in the cells.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xcm</code></td>
<td>
<p>The x center of mass (average of x values) for the cell.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ycm</code></td>
<td>
<p>The y center of mass (average of y values) for the cell.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xbins</code></td>
<td>
<p> number of hexagons across the x axis. hexagon inner
diameter =diff(xbnds)/xbins in x units</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>plot shape which is yheight(inches) / xwidth(inches)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xbnds</code></td>
<td>
<p>x coordinate bounds for binning and plotting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ybnds</code></td>
<td>
<p>y coordinate bounds for binning and plotting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimen</code></td>
<td>
<p>The i and j limits of cnt treated as a matrix cnt[i,j]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of (non NA) (x,y) points, i.e., <code>sum(* @count)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncells</code></td>
<td>
<p>number of cells, i.e., <code>length(* @count)</code>, etc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab</code></td>
<td>
<p>character strings to be used as axis labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cID</code></td>
<td>
<p>of class, <code>"integer or NULL"</code>, only if <code>IDs</code>
was true, an integer vector of length <code>n</code> where
<code>cID[i]</code> is the cell number of the i-th original point
<code>(x[i], y[i])</code>.  Consequently, the <code>cell</code> and <code>count</code>
slots are the same as the <code>names</code> and entries of
<code>table(cID)</code>, see the example.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Carr, D. B. et al. (1987)
Scatterplot Matrix Techniques for Large <code class="reqn">N</code>.
<em>JASA</em> <b>83</b>, 398, 424–436.
</p>


<h3>See Also</h3>

<p><code>hcell2xy</code>

<code>gplot.hexbin</code>,

<code>grid.hexagons</code>, <code>grid.hexlegend</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(101)
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
(bin &lt;- hexbin(x, y))
## or
plot(hexbin(x, y + x*(x+1)/4),
     main = "(X, X(X+1)/4 + Y)  where X,Y ~ rnorm(10000)")

## Using plot method for hexbin objects:
plot(bin, style = "nested.lattice")

hbi &lt;- hexbin(y ~ x, xbins = 80, IDs= TRUE)
str(hbi)
tI &lt;- table(hbi@cID)
stopifnot(names(tI) == hbi@cell,
                tI  == hbi@count)

## NA's now work too:
x[runif(6, 0, length(x))] &lt;- NA
y[runif(7, 0, length(y))] &lt;- NA
hbN &lt;- hexbin(x,y)
summary(hbN)
</code></pre>


</div>