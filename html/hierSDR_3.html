<div class="container">

<table style="width: 100%;"><tr>
<td>hier.sphd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Main hierarchical sufficient dimension reduction fitting function</h2>

<h3>Description</h3>

<p>fits hierarchically nested sufficient dimension reduction models
</p>


<h3>Usage</h3>

<pre><code class="language-R">hier.sphd(
  x,
  y,
  z,
  z.combinations,
  d,
  weights = rep(1L, NROW(y)),
  maxit = 250L,
  tol = 1e-09,
  h = NULL,
  opt.method = c("lbfgs2", "lbfgs.x", "bfgs.x", "bfgs", "lbfgs", "spg", "ucminf", "CG",
    "nlm", "nlminb", "newuoa"),
  init.method = c("random", "phd"),
  vic = TRUE,
  grassmann = TRUE,
  nn = NULL,
  nn.try = c(0.15, 0.25, 0.5, 0.75, 0.9, 0.95),
  n.random = 100L,
  optimize.nn = FALSE,
  separate.nn = FALSE,
  constrain.none.subpop = TRUE,
  verbose = TRUE,
  degree = 2,
  pooled = FALSE,
  maxk = 5000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an n x p matrix of covariates, where each row is an observation and each column is a predictor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>vector of responses of length n</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>an n x C matrix of binary indicators, where each column is a binary variable indicating the presence
of a binary variable which acts as a stratifying variable. Each combination of all columns of <code>z</code> pertains
to a different subpopulation. WARNING: do not use too many binary variables in <code>z</code> or else it will quickly
result in subpopulations with no observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.combinations</code></td>
<td>
<p>a matrix of dimensions 2^C x C with each row indicating a different combination of the possible
values in <code>z</code>. Each combination represents a subpopulation. This is necessary because we need to specify a
different structural dimension for each subpopulation, so we need to know the ordering of the subpopulations so we
can assign each one a structural dimension</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>an integer vector of length 2^C of structural dimensions. Specified in the same order as the rows in
<code>z.combinations</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>vector of observation weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations for optimization routines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>convergence tolerance for optimization routines. Defaults to <code>1e-6</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>bandwidth parameter. By default, a reasonable choice is selected automatically</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.method</code></td>
<td>
<p>optimization method to use. Available choices are
<code>c("lbfgs2", "lbfgs.x", "bfgs.x", "bfgs", "lbfgs", "spg", "ucminf", "CG", "nlm", "nlminb", "newuoa")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.method</code></td>
<td>
<p>method for parameter initialization. Either <code>"random"</code> for random initialization or <code>"phd"</code>
for a principle Hessian directions initialization approach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vic</code></td>
<td>
<p>logical value of whether or not to compute the VIC criterion for dimension determination</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grassmann</code></td>
<td>
<p>logical value of whether or not to enforce parameters to be on the Grassmann manifold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn</code></td>
<td>
<p>nearest neighbor parameter for <code>locfit.raw</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn.try</code></td>
<td>
<p>vector of nearest neighbor parameters for <code>locfit.raw</code> to try in random initialization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.random</code></td>
<td>
<p>integer number of random initializations for parameters to try</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimize.nn</code></td>
<td>
<p>should <code>nn</code> be optimized? Not recommended</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>separate.nn</code></td>
<td>
<p>should each subpopulation have its own <code>nn</code>? If <code>TRUE</code>, optimization takes
much longer. It is rarely better, so recommended to set to <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constrain.none.subpop</code></td>
<td>
<p>should the "none" subpopulation be constrained to be contained in every other subpopulation's
dimension reduction subspace? Recommended to set to <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>should results be printed along the way?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>degree of kernel to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pooled</code></td>
<td>
<p>should the estimator be a pooled estimator?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxk</code></td>
<td>
<p>maxk parameter for <code>locfit.raw</code>. Set to a large number if an out of vertex space error occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra arguments passed to <code>locfit.raw</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following elements
</p>

<ul>
<li>
<p> beta a list of estimated sufficient dimension reduction matrices, one for each subpopulation
</p>
</li>
<li>
<p> beta.init a list of the initial sufficient dimension reduction matrices, one for each subpopulation â€“ do not use, just for the sake of comparisons
</p>
</li>
<li>
<p> directions a list of estimated sufficient dimension reduction directions (i.e. the reduced dimension predictors/variables), one for each subpopulation.
These have number of rows equal to the sample size for the subpopulation and number of columns equal to the specified dimensions of the reduced dimension spaces.
</p>
</li>
<li>
<p> y.list a list of vectors of responses for each subpopulation
</p>
</li>
<li>
<p> z.combinations the <code>z.combinations</code> specified as an input
</p>
</li>
<li>
<p> cov list of variance covariance matrices for the covariates for each subpopulation
</p>
</li>
<li>
<p> sqrt.inv.cov list of inverse square roots of the variance covariance matrices for the covariates for each subpopulation. These are used for scaling
</p>
</li>
<li>
<p> solver.obj object returned by the solver/optimization function
</p>
</li>
<li>
<p> value value of the objective function at the solution
</p>
</li>
<li>
<p> value.init value of the objective function at the initial beta (<code>beta.init</code>) used
</p>
</li>
<li>
<p> vic.est.eqn the average (unpenalized) VIC value  across the r different input values. This assesses model fit
</p>
</li>
<li>
<p> vic.eqns the individual (unpenalized) VIC values across the r input values. Not used.
</p>
</li>
<li>
<p> vic the penalized VIC value. This is used for dimension selection, with dimensions chosen by the set of dimensions
that minimize this penalized vic value that trades off model complexity and model fit
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
library(hierSDR)

set.seed(123)
dat &lt;- simulate_data(nobs = 200, nvars = 6,
                     x.type = "some_categorical",
                     sd.y = 1, model = 2)

x &lt;- dat$x ## covariates
z &lt;- dat$z ## factor indicators
y &lt;- dat$y ## response

dat$beta ## true coefficients that generate the subspaces

dat$z.combinations ## what combinations of z represent different subpops

## correct structural dimensions:
dat$d.correct

## fit hier SPHD model:


hiermod &lt;- hier.sphd(x, y, z, dat$z.combinations, d = dat$d.correct,
                     verbose = FALSE, maxit = 250, maxk = 8200)

## validated inf criterion for choosing dimensions (the smaller the better)
hiermod$vic


cbind(hiermod$beta[[4]], NA, dat$beta[[4]])

## angles between estimated and true subspaces for each population:
mapply(function(x,y) angle(x,y), hiermod$beta, dat$beta)

## projection difference norm between estimated and true subspaces for each population:
mapply(function(x,y) projnorm(x,y), hiermod$beta, dat$beta)



</code></pre>


</div>