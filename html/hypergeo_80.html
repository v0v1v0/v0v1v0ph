<div class="container">

<table style="width: 100%;"><tr>
<td>f15.5.1</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Hypergeometric functions via direct numerical integration
</h2>

<h3>Description</h3>

<p>The hypergeometric function may be evaluated using Gauss's
differential equation 15.5.1: 
</p>
<p style="text-align: center;"><code class="reqn">z(1-z)w''+(c-(a+b+1)z)w'-abw=0</code>
</p>

<p>using a start value away from the three singular points.  This page
documents a suite of related functionality.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hypergeo_press(A,B,C,z, ...)
f15.5.1(A, B, C, z, startz, u, udash, give=FALSE, ...)
hypergeo_func(Time, State, Pars, u, udash)
to_real(o)
to_complex(p)
complex_ode(y, times, func, parms=NA, method=NULL, u, udash, ...)
semicircle(t,z0,z1,clockwise=TRUE)
semidash(t,z0,z1,clockwise=TRUE)
straight(t,z0,z1)
straightdash(t,z0,z1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A,B,C,z</code></td>
<td>
<p>Standard parameters for the hypergeometric function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u,udash</code></td>
<td>
<p>Functions to specify the path of integration, and its
derivative</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give</code></td>
<td>
<p>In function <code>f15.5.1()</code>, Boolean with <code>TRUE</code>
meaning to return extra information from <code>ode()</code> and default
<code>FALSE</code> meaning to return only the evaluated function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startz</code></td>
<td>
<p>In function <code>f15.5.1(</code>, the start position of the path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>ode()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o,p</code></td>
<td>
<p>Real and complex objects to be coerced to each other in
<code>to_real()</code> and <code>to_complex()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y, times, func, parms, method</code></td>
<td>
<p>In function <code>complex_ode()</code>,
arguments matching those of <code>ode()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t,z0,z1,clockwise</code></td>
<td>
<p>Arguments for the standard path functions
<code>semicircle()</code> et seq: <code>u</code> is the primary argument
(real, <code class="reqn">0\leq u\leq 1</code>); <code>z0</code> and <code>z1</code> are
the start and end points of the path; and <code>clockwise</code> is
Boolean, indicating whether the path proceeds clockwise or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Time, State, Pars</code></td>
<td>
<p>arguments matchin those of standard examples
in the <code>deSolve</code> package</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>hypergeo_press()</code> is the most user-friendly of the
functions documented here.  It performs integration of Gauss's ODE,
along a straight line path from the start-point to <code>z</code>.  It follows
Press et al's suggestion of start-point.
</p>
<p>Function <code>f15.5.1()</code> is a little more flexible in that it allows
the user to choose a start point and an integration path.
</p>
<p>Function <code>complex_ode()</code> is a complex generalization of
<code>ode()</code> of package <span class="pkg">deSolve</span>; function <code>hypergeo_func</code>
is an internal function, designed for use with <code>complex_ode()</code>,
that specifies the Gauss ODE which is satisified by the hypergeometric
function.
</p>
<p>Functions <code>to_real()</code> and <code>to_complex()</code> are internal
functions which coerce from real to complex and back; they are needed
because <code>ode()</code> deals only with real values.
</p>
<p>Functions <code>semicircle()</code> and <code>straight()</code> are helper
functions which specify straight or semicircular paths from <code>z0</code>
to <code>z1</code>; note that <code>f(0)=z0</code> and <code>f(1)=z1</code>.  Functions
<code>semidash()</code> and <code>straightdash()</code> provide the differential
of the path.
</p>


<h3>Note</h3>

<p>Accuracy is low compared with the other methods in the package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>References</h3>

<p>W. H. Press et al.  1997. <em>Numerical Recipes in C</em>.  Cambridge
University Press, Second Edition.
</p>


<h3>See Also</h3>

<p><code>hypergeo_residue</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
hypergeo_press(A=pi,B=sqrt(2),C=1.4,z=1-2i)
hypergeo      (A=pi,B=sqrt(2),C=1.4,z=1-2i)


jj1 &lt;- 
f15.5.1(
    A=1.1, B=2.2, C=3.3, z=3+0.5i, startz=0.5,
        u    =function(u){semicircle(u,0.5,3+0.5i,FALSE)},
        udash=function(u){semidash(u,0.5,3+0.5i,FALSE)}
        )

jj2 &lt;-
f15.5.1(
    A=1.1, B=2.2, C=3.3, z=3+0.5i, startz=0.5,
        u    =function(u){semicircle(u,0.5,3+0.5i,TRUE)},
        udash=function(u){semidash(u,0.5,3+0.5i,TRUE)}
        )



jj3 &lt;- hypergeo(    A=1.1, B=2.2, C=3.3, z=3+0.5i)
## First one agrees with jj3=hypergeo(...), the second one does not 


# Now try the Airy Ai function;  satisfies f'' =  zf:

pars &lt;- c(kay = 1+1i, ell = 0.1+0.2i)  # not actually used
airy_ai_func &lt;- function(Time, State, Pars, u, udash) {
    with(as.list(c(to_complex(State), to_complex(Pars))), {

      z &lt;- u(Time)
      dz &lt;- udash(Time)
        
      dF &lt;- Fdash*dz
      dFdash &lt;-  z*F*dz # could use kay and ell from pars here if necessary
        
        ## coerce back to real:
        out &lt;- to_real(c(dF,dFdash))
        names(out) &lt;- names(State)
        return(list(out))
    })
}

complex_ode(
    y     = c(F = 1/3^(2/3)/gamma(2/3), Fdash= -1/3^(1/3)/gamma(1/3)),
    times = seq(0,1,by=0.1),
    func  = airy_ai_func,
    parms = pars,
    u     = function(t){straight(t,0,1)},
    udash = function(t){straightdash(t,0,1)}
)

# Look at the last line for the value at 1.
# compare gsl: Ai(1) = 0.1352924 ; Ai'(1) = -0.1591474

# ...although in this case there is actually a hypergeometric series
#  representation:

f &lt;- function(z){
    return(
        +genhypergeo(U=NULL,L=2/3,z^3/9)/3^(2/3)/gamma(2/3)
        -genhypergeo(U=NULL,L=4/3,z^3/9)/3^(1/3)/gamma(1/3)*z
        ) 
}

f(1)

</code></pre>


</div>