<div class="container">

<table style="width: 100%;"><tr>
<td>run-mold</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<code>mold()</code> according to a blueprint</h2>

<h3>Description</h3>

<p>This is a developer facing function that is <em>only</em> used if you are creating
your own blueprint subclass. It is called from <code>mold()</code> and dispatches off
the S3 class of the <code>blueprint</code>. This gives you an opportunity to mold the
data in a way that is specific to your blueprint.
</p>
<p><code>run_mold()</code> will be called with different arguments depending on the
interface to <code>mold()</code> that is used:
</p>

<ul>
<li>
<p> XY interface:
</p>

<ul><li> <p><code>run_mold(blueprint, x = x, y = y)</code>
</p>
</li></ul>
</li>
<li>
<p> Formula interface:
</p>

<ul>
<li> <p><code>run_mold(blueprint, data = data)</code>
</p>
</li>
<li>
<p> Additionally, the <code>blueprint</code> will have been updated to contain the
<code>formula</code>.
</p>
</li>
</ul>
</li>
<li>
<p> Recipe interface:
</p>

<ul>
<li> <p><code>run_mold(blueprint, data = data)</code>
</p>
</li>
<li>
<p> Additionally, the <code>blueprint</code> will have been updated to contain the
<code>recipe</code>.
</p>
</li>
</ul>
</li>
</ul>
<p>If you write a blueprint subclass for <code>new_xy_blueprint()</code>,
<code>new_recipe_blueprint()</code>, or <code>new_formula_blueprint()</code> then your <code>run_mold()</code>
method signature must match whichever interface listed above will be used.
</p>
<p>If you write a completely new blueprint inheriting only from
<code>new_blueprint()</code> and write a new <code>mold()</code> method (because you aren't using
an xy, formula, or recipe interface), then you will have full control over
how <code>run_mold()</code> will be called.
</p>


<h3>Usage</h3>

<pre><code class="language-R">run_mold(blueprint, ...)

## S3 method for class 'default_formula_blueprint'
run_mold(blueprint, ..., data)

## S3 method for class 'default_recipe_blueprint'
run_mold(blueprint, ..., data)

## S3 method for class 'default_xy_blueprint'
run_mold(blueprint, ..., x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>blueprint</code></td>
<td>
<p>A preprocessing blueprint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used. Required for extensibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or matrix containing the outcomes and predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data frame or matrix containing the predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A data frame, matrix, or vector containing the outcomes.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>run_mold()</code> methods return the object that is then immediately returned from
<code>mold()</code>. See the return value section of <code>mold()</code> to understand what the
structure of the return value should look like.
</p>


<h3>Examples</h3>

<pre><code class="language-R">bp &lt;- default_xy_blueprint()

outcomes &lt;- mtcars["mpg"]
predictors &lt;- mtcars
predictors$mpg &lt;- NULL

run_mold(bp, x = predictors, y = outcomes)
</code></pre>


</div>