<div class="container">

<table style="width: 100%;"><tr>
<td>new_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constructor for a base model</h2>

<h3>Description</h3>

<p>A <strong>model</strong> is a <em>scalar object</em>, as classified in
<a href="https://adv-r.hadley.nz/s3.html#object-styles">Advanced R</a>. As such, it
takes uniquely named elements in <code>...</code> and combines them into a list with
a class of <code>class</code>. This entire object represent a single model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">new_model(..., blueprint = default_xy_blueprint(), class = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Name-value pairs for elements specific to the model defined by
<code>class</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blueprint</code></td>
<td>
<p>A preprocessing <code>blueprint</code> returned from a call to <code>mold()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>A character vector representing the class of the model.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Because every model should have multiple interfaces, including formula
and <code>recipes</code> interfaces, all models should have a <code>blueprint</code> that
can process new data when <code>predict()</code> is called. The easiest way to generate
an blueprint with all of the information required at prediction time is to
use the one that is returned from a call to <code>mold()</code>.
</p>


<h3>Value</h3>

<p>A new scalar model object, represented as a classed list with named elements
specified in <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">new_model(
  custom_element = "my-elem",
  blueprint = default_xy_blueprint(),
  class = "custom_model"
)
</code></pre>


</div>