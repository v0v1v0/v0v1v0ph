<div class="container">

<table style="width: 100%;"><tr>
<td>loglik</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Log likelihood functions</h2>

<h3>Description</h3>

<p>Returns a log-likelihood for a given <code>hyper2</code> or <code>hyper3</code>
object at a specific point in probability space
</p>


<h3>Usage</h3>

<pre><code class="language-R">loglik(p, H, log = TRUE)
loglik_single(p,H,log=TRUE)
like_single_list(p,Lsub)
like_series(p,L,log=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>An object of class <code>hyper2</code> or <code>hyper3</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>A probability point.  See details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to return the
log-likelihood and <code>FALSE</code> meaning to return the likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L,Lsub</code></td>
<td>
<p>A list of <code>hyper2</code> objects, or a list of list of
<code>loglik</code> objects</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function <code>loglik()</code> is a straightforward likelihood function.  It
can take a vector of length <code>n=size(H)</code> or <code>size(H)-1</code>; if
given the vector
<code class="reqn">p=\left(p_1,\ldots,p_{n-1}\right)</code> it
appends the fillup value, and then returns returns the (log)
likelihood.
</p>
<p>If <code>p</code> is a matrix, the rows are interpreted as probability
points.
</p>
<p>Function <code>loglik_single()</code> is a helper function that takes a
single point in probability space.  Functions
<code>like_single_list()</code> and <code>like_series()</code> are intended for
use with <code>ggrl()</code>.
</p>


<h3>Note</h3>

<p><em>Likelihood</em> is defined up to an arbitrary multiplicative
constant.  Log-likelihood (also known as <em>support</em>) is defined up
to an arbitrary additive constant.
</p>
<p>If function <code>loglik()</code> is given a probability vector of length
<code>n</code>, the vector must satisfy the unit sum constraint (up to a
small tolerance).  Also, it must be a named vector with names
(collectively) equal to the <code>pnames</code> of argument <code>H</code>.
</p>
<pre>
  &gt; pnames(chess)
  [1] "Topalov" "Anand"   "Karpov"  
  &gt; loglik(c(Topalov=0.7,Anand=0.2,Karpov=0.1),chess)
  [1] -69.45364
  &gt; loglik(c(Karpov=0.1,Topalov=0.7,Anand=0.2),chess)  # identical, just a different order
  [1] -69.45364
  </pre>
<p>But if given a vector of length <code>n-1</code> [e.g. the value of
<code>indep()</code>], then the names are ignored and the entries are
interpreted as the BT strengths of <code>pnames(H)[seq_len(n-1)]</code>:
</p>
<pre>
  &gt; loglik(c(0.7,0.2),chess)
  [1] -69.45364
  &gt; loglik(c(foo=0.7,bar=0.2),chess)  # names are ignored 
  [1] -69.45364
  </pre>
<p>(the above applies for <code>H</code> a <code>hyper2</code> or <code>hyper3</code>
object).
</p>
<p>Empty brackets are interpreted consistently: that is, zero whatever
the probability vector (although the print method is not perfect).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code>maxp</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(chess)
loglik(c(1/3,1/3),chess)

loglik(rp(14,icons),icons)

## Not run:  # takes too long
like_series(masterchef_maxp,masterchef)
like_series(indep(equalp(masterchef)),masterchef)

## End(Not run)

W &lt;- hyper2(pnames=letters[1:6])
W1 &lt;- ggrl(W, 'a', letters[2:5],'f')              # 24-element list
W2 &lt;- ggrl(W, c('a','b'), c('c','d'),c('e','f'))  # 2^3=8 element list

like_single_list(rep(1/6,5),W1)      # information from first observation
like_series(rep(1/6,5),list(W1,W2))  # information from both observations

# hyper3 objects:
H3 &lt;- ordervec2supp3(letters[c(1,2,3,3,2,1,2)])
loglik(c(a=1,b=2,c=3)/6,H3)
loglik(c(a=1,c=3,b=2)/6,H3) # identical
</code></pre>


</div>