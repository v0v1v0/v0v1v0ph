<div class="container">

<table style="width: 100%;"><tr>
<td>disappointmentRate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
computation of the disappointment rate
</h2>

<h3>Description</h3>

<p>For a minimizing player, the <em>disappointment rate</em> is the likelihood for the loss to exceed its expectation (thus disappoint the defender). For any random loss <code class="reqn">X</code>, it is given by <code class="reqn">Pr(X &gt; E(X))</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">disappointmentRate(d, x, y, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>a lossDistribution object or a matrix; typically the assurance from a previously computed equilibrium (see <code>mgss</code>). In that case, all other parameters are ignored.
</p>
<p>Alternatively, one can provide a matrix of real values instead, to compute the disappointment rate in the so-specified zero-sum matrix game. In that case, the other parameters are also taken into considertion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>the mixed strategies under which the disappointment rate shall be computed. Usually, this would be an equilibrium of the (real-valued) matrix game. If only <code>x</code> or only <code>y</code> is supplied, the function computes a best response to the given (mixed) strategy. If both are omitted, the function internally computes an equilibrium by a call to <code>mgss</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if set to <code>FALSE</code>, suppresses all messaging.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters internally passed onwards to <code>mgss</code> to compute an equilibrium.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The disappointment rate can be taken as an auxiliary goal to optimize, though it is not supported for optimization in the current version of the package. Note that it does not make sense to consider this rate as an isolated (single) goal, since the optimal strategy would then be playing towards maximal losses (with explicit aid of the opponent) in order to minimize the mass to the left of the expected loss. However, it is a quantity of interest when the equilibrium has been computed, as it indicates how “satisfying” the equilibrium will be upon playing.
</p>


<h3>Value</h3>

<p>the likelihood to overshoot the expectation of the random loss <code class="reqn">X</code> with distribution <code>d</code>, i.e., <code class="reqn">Pr(X &gt; E(X))</code>.





</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>References</h3>

<p>see for example, F. Gul: "A Theory of Disappointment Aversion", Econometrica, vol. 59, no. 3, p. 667, 1991.
</p>


<h3>See Also</h3>

<p><code>mgss</code>

</p>


<h3>Examples</h3>

<pre><code class="language-R">## raw data (PURELY ARTIFICIAL, for demo purposes only)
# N=100 observations in each category
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));

## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=2,
            payoffs,
            goals=3,
            goalDescriptions=c("g1", "g2", "g3"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2"))
eq &lt;- mgss(G,weights=c(0.25,0.5,0.25))

# get the disappointment rate for the first security goal g1
disappointmentRate(eq$assurances$g1)

############
# construct a game with one goal and related disappointment
payoffs &lt;- list(f111,f112,f121,f122)
# note that from here onwards, the code is "generic", meaning that
# exactly the same procedure would apply to *any* kind of game that
# we want to play with disappointments, as long as the input data comes
# in the variable "payoffs" (as used in the code below)
expectations &lt;- unlist(lapply(payoffs, mean))
disappointmentRates &lt;- unlist(lapply(payoffs, disappointmentRate))
# put the two goals together in a game
gameWithDisappointment &lt;- c(expectations, disappointmentRates)
G &lt;- mosg( n=2,
          m=2,
          losses=gameWithDisappointment,
          goals=2,
          goalDescriptions=c("revenue", "disappointment"),
          defensesDescr = c("d1", "d2"),
          attacksDescr = c("a1", "a2"))
eq &lt;- mgss(G,weights=c(0.1,0.9))

</code></pre>


</div>