<div class="container">

<table style="width: 100%;"><tr>
<td>matrix.trellis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Convert a one-dimensional trellis object to a two-dimensional trellis object.
This permits combineLimits and useOuterStrips to work.
</h2>

<h3>Description</h3>

<p>matrix.trellis
</p>


<h3>Usage</h3>

<pre><code class="language-R">matrix.trellis(x = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)

## S3 method for class 'trellis'
as.matrix(x, ..., row = FALSE, yname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>x
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow, ncol, byrow, dimnames</code></td>
<td>

<p>See <code>matrix</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row</code></td>
<td>

<p>Logical.  The default is <code>FALSE</code> to match the behavior of the
generic <code>as.matrix</code>.  I think <code>TRUE</code> usually
looks better.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yname</code></td>
<td>

<p>Character. Provides the name of the generated conditioning factor.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>matrix.trellis</code> lets the user specify <code>nrow</code> and <code>ncol</code>.
<code>as.matrix.trellis</code> produces either be a single column (by
default) or a single row.
</p>


<h3>Value</h3>

<p><code>trellis</code> object with <code>length(dim(x)) == 2</code> and specified nrow and ncol.
</p>


<h3>Author(s)</h3>

<p> Richard M. Heiberger &lt;rmh@temple.edu&gt; </p>


<h3>Examples</h3>

<pre><code class="language-R">tmp &lt;- data.frame(a=1:3,
                  b=c(4,5,7),
                  c=5:7,
                  d=c(8, 9, 12),
                  e=9:11)
tmp
a1 &lt;- xyplot(a + b ~ c + d + e, data=tmp, outer=TRUE,
             main="a1")
a1
dim(a1)
a2 &lt;- xyplot(a + b ~ c + d + e, data=tmp, outer=TRUE,
             scales=list(relation="free"), main="a2")
a2
dim(a2)
try(combineLimits(a2))
combineLimits.trellisvector(a2)
combineLimits.trellisvector(update(a2, layout=c(3,2)))

a21 &lt;- matrix.trellis(a2, ncol=3, nrow=2, byrow=TRUE)
a21 &lt;- update(a21, main="a21")
a21
dim(a21)
a21$x.scales$at
combineLimits(a21)

a22 &lt;- update(a21, main="a22")
a22$x.scales$at &lt;- list(FALSE, FALSE, FALSE, NULL, NULL, NULL)
a22$y.scales$at &lt;- list(FALSE, NULL, NULL, FALSE, NULL, NULL)
a22

a23 &lt;- useOuterStrips(combineLimits(a21))
a23 &lt;- update(a23, main="a23")
a23
a23$condlevels
a23$condlevels &lt;- list(letters[3:5], letters[1:2])
a23

a24 &lt;- resizePanels(update(a23, main="a24"), h=c(3,4), w=c(3,5,3))
a24

a25 &lt;- update(a23, xlab=letters[3:5], ylab.right=letters[1:2],
              xlab.top="column variables",
              ylab="row variables",
              scales=list(x=list(alternating=1), y=list(alternating=2)),
              main="a25: what I want\nxyplot(a + b ~ c + d + e, data=tmp, outer=TRUE)\nto produce.")
a25

as.matrix(a1)
as.matrix(a1, yname="abcd")
as.matrix(a1, yname="abcd", row=TRUE)

</code></pre>


</div>