<div class="container">

<table style="width: 100%;"><tr>
<td>LPR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Lasso Partial Ridge
</h2>

<h3>Description</h3>

<p>Computes the two-stage estimator Lasso+Partial Ridge.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LPR(x, y, lambda = NULL, fix.lambda = TRUE, lambda2, cv.method = "cv", nfolds = 10, 
    foldid, cv.OLS = TRUE, tau = 0, parallel = FALSE, standardize = TRUE, intercept = 
    TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Input matrix as in glmnet, of dimension nobs x nvars; each row is an observation vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Response variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>lambda: A value of lambda - default is NULL. lambda should be given a value when fix.lambda=TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix.lambda</code></td>
<td>

<p>If TRUE, computes Lasso+Partial Ridge estimator for a fix value of lambda given by the argument "lambda"; otherwise, computes Lasso+Partial Ridge estimator for the value of lambda choosing by cv/cv1se/escv.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>

<p>Tuning parameter in the Partial Ridge. If missing, lambda2 will be set to 1/nobs, where nobs is the number of observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.method</code></td>
<td>

<p>The method used to select lambda â€“ can be cv, cv1se, and escv; the default is cv. cv.method is useful only when fix.lambda=FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds, foldid, cv.OLS, tau, parallel</code></td>
<td>

<p>Arguments that can be passed to escv.glmnet (useful only when fix.lambda=FALSE). Note that, the default value of cv.OLS is TRUE, which means using Lasso+OLS in the cv fits.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>

<p>Logical flag for x variable standardization, prior to fitting the model. Default is standardize=TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p>Should intercept be fitted (default is TRUE) or set to zero (FALSE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other arguments that can be passed to glmnet.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes the Lasso+Partial Ridge estimator for a give value of lambda (if fix.lambda=TRUE) or for the value of lambda choosing by cv/cv1se/escv (if fix.lambda=FALSE).
</p>


<h3>Value</h3>

<p>A list consisting of the following elements is returned.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>

<p>The Lasso+Partial Ridge estimator for the coefficients of variables/predictors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>

<p>A value of intercept term.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>The value/values of lambda.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>

<p>The value of lambda2.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanx</code></td>
<td>

<p>The mean vector of variables/predictors if intercept=TRUE, otherwise is a vector of 0's.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>The mean of the response if intercept=TRUE, otherwise is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normx</code></td>
<td>

<p>The vector of standard error of variables/predictors if standardize=TRUE, otherwise is a vector of 1's.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>Tuning parameter in modified Least Squares (mls).
</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">library("glmnet")
library("mvtnorm") 

## generate the data
set.seed(2015)
n &lt;- 200      # number of obs
p &lt;- 500
s &lt;- 10
beta &lt;- rep(0, p)
beta[1:s] &lt;- runif(s, 1/3, 1)
x &lt;- rmvnorm(n = n, mean = rep(0, p), method = "svd")
signal &lt;- sqrt(mean((x %*% beta)^2))
sigma &lt;- as.numeric(signal / sqrt(10))  # SNR=10
y &lt;- x %*% beta + rnorm(n)

## Lasso+Partial Ridge estimator
# for a given value of lambda
set.seed(0)
obj.escv &lt;- escv.glmnet(x, y)
obj &lt;- LPR(x, y, lambda = obj.escv$lambda.cv)
# Lasso+OLS estimate of the regression coefficients
obj$beta
# intercept term
obj$beta0
# prediction
mypredict(obj, newx = matrix(rnorm(10*p), 10, p))

# for lambda choosing by cross-validation (cv) which uses Lasso+OLS in the cv fit
set.seed(0)
obj &lt;- LPR(x, y, fix.lambda = FALSE)

# for lambda choosing by cross-validation (cv) which uses Lasso in the cv fit
set.seed(0)
obj &lt;- LPR(x, y, fix.lambda = FALSE, cv.OLS = FALSE)

</code></pre>


</div>