<div class="container">

<table style="width: 100%;"><tr>
<td>mosg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Construction and handling of multi-objective security games
</h2>

<h3>Description</h3>

<p>this function takes a list of loss distributions construced using <code>lossDistribution</code>, along with a specification of the game's shape (number of strategies for both players and number of goals for the first player), and returns an object suitable for analysis by <code>mgss</code> to compute a multi-goal security strategy. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">mosg( n,
      m,
      goals,
      losses,
      byrow = TRUE,
      goalDescriptions = NULL,
      defensesDescr = NULL,
      attacksDescr = NULL)

## S3 method for class 'mosg'
print(x, ...)

## S3 method for class 'mosg'
plot(x,
     goal = 1,
     points = 100,
     cutoff = NULL,
     largeGame = FALSE,
     subPlotWidth = 2,
     subPlotHeight = 2,
     cleanUp = TRUE, ...)

# construct a loss distribution by playing a given strategy in the game G
## S3 method for class 'mosg'
lossDistribution(G, player1Strat, player2Strat, points = 512, goal = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>number of defense strategies (cardinality of the action space for player 1)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>number of attack stratgies (cardinality of the action space for player 2)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goals</code></td>
<td>

<p>number of goals for player 1 (must be <code class="reqn">\geq 1</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>losses</code></td>
<td>

<p>a <code>list</code> with <code>n*m*goals</code> entries, which specifies a total of <code>goals</code> game matrices, each with shape <code>n</code>-by-<code>m</code>. The way in which the game matrices are filled from this list is controlled by the parameter <code>byrow</code>. Note that in every case, it is assumed that one matrix is specified after the other in the list.
</p>
<p>Furthermore, the function assumes all loss distributions having a common support. This is only explicitly verified for discrete distributions (with errors reported), but implicitly assumed to hold for continuous distributions without further checks.
</p>
<p>Typically, a game will be constructed from a list of loss distributions obtained by invocations of <code>lossDistribution</code>.
</p>
<p>Games can be defined with real-valued (scalar) payoffs if a list of numbers is provided instead. Internally, the function converts these numbers into Bernoulli distributions; a scalar payoff <code class="reqn">a</code> is converted into a Bernoulli random variable <code class="reqn">X</code> having <code class="reqn">\Pr(X=a)=p\propto a</code>. This conversion is equivalent to an invocation of <code>lossDistribution</code> with the parameters <code>dat=c(1-p, p)</code>, <code>discrete=TRUE</code>, <code>dataType="pdf"</code>, <code>smoothing="none"</code>, <code>bw = 1</code> and <code>supp=c(1,2)</code>.
</p>
<p>If the list of losses comes as a list of vectors, <code>mosg</code> will construct a game assuming a lexicographic order on the loss vectors
(with the order being determined from left to right along the coordinates). To this end, <code>mosg</code> checks for all loss vectors to have the same length (otherwise, an error is reported). Negative and zero values in the loss vector <em>are allowed</em>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byrow</code></td>
<td>

<p>by default (<code>TRUE</code>), the game matrices are filled row-by-row from list <code>losses</code>. If set to <code>FALSE</code>, then the game matrices are filled column-by-column.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goalDescriptions</code></td>
<td>

<p>if specified, this can be any vector (e.g., textual descriptions) for the goals. Defaults to 1, 2, 3, ... if missing. The length must be equal to <code>goals</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defensesDescr</code></td>
<td>

<p>if specified, this can be any vector (e.g., textual descriptions) for the defense strategies. Defaults to 1, 2, 3, ... if missing. The length must be equal to <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attacksDescr</code></td>
<td>

<p>if specified, this can be any vector (e.g., textual descriptions) for the attack strategies. Defaults to 1, 2, 3, ... if missing. The length must be equal to <code>m</code>.</p>
</td>
</tr>
</table>
<p>for the functions <code>print</code>, <code>summary</code> and <code>plot</code>
</p>
<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a game, object of class "mosg", as constructed by the function <code>mosg</code></p>
</td>
</tr></table>
<p>The function <code>plot</code> additionally takes the following parameters:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>goal</code></td>
<td>
<p>an integer referring to the goal of interest (for plotting or to construct a loss distribution for). Defaults to the first goal if omitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p>The number of points at which the density is evaluated (for continuous losses); this parameter is ignored for categorical losses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>the cutoff point at which all densities shall be truncated before plotting (note that the mass functions are rescaled towards unit mass).</p>
</td>
</tr>
</table>
<p>The plot function overrides the following settings internally (so supplying these as parameters will raise an error): <code>xlab, ylab, main, type, names.arg</code> and <code>font.main</code> (applying differently for bar and line plots)
</p>
<table>
<tr style="vertical-align: top;">
<td><code>largeGame</code></td>
<td>
<p>if the plot exits with the error "figure margins too large", one can set this
parameter to TRUE, causing plot to write to a temporary SVG file (scalable vector graphics), to avoid the figure space issue and hence
the error. The price is a (potentially much) slower plotting, since the system creates the file, and loads it afterwards from
the harddisk (cleaning up the file after displaying it). The size of the plot is controllable by setting
the parameters <code>subPlotWidth</code> and <code>subPlotHeight</code>, see below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subPlotWidth</code></td>
<td>
<p>the width in inches for each payoff distribution in the game matrix. This parameter is
ignored when <code>largeGame</code> is set to FALSE (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subPlotHeight</code></td>
<td>
<p>the height in inches for each payoff distribution in the game matrix. This parameter is
ignored when <code>largeGame</code> is set to FALSE (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cleanUp</code></td>
<td>
<p>If the graph is to be used in other programs, one can supply <code>cleanUp = FALSE</code> to retain the temporary SVG file for subsequent use and prints a message where to find the file. By default, the temporary file gets deleted.</p>
</td>
</tr>
</table>
<p>The function <code>lossDistribution.mosg</code> can be used to play any (given) strategies for player 1 and player 2, and compute the resulting loss from the game.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>a game constructed by <code>mosg</code> to deliver the loss distribution through its game matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>player1Strat</code></td>
<td>
<p>a discrete distribution over the action space for the defending player 1 in the game <code>G</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>player2Strat</code></td>
<td>
<p>a discrete distribution over the action space for the attacking player 2 in the game <code>G</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Upon input, the function does some consistency checks, such as testing the length of the parameter <code>losses</code> to be equal to n*m*goals. The loss distributions are checked for mutual consistency in terms of all being continuous or all being discrete (a mix is not allowed), and all being not mixed distributions (that is, the output distribution of a previous call to <code>mgss</code> cannot be used as input to this function).
</p>
<p>The functions <code>print.mosg</code> gives a brief overview of the game, listing only the shape and strategies for both players. For detailed information, use <code>summary</code> on a specific loss distribution in the list for the game (field <code>losses</code>).
</p>
<p>For plotting games, <code>plot.mosg</code> constructs an (n x m)-matrix of loss distributions with rows and columns in the grid being labeled by the values in <code>defensesDescr</code> and <code>attacksDescr</code>. The plot heading is the name for the specified goal. The function makes no changes to the plot parameters, so fine tuning can be done by changing the settings using the par function.
</p>
<p>The function <code>lossDistribution.mosg</code> can be used to compute the distribution <code class="reqn">x^T*A*y</code>, for the payoff distribution matrix <code class="reqn">A</code>, and mixed strategies <code class="reqn">x</code> (<code>player1strat</code>) and <code class="reqn">y</code> (<code>player2strat</code>) in the game. The computation is by a pointwise addition of loss distributions, with the number of points being specifiable by the parameter <code>points</code>, which defaults to 512.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>mosg</code>, usable with the function <code>mgss</code> to determine a security strategy (i.e., a lexicographic Nash equilibrium assuming a zero-sum one-against-all competition). The fields returned in the <code>mosg</code> object are filled with the input values supplied. In detail, the fields are:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>nDefenses</code></td>
<td>
<p>the value of the parameter <code>n</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nAttacks</code></td>
<td>
<p>the value of the parameter <code>m</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>the value of the parameter <code>goals</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attacksDescriptions, defensesDescriptions, goalDescriptions</code></td>
<td>
<p>if supplied, then these are filled with the values of <code>goalDescr</code>, <code>defensesDescr</code> and <code>attacksDescr</code>; otherwise, they contain the default values described above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximumLoss</code></td>
<td>
<p>the maximal loss taken over all specified loss distributions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>a locus-function for accessing the list <code>losses</code> using a triple notation (goal,i,j), where goal addresses the game matrix and i,j are the row and column indices (starting from 1 as the smallest index). This function is used internally (only).</p>
</td>
</tr>
</table>
<h3>Warning </h3>

<p>Games constructed with real-valued payoffs or payoff vectors over the reals are allowed with negative or zero values in the list of losses. In that case, embeds the loss values or vector into a lossDistribution object after shifting and scaling the values into the strictly positive range. This operation creates a strategically equivalent game, i.e., leaves the set of equilibria unchanged, yet the resulting mosg object <em>is not</em> useful with the lossDistribution.mosg, moment, cdf, or any other member functions for lossDistribution objects obtained from equilibria. Those have to be computed manually. Be aware that there will be no warnings issued whatsoever in that case of misuse, since the lossDistribution objects constructed to carry the real or vector-valued payoffs of the original game carry no information about the semantics of the values or vectors that they have been created from. Hence, the <em>computation of equilibria works correctly</em> using mosg, while any further analysis (including plots)  <em>needs to be done manually</em>.
</p>


<h3>Note</h3>

<p>It is important to remark that player 1 is always minimizing. To treat a maximizing player, one must reconstruct the game using regrets instead of losses, i.e., if the data for a specific loss distribution is <code class="reqn">D</code>, then the game for a maximizing player 1 must be constructed from <code>(max(D) - D)</code> instead of <code>D</code>.</p>


<h3>Author(s)</h3>

<p>Stefan Rass
</p>


<h3>See Also</h3>

<p>Security strategies for a <code>mosg</code> object can be obtained by calling <code>mgss</code>. The game itself can be constructed from the output of <code>lossDistribution</code>.

</p>


<h3>Examples</h3>

<pre><code class="language-R">library(compare)

## raw data (PURELY ARTIFICIAL, for demo purposes only)
# N=100 observations in each category
obs111&lt;-c(rep(1,40),rep(3,20),rep(5,10),rep(7,20),rep(9,10));
obs112&lt;-c(rep(1,50),rep(2,10),rep(4,10),rep(6,20),rep(8,10));
obs121&lt;-c(rep(1,20),rep(4,30),rep(6,20),rep(8,10),rep(10,20));
obs122&lt;-c(rep(1,40),rep(2.5,20),rep(5,20),rep(7.5,10),rep(9,10));
obs211&lt;-c(rep(1,30),rep(2,30),rep(5,10),rep(8,10),rep(10,20));
obs212&lt;-c(rep(1,10),rep(2,10),rep(4,20),rep(7,20),rep(10,40));
obs221&lt;-c(rep(1,30),rep(3,30),rep(4,10),rep(7,20),rep(9,10));
obs222&lt;-c(rep(1,10),rep(3,10),rep(5,50),rep(8,20),rep(10,10));
obs311&lt;-c(rep(1,40),rep(2,30),rep(4,10),rep(7,10),rep(9,10));
obs312&lt;-c(rep(1,20),rep(3,20),rep(4,20),rep(7,20),rep(10,20));
obs321&lt;-c(rep(1,10),rep(3,40),rep(4,30),rep(7,10),rep(9,10));
obs322&lt;-c(rep(1,10),rep(4,30),rep(5,30),rep(7,10),rep(10,20));

## compute payoff densities
f111&lt;-lossDistribution(obs111)
f112&lt;-lossDistribution(obs112)
f121&lt;-lossDistribution(obs121)
f122&lt;-lossDistribution(obs122)
f211&lt;-lossDistribution(obs211)
f212&lt;-lossDistribution(obs212)
f221&lt;-lossDistribution(obs221)
f222&lt;-lossDistribution(obs222)
f311&lt;-lossDistribution(obs311)
f312&lt;-lossDistribution(obs312)
f321&lt;-lossDistribution(obs321)
f322&lt;-lossDistribution(obs322)

payoffs&lt;-list(f111,f112,f121, f122,f211,f212,f221,f222, f311,f312,f321,f322)
G &lt;- mosg( n=2,
            m=2,
            payoffs,
            goals=3,
            goalDescriptions=c("g1", "g2", "g3"),
            defensesDescr = c("d1", "d2"),
            attacksDescr = c("a1", "a2"))
print(G)
summary(G)
plot(G)

# construct and solve scalar valued (classical) game;
# losses are all numbers (degenerate distributions)
# the resulting matrix game has the payoff structure:
#     [,1] [,2]
#[1,]    3    4
#[2,]    6    1
G &lt;- mosg(n = 2, m = 2, goals = 1, losses = list(3,6,4,1), byrow=FALSE)
mgss(G)  # compute a lexicographic Nash equilibrium
</code></pre>


</div>