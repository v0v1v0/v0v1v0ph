<div class="container">

<table style="width: 100%;"><tr>
<td>rhmm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Simulate discrete data from a non-parametric hidden Markov model.
</h2>

<h3>Description</h3>

<p>Simulates one or more replicates of discrete data
from a model such as is fitted by the function <code>hmm()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rhmm(model,...,nsim,verbose=FALSE)
## Default S3 method:
rhmm(model, ..., nsim=1, verbose=FALSE, ylengths,
                       nafrac=NULL, fep=NULL, tpm, Rho, ispd=NULL, yval=NULL,
                       drop=TRUE, forceNumeric=TRUE)
## S3 method for class 'hmm.discnp'
rhmm(model, ..., nsim=1, verbose=FALSE, inMiss=TRUE,
                          fep=NULL, drop=TRUE, forceNumeric=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>An object of class <code>hmm.discnp</code>.  This will have the form of
a list specifying a hidden Markov model with discrete emissions
and emission probabilities specified non-parametrically, i.e.
by means of some form of table or tables.  Usually this will
be an object returned by <code>hmm()</code>.  This argument is
ignored by the default method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Not used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>

<p>Integer scalar; the number of data sets to be simulated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical scalar.  If <code>TRUE</code> then the overall index
of the simulated value that has been reached is printed out every
1000 iterations.  Useful for reassurance when very “large”
simulations are undertaken.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylengths</code></td>
<td>

<p>Integer values vector specify the lengths (or number of rows
in the bivariate setting) of the individual observation
sequences constituting a data set.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nafrac</code></td>
<td>

<p>See <code>misstify()</code> for an explanation of this argument.
If specified a fraction <code>nafrac[[j]]</code> of column <code>j</code>
of the data will be randomly set equal to <code>NA</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fep</code></td>
<td>

<p>“First entry present”.  See <code>misstify()</code>
for an explanation of this argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tpm</code></td>
<td>

<p>The transition probability matrix for the underlying hidden
Markov chain(s).  Note that the rows of <code>tpm</code> must sum to 1.
Ignored if <code>ncol(Rho)==1</code>.  Ignored by the <code>hmm.discnp</code>
method and extracted from <code>model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rho</code></td>
<td>

<p>An object specifying the probability distribution of the
observations, given the state of the underlying hidden Markov chain.
(I.e. the “emission” probabilities.)  See <code>hmm()</code>.
Note that <code>Rho</code> can be such that the number of states is 1, in
which case the simulated data are i.i.d. from the single distribution
specified by <code>Rho</code>.  Ignored by the <code>hmm.discnp</code> method
and extracted from <code>model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ispd</code></td>
<td>
<p>A vector specifying the initial state probability
distribution of the chain.  If this is not specified it is taken
to be the stationary distribution of the chain, calculated from
<code>tpm</code>.  Ignored by the <code>hmm.discnp</code> method and extracted
from <code>model</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yval</code></td>
<td>
<p>Vector of possible values of the observations, or (in
the bivariate setting) a list of two such vectors.  If not supplied
it is formed from the levels of the factor constituting the <code>y</code>
column of <code>Rho</code> (univariate case) or from appropriate dimension
names associated with <code>Rho</code> (bivariate case).  Ignored by the
<code>hmm.discnp</code> method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> then lists of length 1 are
replaced by their first entry.  In particular if <code>nsim</code>
is 1 and if <code>drop</code> is <code>TRUE</code> then the list to be
returned by this function (see below) is replaced by its first and only
entry.  Also if <code>ylengths</code> is of length 1 (so that each
entry of the returned value contains only a single sequence of
of simulated observations) then each list of such sequences
is replaced by its first and only entry.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inMiss</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> then missing values will
be randomly inserted into the data in the fraction
<code>nafrac</code> determined from <code>object</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceNumeric</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> then if all of the possible
values of the observations can be interpreted as numeric
(by <code>as.numeric()</code>) then they are so interpreted.
That is, the value returned will consist of a collection
of numeric sequences, rather than a collection of sequences
of values of categorical variables.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>nsim&gt;1</code> or <code>drop</code> is <code>FALSE</code> then the value
returned is a list of length <code>nsim</code>.  Each entry of this
list is in turn a list of the same length as <code>ylengths</code>,
each component of which is an independent  vector or matrix of
simulated observations.  The length or number of rows of component
<code>i</code> of this list is equal to <code>ylengths[i]</code>.  The values
of the observations are entries of <code>yval</code> or of <em>its</em>
entries when <code>yval</code> is a list.
</p>
<p>If <code>nsim=1</code> and <code>drop</code> is <code>TRUE</code> then the (“outer”)
list described above is replaced by its first and only entry
</p>
<p>If the length of <code>ylengths</code> is <code>1</code> and <code>drop</code> is
<code>TRUE</code> then each “inner” list described above is
replaced by its first and only entry.
</p>


<h3>Note</h3>

<p>You may find it useful to avail yourself of the function
<code>nafracCalc()</code> to determine the fraction of missing
values in a given existing (presumably “real”) data set.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br></p>


<h3>See Also</h3>

<p><code>hmm()</code> <code>nafracCalc()</code>
<code>misstify()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># To do: one or more bivariate examples.
## Not run: 
    y &lt;- list(linLandFlows$deciles,ftLiardFlows$deciles)
    fit &lt;- hmm(y,K=3)
    simX &lt;- rhmm(fit)

## End(Not run)
</code></pre>


</div>