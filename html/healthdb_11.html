<div class="container">

<table style="width: 100%;"><tr>
<td>execute_def</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Execute parameterized case definitions</h2>

<h3>Description</h3>

<p>This function executes the function calls stored in the output tibble from [build_def()] with data objects supplied through a named list and returns the results as a list. It is intended to facilitate re-use of pre-defined calls with different data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">execute_def(
  def,
  with_data,
  bind = FALSE,
  force_proceed = getOption("healthdb.force_proceed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>def</code></td>
<td>
<p>A tibble created by [build_def()].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_data</code></td>
<td>
<p>A named list which the elements are in the form of src_lab = data, where 'src_lab' corresponds to the src_labs argument from [build_def()] and 'data' is the data object that will be passed to calls stored in def. The names (and length) of 'with_data' must match the unique values of src_labs in 'def'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bind</code></td>
<td>
<p>A logical for whether row-binding records from multiple sources into one table. Note that the binding may fail in ways that are difficult to anticipate in advance, such as data type conflict (e.g., Date vs. character) between variables in the same name from different sources. The default is FALSE. If TRUE, the behavior is to try and return the unbinded result when failed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_proceed</code></td>
<td>
<p>A logical for whether to ask for user input in order to proceed when remote tables are needed to be collected for binding. The default is FALSE to let user be aware of that the downloading process may be slow. Use options(healthdb.force_proceed = TRUE) to suppress the prompt once and for all.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A single (if bind = TRUE) or a list of data.frames or remote tables.
</p>


<h3>See Also</h3>

<p>[bind_sources()] for binding the output with convenient renaming features.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># toy data
sample_size &lt;- 30
df &lt;- data.frame(
  clnt_id = rep(1:3, each = 10),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
    size = sample_size, replace = TRUE
  ),
  diagx = sample(letters, size = sample_size, replace = TRUE),
  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
)

# make df a database table
db &lt;- dbplyr::tbl_memdb(df)

# use build_def to make a toy definition
sud_def &lt;- build_def("SUD", # usually a disease name
  src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
  # functions that filter the data with some criteria
  def_fn = define_case,
  fn_args = list(
    vars = starts_with("diagx"),
    match = "start", # "start" will be applied to all sources as length = 1
    vals = list(c("304"), c("305")),
    clnt_id = "clnt_id", # list()/c() could be omitted for single element
    # c() can be used in place of list
    # if this argument only takes one value for each source
    n_per_clnt = c(2, 3)
  )
)

# save the definition for re-use
# saveRDS(sud_def, file = some_path)

sud_def %&gt;% execute_def(with_data = list(src1 = df, src2 = db), force_proceed = TRUE)
</code></pre>


</div>