<div class="container">

<table style="width: 100%;"><tr>
<td>without_internet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make all HTTP requests raise an error</h2>

<h3>Description</h3>

<p><code>without_internet()</code> simulates the situation when any network request will
fail, as in when you are without an internet connection. Any HTTP request
through <code>httr2</code> will raise an error.
</p>


<h3>Usage</h3>

<pre><code class="language-R">without_internet(expr)

block_requests()
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>Code to run inside the mock context</p>
</td>
</tr></table>
<h3>Details</h3>

<p><code>block_requests()</code> and <code>stop_mocking()</code> allow you to turn on/off request
blocking for more convenient use in an interactive session.
</p>
<p>The error message raised has a well-defined shape, made of three
elements, separated by space: (1) the request
method (e.g. "GET"); (2) the request URL; and
(3) the request body, if present. The verb-expectation functions,
such as <code>expect_GET()</code> and <code>expect_POST()</code>, look for this shape.
</p>


<h3>Value</h3>

<p>The result of <code>expr</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(httr2)
library(testthat, warn.conflicts = FALSE)
without_internet({
  expect_error(
    request("http://httpbin.org/get") %&gt;% req_perform(),
    "GET http://httpbin.org/get"
  )
  expect_error(
    request("http://httpbin.org/put") %&gt;%
      req_method("PUT") %&gt;%
      req_body_json(list(a = 1)) %&gt;%
      req_perform(),
    'PUT http://httpbin.org/put {"a":1}',
    fixed = TRUE
  )
})
</code></pre>


</div>