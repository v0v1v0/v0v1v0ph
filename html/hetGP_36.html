<div class="container">

<table style="width: 100%;"><tr>
<td>mleHetTP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Student-t process modeling with heteroskedastic noise</h2>

<h3>Description</h3>

<p>Student-t process regression under input dependent noise based on maximum likelihood estimation of the hyperparameters.
A GP is used to model latent (log-) variances.
This function is enhanced to deal with replicated observations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mleHetTP(
  X,
  Z,
  lower = NULL,
  upper = NULL,
  noiseControl = list(k_theta_g_bounds = c(1, 100), g_max = 10000, g_bounds = c(1e-06,
    0.1), nu_bounds = c(2 + 0.001, 30), sigma2_bounds = c(sqrt(.Machine$double.eps),
    10000)),
  settings = list(linkThetas = "joint", logN = TRUE, initStrategy = "residuals", checkHom
    = TRUE, penalty = TRUE, trace = 0, return.matrices = TRUE, return.hom = FALSE, factr
    = 1e+09),
  covtype = c("Gaussian", "Matern5_2", "Matern3_2"),
  maxit = 100,
  known = list(beta0 = 0),
  init = list(nu = 3),
  eps = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>matrix of all designs, one per row, or list with elements:
</p>

<ul>
<li> <p><code>X0</code> matrix of unique design locations, one point per row
</p>
</li>
<li> <p><code>Z0</code> vector of averaged observations, of length <code>nrow(X0)</code>
</p>
</li>
<li> <p><code>mult</code> number of replicates at designs in <code>X0</code>, of length <code>nrow(X0)</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>vector of all observations. If using a list with <code>X</code>, <code>Z</code> has to be ordered with respect to <code>X0</code>, and of length <code>sum(mult)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>bounds for the <code>theta</code> parameter (see <code>cov_gen</code> for the exact parameterization).
In the multivariate case, it is possible to give vectors for bounds (resp. scalars) for anisotropy (resp. isotropy)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noiseControl</code></td>
<td>
<p>list with elements related to optimization of the noise process parameters:
</p>

<ul>
<li> <p><code>g_min</code>, <code>g_max</code> minimal and maximal noise to signal ratio (of the mean process)
</p>
</li>
<li> <p><code>lowerDelta</code>, <code>upperDelta</code> optional vectors (or scalars) of bounds on <code>Delta</code>, of length <code>nrow(X0)</code> (default to <code>rep(eps, nrow(X0))</code> and <code>rep(noiseControl$g_max, nrow(X0))</code> resp., or their <code>log</code>) 
</p>
</li>
<li> <p><code>lowerTheta_g</code>, <code>upperTheta_g</code> optional vectors of bounds for the lengthscales of the noise process if <code>linkThetas == 'none'</code>.
Same as for <code>theta</code> if not provided.
</p>
</li>
<li> <p><code>k_theta_g_bounds</code> if <code>linkThetas == 'joint'</code>, vector with minimal and maximal values for <code>k_theta_g</code> (default to <code>c(1, 100)</code>). See Details.
</p>
</li>
<li> <p><code>g_bounds</code> vector for minimal and maximal noise to signal ratios for the noise of the noise process, i.e., the smoothing parameter for the noise process.
(default to <code>c(1e-6, 1)</code>).
</p>
</li>
<li> <p><code>sigma2_bounds</code>, vector providing minimal and maximal signal variance.
</p>
</li>
<li> <p><code>nu_bounds</code>, vector providing minimal and maximal values for the degrees of freedom. 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>settings</code></td>
<td>
<p>list for options about the general modeling procedure, with elements:
</p>

<ul>
<li> <p><code>linkThetas</code> defines the relation between lengthscales of the mean and noise processes.
Either <code>'none'</code>, <code>'joint'</code>(default) or <code>'constr'</code>, see Details.
</p>
</li>
<li> <p><code>logN</code>, when <code>TRUE</code> (default), the log-noise process is modeled.
</p>
</li>
<li> <p><code>initStrategy</code> one of <code>'simple'</code>, <code>'residuals'</code> (default) and <code>'smoothed'</code> to obtain starting values for <code>Delta</code>, see Details
</p>
</li>
<li> <p><code>penalty</code> when <code>TRUE</code>, the penalized version of the likelihood is used (i.e., the sum of the log-likelihoods of the mean and variance processes, see References).
</p>
</li>
<li> <p><code>checkHom</code> when <code>TRUE</code>, if the log-likelihood with a homoskedastic model is better, then return it.
</p>
</li>
<li> <p><code>trace</code> optional scalar (default to <code>0</code>). If positive, tracing information on the fitting process.
If <code>1</code>, information is given about the result of the heterogeneous model optimization.
Level <code>2</code> gives more details. Level <code>3</code> additionaly displays all details about initialization of hyperparameters.
</p>
</li>
<li> <p><code>return.matrices</code> boolean too include the inverse covariance matrix in the object for further use (e.g., prediction).
</p>
</li>
<li>
<p> Arguments <code>factr</code> (default to 1e9) and <code>pgtol</code> are available to be passed to <code>control</code> for L-BFGS-B in <code>optim</code>.   
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covtype</code></td>
<td>
<p>covariance kernel type, either <code>'Gaussian'</code>, <code>'Matern5_2'</code> or <code>'Matern3_2'</code>, see <code>cov_gen</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations for <code>L-BFGS-B</code> of <code>optim</code> dedicated to maximum likelihood optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init, known</code></td>
<td>
<p>optional lists of starting values for mle optimization or that should not be optimized over, respectively.
Values in <code>known</code> are not modified, while it can happen to those of <code>init</code>, see Details. 
One can set one or several of the following:
</p>

<ul>
<li> <p><code>theta</code> lengthscale parameter(s) for the mean process either one value (isotropic) or a vector (anistropic)
</p>
</li>
<li> <p><code>Delta</code> vector of nuggets corresponding to each design in <code>X0</code>, that are smoothed to give <code>Lambda</code>
(as the global covariance matrix depend on <code>Delta</code> and <code>nu_hat</code>, it is recommended to also pass values for <code>theta</code>)
</p>
</li>
<li> <p><code>beta0</code> constant trend of the mean process
</p>
</li>
<li> <p><code>k_theta_g</code> constant used for link mean and noise processes lengthscales, when <code>settings$linkThetas == 'joint'</code>
</p>
</li>
<li> <p><code>theta_g</code> either one value (isotropic) or a vector (anistropic) for lengthscale parameter(s) of the noise process, when <code>settings$linkThetas != 'joint'</code>
</p>
</li>
<li> <p><code>g</code> scalar nugget of the noise process
</p>
</li>
<li> <p><code>nu</code> degree of freedom parameter
</p>
</li>
<li> <p><code>sigma2</code> scale variance
</p>
</li>
<li> <p><code>g_H</code> scalar homoskedastic nugget for the initialisation with a <code>mleHomGP</code>. See Details.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>jitter used in the inversion of the covariance matrix for numerical stability</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The global covariance matrix of the model is parameterized as <code>K = sigma2 * C + Lambda * diag(1/mult)</code>,
with <code>C</code> the correlation matrix between unique designs, depending on the family of kernel used (see <code>cov_gen</code> for available choices).
<code>Lambda</code> is the prediction on the noise level given by a (homoskedastic) GP: <br></p>
<p style="text-align: center;"><code class="reqn">\Lambda = C_g(C_g + \mathrm{diag}(g/\mathrm{mult}))^{-1} \Delta</code>
</p>
 <p><br>
with <code>C_g</code> the correlation matrix between unique designs for this second GP, with lengthscales hyperparameters <code>theta_g</code> and nugget <code>g</code>
and <code>Delta</code> the variance level at <code>X0</code> that are estimated.
</p>
<p>It is generally recommended to use <code>find_reps</code> to pre-process the data, to rescale the inputs to the unit cube and to normalize the outputs.
</p>
<p>The noise process lengthscales can be set in several ways:
</p>

<ul>
<li>
<p> using <code>k_theta_g</code> (<code>settings$linkThetas == 'joint'</code>), supposed to be greater than one by default. 
In this case lengthscales of the noise process are multiples of those of the mean process.
</p>
</li>
<li>
<p> if <code>settings$linkThetas == 'constr'</code>, then the lower bound on <code>theta_g</code> correspond to estimated values of an homoskedastic GP fit.
</p>
</li>
<li>
<p> else lengthscales between the mean and noise process are independent (both either anisotropic or not).
</p>
</li>
</ul>
<p>When no starting nor fixed parameter values are provided with <code>init</code> or <code>known</code>, 
the initialization process consists of fitting first an homoskedastic model of the data, called <code>modHom</code>.
Unless provided with <code>init$theta</code>, initial lengthscales are taken at 10% of the range determined with <code>lower</code> and <code>upper</code>,
while <code>init$g_H</code> may be use to pass an initial nugget value.
The resulting lengthscales provide initial values for <code>theta</code> (or update them if given in <code>init</code>). <br><br>
If necessary, a second homoskedastic model, <code>modNugs</code>, is fitted to the empirical residual variance between the prediction
given by <code>modHom</code> at <code>X0</code> and <code>Z</code> (up to <code>modHom$nu_hat</code>).
Note that when specifying <code>settings$linkThetas == 'joint'</code>, then this second homoskedastic model has fixed lengthscale parameters.
Starting values for <code>theta_g</code> and <code>g</code> are extracted from <code>modNugs</code>.<br><br>
Finally, three initialization schemes for <code>Delta</code> are available with <code>settings$initStrategy</code>: 
</p>

<ul>
<li>
<p> for <code>settings$initStrategy == 'simple'</code>, <code>Delta</code> is simply initialized to the estimated <code>g</code> value of <code>modHom</code>. 
Note that this procedure may fail when <code>settings$penalty == TRUE</code>.
</p>
</li>
<li>
<p> for <code>settings$initStrategy == 'residuals'</code>, <code>Delta</code> is initialized to the estimated residual variance from the homoskedastic mean prediction.
</p>
</li>
<li>
<p> for <code>settings$initStrategy == 'smoothed'</code>, <code>Delta</code> takes the values predicted by <code>modNugs</code> at <code>X0</code>.
</p>
</li>
</ul>
<p>Notice that <code>lower</code> and <code>upper</code> bounds cannot be equal for <code>optim</code>.
</p>


<h3>Value</h3>

<p>a list which is given the S3 class <code>"hetTP"</code>, with elements:
</p>

<ul>
<li> <p><code>theta</code>: unless given, maximum likelihood estimate (mle) of the lengthscale parameter(s),
</p>
</li>
<li> <p><code>Delta</code>: unless given, mle of the nugget vector (non-smoothed),
</p>
</li>
<li> <p><code>Lambda</code>: predicted input noise variance at <code>X0</code>, 
</p>
</li>
<li> <p><code>sigma2</code>: plugin estimator of the variance,
</p>
</li>
<li> <p><code>theta_g</code>: unless given, mle of the lengthscale(s) of the noise/log-noise process,
</p>
</li>
<li> <p><code>k_theta_g</code>: if <code>settings$linkThetas == 'joint'</code>, mle for the constant by which lengthscale parameters of <code>theta</code> are multiplied to get <code>theta_g</code>,
</p>
</li>
<li> <p><code>g</code>: unless given, mle of the nugget of the noise/log-noise process,
</p>
</li>
<li> <p><code>trendtype</code>: either "<code>SK</code>" if <code>beta0</code> is provided, else "<code>OK</code>",
</p>
</li>
<li> <p><code>beta0</code> constant trend of the mean process, plugin-estimator unless given,
</p>
</li>
<li> <p><code>nmean</code>: plugin estimator for the constant noise/log-noise process mean,
</p>
</li>
<li> <p><code>ll</code>: log-likelihood value, (<code>ll_non_pen</code>) is the value without the penalty,
</p>
</li>
<li> <p><code>nit_opt</code>, <code>msg</code>: <code>counts</code> and <code>message</code> returned by <code>optim</code>
</p>
</li>
<li> <p><code>modHom</code>: homoskedastic GP model of class <code>homGP</code> used for initialization of the mean process,
</p>
</li>
<li> <p><code>modNugs</code>: homoskedastic GP model of class <code>homGP</code> used for initialization of the noise/log-noise process,
</p>
</li>
<li> <p><code>nu_hat_var</code>: variance of the noise process,
</p>
</li>
<li> <p><code>used_args</code>: list with arguments provided in the call to the function, which is saved in <code>call</code>,
</p>
</li>
<li> <p><code>X0</code>, <code>Z0</code>, <code>Z</code>, <code>eps</code>, <code>logN</code>, <code>covtype</code>: values given in input,
</p>
</li>
<li> <p><code>time</code>: time to train the model, in seconds.
</p>
</li>
</ul>
<h3>References</h3>

<p>M. Binois, Robert B. Gramacy, M. Ludkovski (2018), Practical heteroskedastic Gaussian process modeling for large simulation experiments,
Journal of Computational and Graphical Statistics, 27(4), 808–821.<br> 
Preprint available on arXiv:1611.05902.<br><br></p>
<p>A. Shah, A. Wilson, Z. Ghahramani (2014), Student-t processes as alternatives to Gaussian processes, Artificial Intelligence and Statistics, 877–885.
</p>


<h3>See Also</h3>

<p><code>predict.hetTP</code> for predictions. 
<code>summary</code> and <code>plot</code> functions are available as well.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##------------------------------------------------------------
## Example 1: Heteroskedastic TP modeling on the motorcycle data
##------------------------------------------------------------
set.seed(32)

## motorcycle data
library(MASS)
X &lt;- matrix(mcycle$times, ncol = 1)
Z &lt;- mcycle$accel
nvar &lt;- 1
plot(X, Z, ylim = c(-160, 90), ylab = 'acceleration', xlab = "time")


## Model fitting
model &lt;- mleHetTP(X = X, Z = Z, lower = rep(0.1, nvar), upper = rep(50, nvar),
                  covtype = "Matern5_2")
            
## Display averaged observations
points(model$X0, model$Z0, pch = 20)

## A quick view of the fit                  
summary(model)

## Create a prediction grid and obtain predictions
xgrid &lt;- matrix(seq(0, 60, length.out = 301), ncol = 1) 
preds &lt;- predict(x = xgrid, object =  model)

## Display mean predictive surface
lines(xgrid, preds$mean, col = 'red', lwd = 2)
## Display 95% confidence intervals
lines(xgrid, preds$mean + sqrt(preds$sd2) * qt(0.05, df = model$nu + nrow(X)), col = 2, lty = 2)
lines(xgrid, preds$mean + sqrt(preds$sd2) * qt(0.95, df = model$nu + nrow(X)), col = 2, lty = 2)
## Display 95% prediction intervals
lines(xgrid, preds$mean + sqrt(preds$sd2 + preds$nugs) * qt(0.05, df = model$nu + nrow(X)),
  col = 3, lty = 2)
lines(xgrid, preds$mean + sqrt(preds$sd2 + preds$nugs) * qt(0.95, df = model$nu + nrow(X)), 
  col = 3, lty = 2)

##------------------------------------------------------------
## Example 2: 2D Heteroskedastic TP modeling
##------------------------------------------------------------
set.seed(1)
nvar &lt;- 2
  
## Branin redefined in [0,1]^2
branin &lt;- function(x){
  if(is.null(nrow(x)))
    x &lt;- matrix(x, nrow = 1)
    x1 &lt;- x[,1] * 15 - 5
    x2 &lt;- x[,2] * 15
    (x2 - 5/(4 * pi^2) * (x1^2) + 5/pi * x1 - 6)^2 + 10 * (1 - 1/(8 * pi)) * cos(x1) + 10
}

## Noise field via standard deviation
noiseFun &lt;- function(x){
  if(is.null(nrow(x)))
    x &lt;- matrix(x, nrow = 1)
  return(1/5*(3*(2 + 2*sin(x[,1]*pi)*cos(x[,2]*3*pi) + 5*rowSums(x^2))))
}

## data generating function combining mean and noise fields
ftest &lt;- function(x){
  return(branin(x) + rnorm(nrow(x), mean = 0, sd = noiseFun(x)))
}

## Grid of predictive locations
ngrid &lt;- 51
xgrid &lt;- matrix(seq(0, 1, length.out = ngrid), ncol = 1) 
Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))

## Unique (randomly chosen) design locations
n &lt;- 100
Xu &lt;- matrix(runif(n * 2), n)

## Select replication sites randomly
X &lt;- Xu[sample(1:n, 20*n, replace = TRUE),]

## obtain training data response at design locations X
Z &lt;- ftest(X)

## Formating of data for model creation (find replicated observations) 
prdata &lt;- find_reps(X, Z, rescale = FALSE, normalize = FALSE)

## Model fitting
model &lt;- mleHetTP(X = list(X0 = prdata$X0, Z0 = prdata$Z0, mult = prdata$mult), Z = prdata$Z, ,
                  lower = rep(0.01, nvar), upper = rep(10, nvar),
                  covtype = "Matern5_2")

## a quick view into the data stored in the "hetTP"-class object
summary(model)                  
             
## prediction from the fit on the grid     
preds &lt;- predict(x = Xgrid, object =  model)

## Visualization of the predictive surface
par(mfrow = c(2, 2))
contour(x = xgrid,  y = xgrid, z = matrix(branin(Xgrid), ngrid), 
  main = "Branin function", nlevels = 20)
points(X, col = 'blue', pch = 20)
contour(x = xgrid,  y = xgrid, z = matrix(preds$mean, ngrid), 
  main = "Predicted mean", nlevels = 20)
points(X, col = 'blue', pch = 20)
contour(x = xgrid,  y = xgrid, z = matrix(noiseFun(Xgrid), ngrid), 
  main = "Noise standard deviation function", nlevels = 20)
points(X, col = 'blue', pch = 20)
contour(x = xgrid,  y= xgrid, z = matrix(sqrt(preds$nugs), ngrid), 
  main = "Predicted noise values", nlevels = 20)
points(X, col = 'blue', pch = 20)
par(mfrow = c(1, 1))
</code></pre>


</div>