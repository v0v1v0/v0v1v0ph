<div class="container">

<table style="width: 100%;"><tr>
<td>universalmclapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run the function FUN on X using parallel computing</h2>

<h3>Description</h3>

<p>Return the results of the function FUN applied to X. It uses forking in unix system and not in windows system.<br>
By default, it will send all the content of environment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">universalmclapply(
  X,
  FUN,
  ...,
  mc.cores = getOption("mc.cores", parallel::detectCores()),
  mc.preschedule = TRUE,
  clusterExport = list(),
  clusterEvalQ = list(),
  forking = ifelse(.Platform$OS.type == "windows", FALSE, TRUE),
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A vector (atomic or list) or an expressions vector. Other objects (including classed objects) will be coerced by as.list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>The function to be applied to each element of X</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments to FUN</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.preschedule</code></td>
<td>
<p>if set to TRUE then the computation is first divided to (at most) as many jobs are there are cores and then the jobs are started, each job possibly covering more than one value. If set to FALSE then one job is forked for each value of X. The former is better for short computations or large number of values in X, the latter is better for jobs that have high variance of completion time and not too many values of X compared to mc.cores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterExport</code></td>
<td>
<p>List of clusterExport parameters as list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterEvalQ</code></td>
<td>
<p>List of clusterEvalQ parameters as list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forking</code></td>
<td>
<p>If TRUE will use forking</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressbar</code></td>
<td>
<p>If pbapply package is installed, show a progressbar</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>universalmclapply runs the function FUN on X using parallel computing
</p>


<h3>Value</h3>

<p>The results of the function FUN applied to X
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(HelpersMG)
x &lt;- 1:1000
funx &lt;- function(y) {
  mint &lt;- rep(NA, length(y))
  for (i in seq_along(y)) {
    k &lt;- rnorm(runif(n = 1, 50, 50), mean=10, sd=2)
    mint[i] &lt;- mean(k)
  }
  mint
}
# Note that parallel computing is not always the best solution !
(tp &lt;- system.time({
   m &lt;- lapply(X=x, FUN=funx)
}))
(tp &lt;- system.time({
   m &lt;- universalmclapply(X=x, FUN=funx, forking=FALSE)
}))
(tp &lt;- system.time({
   m &lt;- universalmclapply(X=x, FUN=funx, forking=TRUE)
}))

### An example using clusterExport
# Here no error is generated because environment was exported
# However forking is not possible in windows and non parallel code is ran
pp &lt;- runif(100)
x &lt;- 1:100
funx1 &lt;- function(y) {pp[y]*10}
u &lt;- universalmclapply(x, FUN=funx1, forking=TRUE)

# Here an error is generated because environment was not exported when parLapplyLB is used
pp &lt;- runif(100)
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE)
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE, 
                       clusterExport=list())

# here no error is generated because the variable pp is exported
pp &lt;- runif(100)
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE, 
                       clusterExport=list(varlist=c("pp"), envir=environment()))

# here no error is generated because all the environment is exported
pp &lt;- runif(100)
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx1, forking=FALSE, 
                       clusterExport=list(varlist=c(ls()), envir=environment()))

### An example using clusterEvalQ
asc("a") # asc() is a function from packages HelpersMG
funx2 &lt;- function(y) {asc("a")*10}
# In unix, the loaded packages are visible from all cores
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx2, forking=TRUE)
# In windows, the loaded packages are not visible from all cores
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx2, forking=FALSE)
# In windows, the loaded packages are not visible from all cores
x &lt;- 1:100
u &lt;- universalmclapply(x, FUN=funx2, forking=FALSE, 
clusterEvalQ=list(expr=expression(library(HelpersMG)))
)

### If package pbapply is available, progress bar can be shown
m &lt;- universalmclapply(X=x, FUN=funx, forking=FALSE, progressbar=TRUE)
m &lt;- universalmclapply(X=x, FUN=funx, forking=TRUE, progressbar=TRUE)

## You can manage the number of cores used using:
options(mc.cores=1)

## End(Not run)
</code></pre>


</div>