<div class="container">

<table style="width: 100%;"><tr>
<td>qqthin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>a version of qqplot() that thins out points that overplot</h2>

<h3>Description</h3>

<p>QQ-plots with large numbers of points typically generate graphics files
that are unhelpfully large.  This function handles the problem by
removing points that are, for all practical purposes, redundant
</p>


<h3>Usage</h3>

<pre><code class="language-R">qqthin(x, y, ends = c(0.01, 0.99), eps = 0.001, xlab = deparse(substitute(x)),
       adj.xlab = NULL, ylab = deparse(substitute(y)), show.line = TRUE,
       print.thinning.details=TRUE, centerline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>ordered values of <code>x</code> will be plotted on the x-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>ordered values of <code>y</code> will be plotted on the y-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ends</code></td>
<td>
<p>outside these cumulative proportions of numbers of points,
all points will be included in the graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>controls the extent of overplotting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>label for x-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.xlab</code></td>
<td>
<p>positioning of x-label</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>label for y-axis</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.line</code></td>
<td>
<p>logical; show the line y=x?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.thinning.details</code></td>
<td>
<p>logical; print number of points after thinning?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centerline</code></td>
<td>
<p>logical; draw a line though the part of the graph where
some points have been omitted?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional graphics parameters</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Gives a qqplot. The number of points retained is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>John Maindonald</p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>Examples</h3>

<pre><code class="language-R">mat &lt;- matrix(rnorm(1000), ncol=20)
cl &lt;- factor(rep(1:3, c(7,9,4)))
Fstats &lt;- aovFbyrow(x = mat, cl = cl)
qqthin(qf(ppoints(length(Fstats)), 2, 17), Fstats, eps=0.01)


## The function is currently defined as
function(x, y, ends=c(.01,.99), eps=0.001,
           xlab = deparse(substitute(x)), adj.xlab=NULL,
           ylab = deparse(substitute(y)), show.line=TRUE,
           print.thinning.details=TRUE,
           centerline=TRUE, ...){
    ## qqthin() is a substitute for qqplot(), that thins
    ## out plotted points from the region where they are
    ## dense.  Apart from the overlaid curve that shows
    ## the region where points have been thinned, it may
    ## be hard to distinguish the result of qqthin()
    ## from that of qqplot()
    xlab &lt;- xlab
    ylab &lt;- ylab
    x &lt;- sort(x)
    y &lt;- sort(y)
    dx&lt;-diff(x)
    epsdist &lt;- sqrt(diff(range(x))^2+diff(range(y))^2)*eps
    dx&lt;-0.5*(c(dx[1],dx)+c(dx,dx[length(dx)]))
    dy&lt;-diff(y)
    dy&lt;-0.5*(c(dy[1],dy)+c(dy,dy[length(dy)]))
    dpoints &lt;- epsdist/sqrt(dx^2+dy^2)
    ## dpoints is a local measure of the number of points
    ## per unit distance along the diagonal, with the unit
    ## set to approximately eps*(length of diagonal)
    dig&lt;-floor(dpoints)+1
    ## dig is, roughly, the number of points per unit distance.
    ## We wish to retain one point per unit distance.  For this
    ## retain points where cdig rounds to an integer. For such
    ## points, cdig has increased by approx 1, relative to the
    ## previous point that is retained.
    cdig&lt;-round(cumsum(1/dig))
    subs&lt;-match(unique(cdig), cdig)
    if(is.null(adj.xlab))
    plot(x[subs], y[subs], xlab=xlab, ylab=ylab)
    else {
      plot(x[subs], y[subs], xlab="", ylab=ylab)
      mtext(side=1, xlab, adj=adj.xlab, line=par()$mgp[1])
    }
    if(any(diff(subs)&gt;1)){
    n1 &lt;- min(subs[c(diff(subs),0)&gt;1])
    n2 &lt;- max(subs[c(0,diff(subs))&gt;1])
    ns1 &lt;- match(n1, subs)
    ns2 &lt;- match(n2, subs)
    if(print.thinning.details)
       print(paste("Graph retains", length(subs), "points."))
    if(centerline)
      lines(smooth.spline(x[subs[ns1:ns2]], y[subs[ns1:ns2]]),
            col="grey", lwd=2)
	    }
    if(show.line)abline(0, 1, col="red")
invisible(length(subs))
  }
</code></pre>


</div>