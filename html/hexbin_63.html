<div class="container">

<table style="width: 100%;"><tr>
<td>gplot.hexbin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting Hexagon Cells with a Legend</h2>

<h3>Description</h3>

<p>Plots Hexagons visualizing the counts in an hexbin object.  Different
styles are availables.  Provides a legend indicating the count
representations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
gplot.hexbin(x, style = "colorscale", legend = 1.2, lcex = 1,
      minarea = 0.04, maxarea = 0.8, mincnt = 1, maxcnt = max(x@count),
      trans = NULL, inv = NULL, colorcut = seq(0, 1, length = min(17, maxcnt)),
      border = NULL, density = NULL, pen = NULL,
      colramp = function(n) LinGray(n,beg = 90,end = 15),
      xlab = "", ylab = "", main = "", newpage = TRUE,
      type = c("p", "l", "n"), xaxt = c("s", "n"), yaxt = c("s", "n"),
      clip = "on", verbose = getOption("verbose"))



## S4 method for signature 'hexbin,missing'
plot(x, style = "colorscale", legend = 1.2, lcex = 1,
      minarea = 0.04, maxarea = 0.8, mincnt = 1, maxcnt = max(x@count),
      trans = NULL, inv = NULL, colorcut = seq(0, 1, length = min(17, maxcnt)),
      border = NULL, density = NULL, pen = NULL,
      colramp = function(n) LinGray(n,beg = 90,end = 15),
      xlab = "", ylab = "", main = "", newpage = TRUE,
      type = c("p", "l", "n"), xaxt = c("s", "n"), yaxt = c("s", "n"),
      clip = "on", verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>hexbin</code>.</p>
</td>
</tr></table>
<table>
<tr style="vertical-align: top;">
<td><code>style</code></td>
<td>
<p>string specifying the style of hexagon plot,
see <code>grid.hexagons</code> for the possibilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>numeric width of the legend in inches of <code>FALSE</code>.
In the latter case, or when <code>0</code>, no legend is not produced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcex</code></td>
<td>
<p>characters  expansion size for the text in the legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minarea</code></td>
<td>
<p>fraction of cell area for the lowest count</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxarea</code></td>
<td>
<p>fraction of the cell area for the largest count</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mincnt</code></td>
<td>
<p>cells with fewer counts are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxcnt</code></td>
<td>
<p>cells with more counts are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p><code>function</code> specifying a transformation for
the counts such as <code>sqrt</code>.</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>inv</code></td>
<td>
<p>the inverse transformation of <code>trans</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorcut</code></td>
<td>
<p>vector of values covering [0, 1] that determine
hexagon color class boundaries and hexagon legend size boundaries.
Alternatively, an integer (<code>&lt;= maxcnt</code>) specifying the
<em>number</em> of equispaced colorcut values in [0,1].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border, density, pen</code></td>
<td>
<p>color for polygon borders and filling of
each hexagon drawn, passed to <code>grid.hexagons</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colramp</code></td>
<td>
<p>function accepting an integer <code>n</code> as an argument and
returning n colors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab</code></td>
<td>
<p>x- and y-axis label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>main title.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newpage</code></td>
<td>
<p>should a new page start?.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type, xaxt, yaxt</code></td>
<td>
<p>strings to be used (when set to <code>"n"</code>) for
suppressing the plotting of hexagon symbols, or the x- or y-axis,
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clip</code></td>
<td>
<p>either 'on' or 'off' are the allowed arguments, when on
everything is clipped to the plotting region.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical indicating if some diagnostic output should happen.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is the (S4) <code>plot</code> method for <code>hexbin</code> (and
<code>erodebin</code>) objects (erodebin-class).
</p>
<p>To use the standalone function
<code>gplot.hexbin()</code> is <b><em>deprecated</em></b>.
For <code>style</code>, <code>minarea</code> etc, see the <b>Details</b> section of
<code>grid.hexagons</code>'s help page.
</p>
<p>The legend functionality is somewhat preliminary.  Later versions may
include refinements and handle extreme cases (small and large) for
cell size and counts.
</p>
<p>All arguments of <code>gplot.hexbin</code> can also be used for the S4 
<code>plot</code> method.
</p>


<h3>Value</h3>

<p>invisibly, a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>plot.vp</code></td>
<td>
<p>the <code>hexViewport</code> constructed and used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.vp</code></td>
<td>
<p>if a legend has been produced, its
<code>viewport</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Dan Carr <a href="mailto:dcarr@voxel.galaxy.gmu.edu">dcarr@voxel.galaxy.gmu.edu</a>,
ported by Nicholas Lewin-Koh <a href="mailto:kohnicho@comp.nus.edu.sg">kohnicho@comp.nus.edu.sg</a> and
Martin Maechler.
</p>


<h3>References</h3>

<p> see in <code>grid.hexagons</code>.</p>


<h3>See Also</h3>

<p><code>hexbin</code>, <code>hexViewport</code>,
<code>smooth.hexbin</code>,
<code>erode.hexbin</code>,
<code>hcell2xy</code>, <code>hboxplot</code>,
<code>hdiffplot</code>.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 1) simple binning of spherical normal:
x &lt;- rnorm(10000)
y &lt;- rnorm(10000)
bin &lt;- hexbin(x,y)

## Plot method for hexbin !
## ---- ------     --------
plot(bin)
# nested lattice
plot(bin, style= "nested.lattice")

# controlling the colorscheme
plot(bin, colramp=BTY, colorcut=c(0,.1,.2,.3,.4,.6,1))

## 2) A mixture distribution
x &lt;- c(rnorm(5000),rnorm(5000,4,1.5))
y &lt;- c(rnorm(5000),rnorm(5000,2,3))
bin &lt;- hexbin(x,y)

pens &lt;- cbind(c("#ECE2F0","#A6BDDB","#1C9099"),
              c("#FFF7BC","#FEC44F","#D95F0E"))
plot(bin, style = "nested.lattice", pen=pens)
# now really crazy
plot(bin, style = "nested.lattice", pen=pens,border=2,density=35)

# lower resolution binning and overplotting with counts
bin &lt;- hexbin(x,y,xbins=25)
P &lt;- plot(bin, style="lattice", legend=FALSE,
          minarea=1, maxarea=1, border="white")
##

library("grid")
pushHexport(P$plot.vp)
xy &lt;- hcell2xy(bin)
  # to show points rather than counts :
grid.points(x,y,pch=18,gp=gpar(cex=.3,col="green"))
grid.text(as.character(bin@count), xy$x,xy$y,
          gp=gpar(cex=0.3, col="red"),default.units="native")
popViewport()

# Be creative, have fun!
</code></pre>


</div>