<div class="container">

<table style="width: 100%;"><tr>
<td>crit_optim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Criterion optimization</h2>

<h3>Description</h3>

<p>Search for the best value of available criterion, possibly using a h-steps lookahead strategy to favor designs with replication
</p>


<h3>Usage</h3>

<pre><code class="language-R">crit_optim(
  model,
  crit,
  ...,
  h = 2,
  Xcand = NULL,
  control = list(multi.start = 10, maxit = 100),
  seed = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p><code>homGP</code> or <code>hetGP</code> model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>considered criterion, one of <code>"crit_cSUR"</code>, <code>"crit_EI"</code>, <code>"crit_ICU"</code>,
<code>"crit_MCU"</code> and <code>"crit_tMSE"</code>. Note that <code>crit_IMSPE</code> has its dedicated method, see <code>IMSPE_optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters of the criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>horizon for multi-step ahead framework.
The decision is made between:
</p>

<ul>
<li>
<p> sequential crit search starting by a new design (optimized first) then adding <code>h</code> replicates
</p>
</li>
<li>
<p> sequential crit searches starting by <code>1</code> to <code>h</code> replicates before adding a new point
</p>
</li>
</ul>
<p>Use <code>h = 0</code> for the myopic criterion, i.e., not looking ahead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xcand</code></td>
<td>
<p>optional discrete set of candidates (otherwise a maximin LHS is used to initialize continuous search)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list in case <code>Xcand == NULL</code>, with elements <code>multi.start</code>,
to perform a multi-start optimization based on <code>optim</code>, with <code>maxit</code> iterations each.
Also, <code>tol_dist</code> defines the minimum distance to an existing design for a new point to be added, otherwise the closest existing design is chosen.
In a similar fashion, <code>tol_dist</code> is the minimum relative change of crit for adding a new design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>optional seed for the generation of LHS designs with <code>maximinSA_LHS</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>number of CPU available (&gt; 1 mean parallel TRUE), see <code>mclapply</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When looking ahead, the kriging believer heuristic is used,
meaning that the non-observed value is replaced by the mean prediction in the update.
</p>


<h3>Value</h3>

<p>list with elements:
</p>

<ul>
<li> <p><code>par</code>: best first design,
</p>
</li>
<li> <p><code>value</code>: criterion h-steps ahead starting from adding <code>par</code>,
</p>
</li>
<li> <p><code>path</code>: list of elements list(<code>par</code>, <code>value</code>, <code>new</code>) at each step <code>h</code>
</p>
</li>
</ul>
<h3>References</h3>

<p>M. Binois, J. Huang, R. B. Gramacy, M. Ludkovski (2019), 
Replication or exploration? Sequential design for stochastic simulation experiments,
Technometrics, 61(1), 7-23.<br> 
Preprint available on arXiv:1710.03206.
</p>


<h3>Examples</h3>

<pre><code class="language-R">###############################################################################
## Bi-variate example (myopic version)
###############################################################################

nvar &lt;- 2 

set.seed(42)
ftest &lt;- function(x, coef = 0.1) return(sin(2*pi*sum(x)) + rnorm(1, sd = coef))

n &lt;- 25 # must be a square
xgrid0 &lt;- seq(0.1, 0.9, length.out = sqrt(n))
designs &lt;- as.matrix(expand.grid(xgrid0, xgrid0))
X &lt;- designs[rep(1:n, sample(1:10, n, replace = TRUE)),]
Z &lt;- apply(X, 1, ftest)

model &lt;- mleHomGP(X, Z, lower = rep(0.1, nvar), upper = rep(1, nvar))

ngrid &lt;- 51
xgrid &lt;- seq(0,1, length.out = ngrid)
Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))

preds &lt;- predict(x = Xgrid, object =  model)

## Initial plots
contour(x = xgrid,  y = xgrid, z = matrix(preds$mean, ngrid),
        main = "Predicted mean", nlevels = 20)
points(model$X0, col = 'blue', pch = 20)

crit &lt;- "crit_EI"
crit_grid &lt;- apply(Xgrid, 1, crit, model = model)
filled.contour(x = xgrid, y = xgrid, matrix(crit_grid, ngrid),
               nlevels = 20, color.palette = terrain.colors, 
               main = "Initial criterion landscape",
plot.axes = {axis(1); axis(2); points(model$X0, pch = 20)})

## Sequential crit search
nsteps &lt;- 1 # Increase for better results

for(i in 1:nsteps){
  res &lt;- crit_optim(model, crit = crit, h = 0, control = list(multi.start = 50, maxit = 30))
  newX &lt;- res$par
  newZ &lt;- ftest(newX)
  model &lt;- update(object = model, Xnew = newX, Znew = newZ)
}

## Final plots
contour(x = xgrid,  y = xgrid, z = matrix(preds$mean, ngrid),
        main = "Predicted mean", nlevels = 20)
points(model$X0, col = 'blue', pch = 20)

crit_grid &lt;- apply(Xgrid, 1, crit, model = model)
filled.contour(x = xgrid, y = xgrid, matrix(crit_grid, ngrid),
               nlevels = 20, color.palette = terrain.colors, 
               main = "Final criterion landscape",
plot.axes = {axis(1); axis(2); points(model$X0, pch = 20)})

###############################################################################
## Bi-variate example (look-ahead version)
###############################################################################
## Not run:   
nvar &lt;- 2 

set.seed(42)
ftest &lt;- function(x, coef = 0.1) return(sin(2*pi*sum(x)) + rnorm(1, sd = coef))

n &lt;- 25 # must be a square
xgrid0 &lt;- seq(0.1, 0.9, length.out = sqrt(n))
designs &lt;- as.matrix(expand.grid(xgrid0, xgrid0))
X &lt;- designs[rep(1:n, sample(1:10, n, replace = TRUE)),]
Z &lt;- apply(X, 1, ftest)

model &lt;- mleHomGP(X, Z, lower = rep(0.1, nvar), upper = rep(1, nvar))

ngrid &lt;- 51
xgrid &lt;- seq(0,1, length.out = ngrid)
Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))

nsteps &lt;- 5 # Increase for more steps
crit &lt;- "crit_EI"

# To use parallel computation (turn off on Windows)
library(parallel)
parallel &lt;- FALSE #TRUE #
if(parallel) ncores &lt;- detectCores() else ncores &lt;- 1

for(i in 1:nsteps){
  res &lt;- crit_optim(model, h = 3, crit = crit, ncores = ncores,
                    control = list(multi.start = 100, maxit = 50))
  
  # If a replicate is selected
  if(!res$path[[1]]$new) print("Add replicate")
  
  newX &lt;- res$par
  newZ &lt;- ftest(newX)
  model &lt;- update(object = model, Xnew = newX, Znew = newZ)
  
  ## Plots 
  preds &lt;- predict(x = Xgrid, object =  model)
  contour(x = xgrid,  y = xgrid, z = matrix(preds$mean, ngrid),
          main = "Predicted mean", nlevels = 20)
  points(model$X0, col = 'blue', pch = 20)
  points(newX, col = "red", pch = 20)
  
  crit_grid &lt;- apply(Xgrid, 1, crit, model = model)
  filled.contour(x = xgrid, y = xgrid, matrix(crit_grid, ngrid),
                 nlevels = 20, color.palette = terrain.colors,
  plot.axes = {axis(1); axis(2); points(model$X0, pch = 20)})
}

## End(Not run)
</code></pre>


</div>