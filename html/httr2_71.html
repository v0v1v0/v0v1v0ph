<div class="container">

<table style="width: 100%;"><tr>
<td>req_perform_sequential</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform multiple requests in sequence</h2>

<h3>Description</h3>

<p>Given a list of requests, this function performs each in turn, returning
a list of responses. It's slower than <code>req_perform_parallel()</code> but
has fewer limitations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">req_perform_sequential(
  reqs,
  paths = NULL,
  on_error = c("stop", "return", "continue"),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>reqs</code></td>
<td>
<p>A list of requests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>An optional character vector of paths, if you want to download
the request bodies to disk. If supplied, must be the same length as <code>reqs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>on_error</code></td>
<td>
<p>What should happen if one of the requests fails?
</p>

<ul>
<li> <p><code>stop</code>, the default: stop iterating with an error.
</p>
</li>
<li> <p><code>return</code>: stop iterating, returning all the successful responses
received so far, as well as an error object for the failed request.
</p>
</li>
<li> <p><code>continue</code>: continue iterating, recording errors in the result.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Display a progress bar? Use <code>TRUE</code> to turn on a basic
progress bar, use a string to give it a name, or see progress_bars to
customise it in other ways.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list, the same length as <code>reqs</code>, containing responses and possibly
error objects, if <code>on_error</code> is <code>"return"</code> or <code>"continue"</code> and one of the
responses errors. If <code>on_error</code> is <code>"return"</code> and it errors on the ith
request, the ith element of the result will be an error object, and the
remaining elements will be <code>NULL</code>. If <code>on_error</code> is <code>"continue"</code>, it will
be a mix of requests and error objects.
</p>
<p>Only httr2 errors are captured; see <code>req_error()</code> for more details.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># One use of req_perform_sequential() is if the API allows you to request
# data for multiple objects, you want data for more objects than can fit
# in one request.
req &lt;- request("https://api.restful-api.dev/objects")

# Imagine we have 50 ids:
ids &lt;- sort(sample(100, 50))

# But the API only allows us to request 10 at time. So we first use split
# and some modulo arithmetic magic to generate chunks of length 10
chunks &lt;- unname(split(ids, (seq_along(ids) - 1) %/% 10))

# Then we use lapply to generate one request for each chunk:
reqs &lt;- chunks |&gt; lapply(\(idx) req |&gt; req_url_query(id = idx, .multi = "comma"))

# Then we can perform them all and get the results
## Not run: 
resps &lt;- reqs |&gt; req_perform_sequential()
resps_data(resps, \(resp) resp_body_json(resp))

## End(Not run)
</code></pre>


</div>