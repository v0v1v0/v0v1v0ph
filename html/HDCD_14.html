<div class="container">

<table style="width: 100%;"><tr>
<td>Pilliat_test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pilliat single change-point test</h2>

<h3>Description</h3>

<p>R wrapper function testing for a single change-point using the three test statistics in the multiple change point detection algorithm of Pilliat et al. (2023). See also Appendix E in Moen et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class="language-R">Pilliat_test(
  X,
  empirical = FALSE,
  N = 100,
  tol = 0.05,
  thresholds_partial = NULL,
  threshold_dense = NULL,
  thresholds_bj = NULL,
  threshold_d_const = 4,
  threshold_bj_const = 6,
  threshold_partial_const = 4,
  rescale_variance = TRUE,
  fast = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of observations, where each row contains a time series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>empirical</code></td>
<td>
<p>If <code>TRUE</code>, detection thresholds are based on Monte Carlo simulation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>If <code>empirical=TRUE</code>, <code>N</code> is the number of Monte Carlo samples used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>If <code>empirical=TRUE</code>, <code>tol</code> is the false error probability tolerance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds_partial</code></td>
<td>
<p>Vector of manually specified detection thresholds for the partial sum statistic, for sparsities/partial sums <code class="reqn">t=1,2,4,\ldots,2^{\lfloor\log_2(p)\rfloor}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold_dense</code></td>
<td>
<p>Manually specified value of detection threshold for the dense statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds_bj</code></td>
<td>
<p>Vector of manually specified detection thresholds for the Berk-Jones statistic, order corresponding to <code class="reqn">x=1,2,\ldots,x_0</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold_d_const</code></td>
<td>
<p>Leading constant for the analytical detection threshold for the dense statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold_bj_const</code></td>
<td>
<p>Leading constant for <code class="reqn">p_0</code> when computing the detection threshold for the Berk-Jones statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold_partial_const</code></td>
<td>
<p>Leading constant for the analytical detection threshold for the partial sum statistic</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescale_variance</code></td>
<td>
<p>If <code>TRUE</code>, each row of the data is re-scaled by a MAD estimate (see <code>rescale_variance</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast</code></td>
<td>
<p>If <code>TRUE</code>, only the mid-point of <code class="reqn">(0,\ldots,n]</code> is tested for a change-point. Otherwise a test is performed at each candidate change-point poisition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>If <code>TRUE</code>, diagnostic prints are provided during execution</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>1 if a change-point is detected, 0 otherwise
</p>


<h3>References</h3>

<p>Moen PAJ, Glad IK, Tveten M (2023).
“Efficient sparsity adaptive changepoint estimation.”
Arxiv preprint, 2306.04702, <a href="https://doi.org/10.48550/arXiv.2306.04702">https://doi.org/10.48550/arXiv.2306.04702</a>.<br><br> Pilliat E, Carpentier A, Verzelen N (2023).
“Optimal multiple change-point detection for high-dimensional data.”
<em>Electronic Journal of Statistics</em>, <b>17</b>(1), 1240 – 1315.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(HDCD)
n = 200
p = 200

# Generating data
X = matrix(rnorm(n*p), ncol = n, nrow=p)
Y = matrix(rnorm(n*p), ncol = n, nrow=p)

# Adding a single sparse change-point to X (and not Y):
X[1:5, 100:200] = X[1:5, 100:200] +1

# Vanilla Pilliat test:
resX = Pilliat_test(X)
resX
resY = Pilliat_test(Y)
resY

# Manually setting leading constants for the theoretical thresholds for the three 
# test statistics used
resX = Pilliat_test(X, 
                    threshold_d_const=4, 
                    threshold_bj_const=6, 
                    threshold_partial_const=4
)
resX 
resY = Pilliat_test(Y, 
                    threshold_d_const=4, 
                    threshold_bj_const=6, 
                    threshold_partial_const=4
)
resY

# Empirical choice of thresholds:
resX = Pilliat_test(X, empirical = TRUE, N = 100, tol = 1/100)
resX
resY = Pilliat_test(Y, empirical = TRUE, N = 100, tol = 1/100)
resY

# Manual empirical choice of thresholds (equivalent to the above)
thresholds_test_emp = Pilliat_test_calibrate(n,p, N=100, tol=1/100,bonferroni=TRUE)
resX = Pilliat_test(X, 
                    threshold_dense=thresholds_test_emp$threshold_dense, 
                    thresholds_bj = thresholds_test_emp$thresholds_bj, 
                    thresholds_partial = thresholds_test_emp$thresholds_partial
)
resX
resY = Pilliat_test(Y, 
                    threshold_dense=thresholds_test_emp$threshold_dense, 
                    thresholds_bj = thresholds_test_emp$thresholds_bj, 
                    thresholds_partial = thresholds_test_emp$thresholds_partial
)
resY
</code></pre>


</div>