<div class="container">

<table style="width: 100%;"><tr>
<td>hpaDist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Probabilities and Moments Hermite Polynomial Approximation</h2>

<h3>Description</h3>

<p>Approximation of truncated, marginal and conditional densities,
moments and cumulative probabilities of multivariate distributions via
Hermite polynomial based approach proposed by Gallant and Nychka in 1987.
</p>
<p>Density approximating function is scale adjusted product of two terms. 
The first one is squared multivariate polynomial of <code>pol_degrees</code>  
degrees with <code>pol_coefficients</code> coefficients vector. 
The second is product of independent normal random variables' densities with 
expected values and standard deviations given by <code>mean</code> and <code>sd</code> 
vectors correspondingly. Approximating function satisfies properties of 
density function thus generating a broad family of distributions.
Characteristics of these distributions 
(moments, quantiles, probabilities and so on) 
may provide accurate approximations to characteristic of other
distributions. Moreover it is usually possible to provide arbitrary close
approximation by the means of polynomial degrees increase.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dhpa(
  x,
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

phpa(
  x,
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

ihpa(
  x_lower = numeric(0),
  x_upper = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

ehpa(
  x = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  expectation_powers = numeric(0),
  is_parallel = FALSE,
  is_validation = TRUE
)

etrhpa(
  tr_left = numeric(0),
  tr_right = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  expectation_powers = numeric(0),
  is_parallel = FALSE,
  is_validation = TRUE
)

dtrhpa(
  x,
  tr_left = numeric(0),
  tr_right = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

itrhpa(
  x_lower = numeric(0),
  x_upper = numeric(0),
  tr_left = numeric(0),
  tr_right = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

dhpaDiff(
  x,
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  type = "pol_coefficients",
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

ehpaDiff(
  x = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  expectation_powers = numeric(0),
  type = "pol_coefficients",
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

ihpaDiff(
  x_lower = numeric(0),
  x_upper = numeric(0),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0),
  type = "pol_coefficients",
  is_parallel = FALSE,
  log = FALSE,
  is_validation = TRUE
)

qhpa(
  p,
  x = matrix(1, 1),
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  given_ind = numeric(0),
  omit_ind = numeric(0),
  mean = numeric(0),
  sd = numeric(0)
)

rhpa(
  n,
  pol_coefficients = numeric(0),
  pol_degrees = numeric(0),
  mean = numeric(0),
  sd = numeric(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric matrix of function arguments and
conditional values. Note that <code>x</code> rows are points (observations)
while random vectors components (variables) are columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pol_coefficients</code></td>
<td>
<p>numeric vector of polynomial coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pol_degrees</code></td>
<td>
<p>non-negative integer vector of polynomial 
degrees (orders).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>given_ind</code></td>
<td>
<p>logical or numeric vector indicating whether corresponding 
random vector component is conditioned. By default it is a logical 
vector of <code>FALSE</code> values. If <code>give_ind[i]</code> equals <code>TRUE</code> or 
<code>i</code> then <code>i</code>-th column of <code>x</code> matrix will contain 
conditional values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit_ind</code></td>
<td>
<p>logical or numeric vector indicating whether corresponding
random component is omitted. By default it is a logical vector 
of <code>FALSE</code> values. If <code>omit_ind[i]</code> equals <code>TRUE</code> or <code>i</code> 
then values in <code>i</code>-th column of <code>x</code> matrix will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>numeric vector of expected values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>positive numeric vector of standard deviations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_parallel</code></td>
<td>
<p>if <code>TRUE</code> then multiple cores will be
used for some calculations. It usually provides speed advantage for
large enough samples (about more than 1000 observations).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical; if <code>TRUE</code> then probabilities p are given as log(p)
or derivatives will be given respect to log(p).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_validation</code></td>
<td>
<p>logical value indicating whether function input 
arguments should be validated.  Set it to <code>FALSE</code> for slight
performance boost (default value is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_lower</code></td>
<td>
<p>numeric matrix of lower integration limits.
Note that <code>x_lower</code> rows are observations while variables are columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_upper</code></td>
<td>
<p>numeric matrix of upper integration limits.
Note that <code>x_upper</code> rows are observations while variables
are columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expectation_powers</code></td>
<td>
<p>integer vector of random vector components powers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr_left</code></td>
<td>
<p>numeric matrix of left (lower) truncation limits.
Note that <code>tr_left</code> rows are observations while variables are columns.
If <code>tr_left</code> and <code>tr_right</code> are single row matrices then the same 
truncation limits will be applied to all observations that are determined 
by the first rows of these matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tr_right</code></td>
<td>
<p>numeric matrix of right (upper) truncation limits.
Note that <code>tr_right</code> rows are observations while variables are columns.
If <code>tr_left</code> and <code>tr_right</code> are single row matrices then the same 
truncation limits will be applied to all observations that are determined 
by the first rows of these matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>determines the partial derivatives to be included into the
gradient. If <code>type="pol_coefficients"</code> then gradient will contain 
partial derivatives respect to polynomial coefficients listed in the
same order as <code>pol_coefficients</code>. Other available types are 
<code>type = "mean"</code> and <code>type = "sd"</code>.
For function <code>dhpaDiff</code> it is possible to take
gradient respect to the x points setting <code>type="x"</code>.
For function <code>ihpaDiff</code> it is possible to take
gradient respect to the x lower and upper points setting 
<code>type = "x_lower"</code> or <code>type = "upper"</code> correspondingly.
In order to get full gradient please set <code>type="all"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>numeric vector of probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>positive integer representing the number of observations</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is possible to approximate densities 
<code>dhpa</code>, cumulative probabilities
<code>phpa</code>, <code>ihpa</code>, moments
<code>ehpa</code> as well as their truncated
<code>dtrhpa</code>, <code>itrhpa</code>, 
<code>etrhpa</code> forms
and gradients <code>dhpaDiff</code>, <code>ihpaDiff</code>.
Note that <code>phpa</code> is special of <code>ihpa</code>
where <code>x</code>
corresponds to <code>x_upper</code> while <code>x_lower</code> is matrix of
negative infinity values. So  <code>phpa</code> intended to approximate 
cumulative
distribution functions while <code>ihpa</code> approximates 
probabilities that
random vector components will be between values determined by rows of 
<code>x_lower</code> and <code>x_upper</code> matrices. Further details are given below.
</p>
<p>Since density approximating function is non-negative and integrates
to 1 it is density function for some <code class="reqn">m</code>-variate 
random vector <code class="reqn">\xi</code>. Approximating function <code class="reqn">f_{\xi }(x)</code> 
has the following form:
</p>
<p style="text-align: center;"><code class="reqn">f_{\xi }(x) = f_{\xi }(x;\mu, \sigma, \alpha) =
\frac{1}{\psi }\prod\limits_{t=1}^{m}\phi 
({x}_{t};{\mu }_{t},{\sigma }_{t}){{\left( \sum\limits_{{i}_{1}=0}^{{K}_{1}}
{...}\sum\limits_{{i}_{m}=0}^{{K}_{m}}{{{\alpha }_{({{i}_{1}},...,{{i}_{m}})
}}\prod\limits_{r=1}^{m}x_{r}^{{{i}_{r}}}} \right)}^{2}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\psi =\sum\limits_{{i}_{1}=0}^{{K}_{1}}{...}\sum
\limits_{{i}_{m}=0}^{{K}_{m}}{\sum\limits_{{j}_{1}=0}^{{K}_{1}}
{...}\sum\limits_{{j}_{m}=0}^{{K}_{m}}{{{\alpha }_{({i}_{1},
\cdots,{i}_{m})}}{{\alpha }_{({j}_{1},\cdots,{j}_{m})}}\prod
\limits_{r=1}^{m}\mathcal{M}({i}_{r}+{j}_{r};{{\mu }_{r}},{\sigma }_{r})}},</code>
</p>

<p>where:
</p>
<p><code class="reqn">x = (x_{1},...x_{m})</code> - is vector of arguments i.e. rows
of <code>x</code> matrix in <code>dhpa</code>.
</p>
<p><code class="reqn">{\alpha }_{({i}_{1},\cdots,{i}_{m})}</code> - is polynomial coefficient
corresponding to <code>pol_coefficients[k]</code> element. In order to investigate
correspondence between <code>k</code> and <code class="reqn">({i}_{1},\cdots,{i}_{m})</code> values 
please see 'Examples' section below or <code>polynomialIndex</code> 
function 'Details', 'Value' and 'Examples' sections. Note that if <code class="reqn">m=1</code>
then <code>pol_coefficients[k]</code> simply corresponds to <code class="reqn">\alpha_{k-1}</code>.
</p>
<p><code class="reqn">(K_{1},...,K_{m})</code> - are polynomial degrees (orders) provided via
<code>pol_degrees</code> argument so <code>pol_degrees[i]</code> determines <code class="reqn">K_{i}</code>.
</p>
<p><code class="reqn">\phi 
(.;{\mu }_{t},{\sigma }_{t})</code> - is normal random variable density function 
where <code class="reqn">\mu_{t}</code> and <code class="reqn">\sigma_{t}</code> are mean and standard deviation 
determined by <code>mean[t]</code> and <code>sd[t]</code> arguments values.
</p>
<p><code class="reqn">\mathcal{M}(q;{{\mu }_{r}},{\sigma }_{r})</code> - is <code class="reqn">q</code>-th order
moment of normal random variable with mean <code class="reqn">{\mu }_{r}</code> and standard
deviation <code class="reqn">{\sigma }_{r}</code>. Note that function 
<code>normalMoment</code> allows to calculate and differentiate normal 
random variable's moments.
</p>
<p><code class="reqn">\psi</code> - constant term insuring that <code class="reqn">f_{\xi }(x)</code> is
density function.
</p>
<p>Therefore <code>dhpa</code> allows to calculate <code class="reqn">f_{\xi}(x)</code> 
values at points
determined by rows of <code>x</code> matrix given polynomial 
degrees <code>pol_degrees</code> (<code class="reqn">K</code>) as well as <code>mean</code> (<code class="reqn">\mu</code>), 
<code>sd</code> (<code class="reqn">\sigma</code>) and <code>pol_coefficients</code> (<code class="reqn">\alpha</code>) 
parameters values. Note that <code>mean</code>, <code>sd</code> and <code>pol_degrees</code> are 
<code class="reqn">m</code>-variate vectors while <code>pol_coefficients</code> has
<code>prod(pol_degrees + 1)</code> elements.
</p>
<p>Cumulative probabilities could be approximated as follows:
</p>
<p style="text-align: center;"><code class="reqn">P\left(\underline{x}_{1}\leq\xi_{1}\leq\overline{x}_{1},...,
\underline{x}_{m}\leq\xi_{m}\leq\overline{x}_{m}\right) = </code>
</p>

<p style="text-align: center;"><code class="reqn">= \bar{F}_{\xi}(\underline{x},\bar{x}) = 
\bar{F}_{\xi}(\underline{x},\bar{x};\mu, \sigma, \alpha) =
\frac{1}{\psi }
\prod\limits_{t=1}^{m}(\Phi ({{{\bar{x}}}_{t}};{{\mu }_{t}},
{{\sigma }_{t}})-\Phi ({{{\underline{x}}}_{t}};{{\mu }_{t}},
{{\sigma }_{t}})) * </code>
</p>

<p><code class="reqn">* \sum\limits_{{{i}_{1}}=0}^{{{K}_{1}}}{...}
\sum\limits_{{{i}_{m}}=0}^{{{K}_{m}}}{\sum\limits_{{{j}_{1}}=0}^{{{K}_{1}}}
{...}\sum\limits_{{{j}_{m}}=0}^{{{K}_{m}}}
{{{\alpha }_{({{i}_{1}},...,{{i}_{m}})}}{{\alpha }_{({{j}_{1}},...,{{j}_{m}})
}}}}\prod\limits_{r=1}^{m}\mathcal{M}_{TR}\left({i}_{r}+{j}_{r};
\underline{x}_{r},\overline{x}_{r},\mu_{r},\sigma_{r}\right)</code>
</p>
<p>where:
</p>
<p><code class="reqn">\Phi 
(.;{\mu }_{t},{\sigma }_{t})</code> - is normal random variable's cumulative 
distribution function where <code class="reqn">\mu_{t}</code> and <code class="reqn">\sigma_{t}</code> are mean and 
standard deviation determined by <code>mean[t]</code> and <code>sd[t]</code> arguments 
values.
</p>
<p><code class="reqn">\mathcal{M}_{TR}(q;
\underline{x}_{r},\overline{x}_{r},\mu_{r},\sigma_{r})</code> - is 
<code class="reqn">q</code>-th order
moment of truncated (from above by <code class="reqn">\overline{x}_{r}</code> and from below by
<code class="reqn">\underline{x}_{r}</code>) 
normal random variable with mean <code class="reqn">{\mu }_{r}</code> and standard
deviation <code class="reqn">{\sigma }_{r}</code>. Note that function 
<code>truncatedNormalMoment</code> allows to calculate and 
differentiate truncated normal random variable's moments.
</p>
<p><code class="reqn">\overline{x} = (\overline{x}_{1},...,\overline{x}_{m})</code> - 
vector of upper integration limits
i.e. rows of <code>x_upper</code> matrix in <code>ihpa</code>.
</p>
<p><code class="reqn">\underline{x} = (\underline{x}_{1},...,\underline{x}_{m})</code> - 
vector of lower integration limits
i.e. rows of <code>x_lower</code> matrix in <code>ihpa</code>.
</p>
<p>Therefore <code>ihpa</code> allows to calculate interval distribution 
function <code class="reqn">\bar{F}_{\xi}(\underline{x},\bar{x})</code>
values at points determined by rows of <code>x_lower</code> (<code class="reqn">\underline{x}</code>)
and <code>x_upper</code> (<code class="reqn">\overline{x}</code>) matrices.
The rest of the arguments are similar to <code>dhpa</code>.
</p>
<p>Expected value powered product approximation is as follows:
</p>
<p style="text-align: center;"><code class="reqn">E\left( \prod\limits_{t=1}^{m}\xi_{t}^{{{k}_{t}}} \right)=
\frac{1}{\psi }\sum\limits_{{{i}_{1}}=0}^{{{K}_{1}}}{...}
\sum\limits_{{{i}_{m}}=0}^{{{K}_{m}}}
{\sum\limits_{{{j}_{1}}=0}^{{{K}_{1}}}{...}
\sum\limits_{{{j}_{m}}=0}^{{{K}_{m}}}
{{{\alpha }_{({{i}_{1}},...,{{i}_{m}})}}
{{\alpha }_{({{j}_{1}},...,{{j}_{m}})}}}}
\prod\limits_{r=1}^{m}\mathcal{M}({{i}_{r}}+{{j}_{r}}+{{k}_{t}};
{{\mu }_{r}},{{\sigma }_{r}})</code>
</p>

<p>where <code class="reqn">(k_{1},...,k_{m})</code> are integer powers determined by
<code>expectation_powers</code> argument of <code>ehpa</code> so
<code>expectation_powers[t]</code> assigns <code class="reqn">k_{t}</code>. Note that argument <code>x</code>
in <code>ehpa</code> allows to determined conditional values.
</p>
<p>Expanding polynomial degrees <code class="reqn">(K_{1},...,K_{m})</code> it is possible to 
provide arbitrary close approximation to density of some <code class="reqn">m</code>-variate 
random vector <code class="reqn">\xi^{\star}</code>. So actually <code class="reqn">f_{\xi}(x)</code>
approximates <code class="reqn">f_{\xi^{\star}}(x)</code>. Accurate approximation requires
appropriate <code>mean</code>, <code>sd</code> and <code>pol_coefficients</code> values
selection. In order to get sample estimates of these parameters please apply 
<code>hpaML</code> function.
</p>
<p>In order to perform calculation for marginal distribution of some 
<code class="reqn">\xi</code> components please provide omitted 
components via <code>omit_ind</code> argument.
For examples if ones assume <code class="reqn">m=5</code>-variate distribution
and wants to deal with <code class="reqn">1</code>-st, <code class="reqn">3</code>-rd, and <code class="reqn">5</code>-th components 
only i.e. <code class="reqn">(\xi_{1},\xi_{3},\xi_{5})</code> then set 
<code>omit_ind = c(FALSE, TRUE, FALSE, TRUE, FALSE)</code>
indicating that <code class="reqn">\xi_{2}</code> and <code class="reqn">\xi_{4}</code> should be 'omitted' from
<code class="reqn">\xi</code> since <code class="reqn">2</code>-nd and <code class="reqn">4</code>-th values of <code>omit_ind</code> are
<code>TRUE</code>.
Then <code>x</code> still should be <code class="reqn">5</code> column matrix but 
values in <code class="reqn">2</code>-nd and <code class="reqn">4</code>-th columns will not affect 
calculation results. Meanwhile note that marginal distribution of <code>t</code>
components of <code class="reqn">\xi</code> usually do not coincide with any marginal
distribution generated by <code>t</code>-variate density approximating function.
</p>
<p>In order to perform calculation for conditional distribution i.e. given 
fixed values for some <code class="reqn">\xi</code> components please provide these
components via <code>given_ind</code> argument.
For example if ones assume <code class="reqn">m=5</code>-variate distribution
and wants to deal with <code class="reqn">1</code>-st, <code class="reqn">3</code>-rd, and <code class="reqn">5</code>-th components 
given fixed values (suppose 8 and 10) for the other two components i.e. 
<code class="reqn">(\xi|\xi_{2} = 8, \xi_{4} = 10)</code> then set 
<code>given_ind = c(FALSE, TRUE, FALSE, TRUE, FALSE)</code> and
<code>x[2] = 8</code>, <code>x[4] = 10</code> where for simplicity it is assumed that
<code>x</code> is single row <code class="reqn">5</code> column matrix; it is possible to provide  
different conditional values for the same components simply setting different  
values to different <code>x</code> rows.
</p>
<p>Note that it is possible to combine <code>given_ind</code> and <code>omit_ind</code>
arguments. However it is wrong to set both <code>given_ind[i]</code> and 
<code>omit_ind[i]</code> to <code>TRUE</code>. Also at least one value should be
<code>FALSE</code> both for <code>given_ind</code> and <code>omit_ind</code>.
</p>
<p>In order to consider truncated distribution of <code class="reqn">\xi</code> i.e. 
<code class="reqn">\left(\xi|\overline{a}_{1}\leq\xi_{1}\leq\overline{b}_{1},
\cdots,\overline{a}_{m}\leq\xi_{m}\leq\overline{b}_{m}\right)</code>
please set lower (left) truncation points <code class="reqn">\overline{a}</code> and 
upper (right) truncation points <code class="reqn">\overline{b}</code> via <code>tr_left</code> 
and <code>tr_right</code> arguments correspondingly. Note that if lower truncation
points are negative infinite and upper truncation points are positive
infinite then <code>dtrhpa</code>, <code>itrhpa</code> and 
<code>etrhpa</code> are similar to <code>dhpa</code>,
<code>ihpa</code> and <code>ehpa</code> correspondingly.
</p>
<p>In order to calculate Jacobian of <code class="reqn">f_{\xi }(x;\mu, \sigma, \alpha)</code>
and <code class="reqn">\bar{F}_{\xi}(\underline{x},\bar{x};\mu, \sigma, \alpha)</code> w.r.t
all ore some particular parameters please apply <code>dhpaDiff</code>
and <code>ihpaDiff</code> functions correspondingly specifying
parameters of interest via <code>type</code> argument. If <code>x</code> or
<code>x_lower</code> and <code>x_upper</code> are single row matrices then gradients
will be calculated.
</p>
<p>For further information please see 'Examples' section. Note that examples
are given separately for each function.
</p>
<p>If <code>given_ind</code> and (or) <code>omit_ind</code> are numeric vectors
then they are insensitive to the order of elements. 
For example <code>given_ind = c(5, 2, 3)</code> is similar 
to <code>given_ind = c(2, 3, 5)</code>.
</p>
<p>Densities Hermite polynomial approximation approach has been
proposed by A. Gallant and D. W. Nychka in 1987. The main idea is to
approximate unknown distribution density with scaled Hermite polynomial.
For more information please refer to the literature listed below.
</p>


<h3>Value</h3>

<p>Functions <code>dhpa</code>, <code>phpa</code> and 
<code>dtrhpa</code> return vector of probabilities of length
<code>nrow(x)</code>. 
</p>
<p>Functions <code>ihpa</code> and 
<code>itrhpa</code> return vector of probabilities of length
<code>nrow(x_upper)</code>.
</p>
<p>If <code>x</code> argument has not been provided or is a single row
matrix then function 
<code>ehpa</code> returns moment value. Otherwise it returns vector of 
length <code>nrow(x)</code> containing moments values.
</p>
<p>If <code>tr_left</code> and <code>tr_right</code> arguments are single row matrices then
function <code>etrhpa</code> returns moment value.
Otherwise it returns vector of length
<code>max(nrow(tr_left), nrow(tr_right))</code> containing moments values.
</p>
<p>Functions <code>dhpaDiff</code> and <code>ihpaDiff</code> 
return Jacobin matrix. The number
of columns depends on <code>type</code> argument. The number of rows is
<code>nrow(x)</code> for <code>dhpaDiff</code> and 
<code>nrow(x_upper)</code> for
<code>ihpaDiff</code>
</p>
<p>If <code>mean</code> or <code>sd</code> are not specified they assume the default 
values of <code class="reqn">m</code>-dimensional vectors of 0 and 1, respectively. 
If <code>x_lower</code> is not specified then it is the matrix of the 
same size as <code>x_upper</code> containing negative infinity values only. If
<code>expectation_powers</code> is not specified then it is <code class="reqn">m</code>-dimensional
vector of 0 values.
</p>
<p>Please see 'Details' section for additional information.
</p>


<h3>References</h3>

<p>A. Gallant and D. W. Nychka (1987) &lt;doi:10.2307/1913241&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example demonstrating dhpa function application.
## Let's approximate some three random variables (i.e. X1, X2 and X3) 
## joint density function at points  x = (0,1, 0.2, 0.3) and 
## y = (0.5, 0.8, 0.6) with Hermite polynomial of (1, 2, 3) degrees which 
## polynomial coefficients equal 1 except coefficient related  to x1*(x^3) 
## polynomial element which equals 2. Also suppose that normal density 
## related mean vector equals (1.1, 1.2, 1.3) while standard deviations 
## vector is (2.1, 2.2, 2.3).

# Prepare initial values
x &lt;- matrix(c(0.1, 0.2, 0.3), nrow = 1)   # x point as a single row matrix
y &lt;- matrix(c(0.5, 0.8, 0.6), nrow = 1)   # y point as a single row matrix
x_y &lt;- rbind(x, y)                        # matrix which rows are x and y
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)
# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial 
# elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
   row.names = c("x1 power", "x2 power", "x3 power", "coefficients"),
   optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate density approximation 
   # at point x (note that x should be a matrix)
dhpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd)
   # at points x and y
dhpa(x = x_y,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd)

# Condition second component to be 0.5 i.e. X2 = 0.5.
# Substitute x and y second components with conditional value 0.5
x &lt;- matrix(c(0.1, 0.5, 0.3), nrow = 1) # or simply x[2] &lt;- 0.5
y &lt;- matrix(c(0.4, 0.5, 0.6), nrow = 1) # or simply y[2] &lt;- 0.5
x_y &lt;- rbind(x, y) 
# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on X2 = 0.5) density approximation 
   # at point x
dhpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind)
   # at points x and y
dhpa(x = x_y,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind)	
	
# Consider third component marginal distribution conditioned on the
# second component 0.5 value i.e. (X3 | X2 = 0.5).
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on x2 = 0.5) marginal (for x3) density approximation
   # at point x
dhpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind, 
     omit_ind = omit_ind)
   # at points x and y
dhpa(x = x_y,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind, 
     omit_ind = omit_ind)  
        
## Example demonstrating phpa function application.
## Let's approximate some three random variables (X1, X2, X3) 
## joint cumulative distribution function (cdf) at point (0,1, 0.2, 0.3)
## with Hermite polynomial of (1, 2, 3) degrees which polynomial 
## coefficients equal 1 except coefficient related to x1*(x^3) polynomial 
## element which equals 2. Also suppose that normal density related
## mean vector equals (1.1, 1.2, 1.3) while standard deviations
## vector is (2.1, 2.2, 2.3).

## Prepare initial values
x &lt;- matrix(c(0.1, 0.2, 0.3), nrow = 1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)

# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial
# elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
	           row.names = c("x1 power", "x2 power", 
	                         "x3 power", "coefficients"),
          	 optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate cdf approximation at point x
phpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd)
	
# Condition second component to be 0.5
# Substitute x second component with conditional value 0.5
x &lt;- matrix(c(0.1, 0.5, 0.3), nrow = 1) # or simply x[2] &lt;- 0.5

# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on X2 = 0.5) cdf approximation at point x
phpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind)
	
# Consider third component marginal distribution
# conditioned on the second component 0.5 value

# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) cdf 
# approximation at point x
phpa(x = x,
      pol_coefficients = pol_coefficients, 
      pol_degrees = pol_degrees,
      mean = mean, sd = sd,
      given_ind = given_ind, 
      omit_ind = omit_ind)

## Example demonstrating ihpa function application.
## Let's approximate some three random variables (X1, X2, X3) joint interval 
## distribution function (intdf) at lower and upper points (0,1, 0.2, 0.3) 
## and (0,4, 0.5, 0.6) correspondingly with Hermite polynomial of (1, 2, 3) 
## degrees which polynomial coefficients equal 1 except coefficient related 
## to x1*(x^3) polynomial element which equals 2. Also suppose that normal
## density related mean vector equals (1.1, 1.2, 1.3) while standard
## deviations vector is (2.1, 2.2, 2.3).

## Prepare initial values
x_lower &lt;- matrix(c(0.1, 0.2, 0.3), nrow=1)
x_upper &lt;- matrix(c(0.4, 0.5, 0.6), nrow=1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)

# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial 
# elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
	           row.names = c("x1 power", "x2 power", 
	                         "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate intdf approximation at points x_lower and x_upper
ihpa(x_lower = x_lower, x_upper = x_upper, 
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd)
	
# Condition second component to be 0.7
# Substitute x second component with conditional value 0.7
x_upper &lt;- matrix(c(0.4, 0.7, 0.6), nrow = 1)

# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on X2 = 0.5) intdf approximation 
# at points x_lower and x_upper
ihpa(x_lower = x_lower, x_upper = x_upper,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind)
	
# Consider third component marginal distribution
# conditioned on the second component 0.7 value
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) 
# intdf approximation at points x_lower and x_upper
ihpa(x_lower = x_lower, x_upper = x_upper,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = given_ind, omit_ind = omit_ind)
	
## Example demonstrating ehpa function application.
## Let's approximate some three random variables (X1, X2, X3) powered product 
## expectation for powers (3, 2, 1) with Hermite polynomial of (1, 2, 3) 
## degrees which polynomial coefficients equal 1 except coefficient 
## related to x1*(x^3) polynomial element which equals 2.
## Also suppose that normal density related mean vector equals 
## (1.1, 1.2, 1.3) while standard deviations vector is (2.1, 2.2, 2.3).

# Prepare initial values
expectation_powers = c(3,2,1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)

# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

#Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
              row.names = c("x1 power", "x2 power", 
                            "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate expected powered product approximation
ehpa(pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd, 
     expectation_powers = expectation_powers)
	
# Condition second component to be 0.5
# Substitute x second component with conditional value 0.5
x &lt;- matrix(c(NA, 0.5, NA), nrow = 1)
#Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on X2 = 0.5) expected powered product approximation
ehpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd, 
     expectation_powers = expectation_powers,
     given_ind = given_ind)
	
# Consider third component marginal distribution
# conditioned on the second component 0.5 value
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) expected powered 
# product approximation at points x_lower and x_upper
ehpa(x = x,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd, 
     expectation_powers = expectation_powers,
     given_ind = given_ind, 
     omit_ind = omit_ind)
	
## Example demonstrating etrhpa function application.
## Let's approximate some three truncated random variables (X1, X2, X3) 
## powered product expectation for powers (3, 2, 1) with Hermite polynomial 
## of (1,2,3) degrees which polynomial coefficients equal 1 except 
## coefficient related to x1*(x^3) polynomial element which equals 2. Also
## suppose that normal density related mean vector equals (1.1, 1.2, 1.3) 
## while standard deviations vector is (2.1, 2.2, 2.3). Suppose that lower  
## and upper truncation points are (-1.1,-1.2,-1.3) and (1.1,1.2,1.3) 
## correspondingly.

# Prepare initial values
expectation_powers = c(3,2,1)
tr_left = matrix(c(-1.1,-1.2,-1.3), nrow = 1)
tr_right = matrix(c(1.1,1.2,1.3), nrow = 1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)
# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
              row.names = c("x1 power", "x2 power", 
                            "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate expected powered product approximation for truncated distribution
etrhpa(pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd, 
       expectation_powers = expectation_powers,
       tr_left = tr_left, tr_right = tr_right)
       
## Example demonstrating dtrhpa function application.
## Let's approximate some three random variables (X1, X2, X3) joint density 
## function at point (0,1, 0.2, 0.3) with Hermite polynomial of (1,2,3)  
## degrees which polynomial coefficients equal 1 except coefficient related 
## to x1*(x^3) polynomial element which equals 2. Also suppose that normal 
## density related mean vector equals (1.1, 1.2, 1.3) while standard 
## deviations vector is (2.1, 2.2, 2.3). Suppose that lower and upper 
## truncation points are (-1.1,-1.2,-1.3) and (1.1,1.2,1.3) correspondingly.

# Prepare initial values
x &lt;- matrix(c(0.1, 0.2, 0.3), nrow=1)
tr_left = matrix(c(-1.1,-1.2,-1.3), nrow = 1)
tr_right = matrix(c(1.1,1.2,1.3), nrow = 1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)

# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
              row.names = c("x1 power", "x2 power", 
                            "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate density approximation at point x
dtrhpa(x = x,
       pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd,
       tr_left = tr_left, 
       tr_right = tr_right)
	
# Condition second component to be 0.5
# Substitute x second component with conditional value 0.5
x &lt;- matrix(c(0.1, 0.5, 0.3), nrow = 1)
# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)
# Calculate conditional (on x2 = 0.5) density approximation at point x
dtrhpa(x = x,
       pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd,
       given_ind = given_ind,
       tr_left = tr_left, tr_right = tr_right)
	
# Consider third component marginal distribution
# conditioned on the second component 0.5 value
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) 
# density approximation at point x
dtrhpa(x = x,
       pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd,
       given_ind = given_ind, omit_ind = omit_ind,
       tr_left = tr_left, tr_right = tr_right)
       
## Example demonstrating itrhpa function application.
## Let's approximate some three truncated random variables (X1, X2, X3) joint 
## interval distribution function at lower and upper points (0,1, 0.2, 0.3) 
## and (0,4, 0.5, 0.6) correspondingly with Hermite polynomial of (1 ,2, 3) 
## degrees which polynomial coefficients equal 1 except coefficient
## related to x1*(x^3) polynomial element which equals 2. Also suppose 
## that normal density related mean vector equals (1.1, 1.2, 1.3) while 
## standard deviations vector is (2.1, 2.2, 2.3). Suppose that lower and 
## upper truncation are (-1.1,-1.2,-1.3) and (1.1,1.2,1.3) correspondingly.

# Prepare initial values
x_lower &lt;- matrix(c(0.1, 0.2, 0.3), nrow=1)
x_upper &lt;- matrix(c(0.4, 0.5, 0.6), nrow=1)
tr_left = matrix(c(-1.1,-1.2,-1.3), nrow = 1)
tr_right = matrix(c(1.1,1.2,1.3), nrow = 1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)
# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2
# Visualize correspondence between polynomial 
# elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
              row.names = c("x1 power", "x2 power", 
                            "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate intdf approximation at points x_lower and x_upper
itrhpa(x_lower = x_lower, x_upper = x_upper, 
       pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd,
       tr_left = tr_left, tr_right = tr_right)
    
# Condition second component to be 0.7
# Substitute x second component with conditional value 0.7
x_upper &lt;- matrix(c(0.4, 0.7, 0.6), nrow = 1)
# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on X2 = 0.5) intdf 
# approximation at points x_lower and x_upper
itrhpa(x_lower = x_lower, x_upper = x_upper,
       pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd,
       given_ind = given_ind,
       tr_left = tr_left, tr_right = tr_right)
    
# Consider third component marginal distribution
# conditioned on the second component 0.7 value
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) intdf 
# approximation at points x_lower and x_upper
itrhpa(x_lower = x_lower, x_upper = x_upper,
       pol_coefficients = pol_coefficients, 
       pol_degrees = pol_degrees,
       mean = mean, sd = sd,
       given_ind = given_ind, omit_ind = omit_ind,
       tr_left = tr_left, tr_right = tr_right)
       
## Example demonstrating dhpaDiff function application.
## Let's approximate some three random variables (X1, X2, X3) joint density
## function at point (0,1, 0.2, 0.3) with Hermite polynomial of (1,2,3)
## degrees which polynomial coefficients equal 1 except coefficient related
## to x1*(x^3) polynomial element which equals 2. Also suppose that normal
## density related mean vector equals (1.1, 1.2, 1.3) while standard
## deviations vector is (2.1, 2.2, 2.3). In this example let's calculate
## density approximating function's gradient respect to various parameters

# Prepare initial values
x &lt;- matrix(c(0.1, 0.2, 0.3), nrow = 1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)
# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial
# elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
              row.names = c("x1 power", "x2 power", 
                            "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate density approximation gradient 
# respect to polynomial coefficients at point x
dhpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd)
	
# Condition second component to be 0.5
# Substitute x second component with conditional value 0.5
x &lt;- matrix(c(0.1, 0.5, 0.3), nrow = 1)
# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on x2 = 0.5) density approximation's 
# gradient respect to polynomial coefficients at point x
dhpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind)
	
# Consider third component marginal distribution
# conditioned on the second component 0.5 value
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) density 
# approximation's gradient respect to: 
  # polynomial coefficients
dhpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, 
         omit_ind = omit_ind)
  # mean
dhpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, 
         omit_ind = omit_ind,
         type = "mean")
  # sd
dhpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, 
         omit_ind = omit_ind,
         type = "sd")
 # x
dhpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, 
         omit_ind = omit_ind,
         type = "x")
         
## Example demonstrating ehpaDiff function application.
## Let's approximate some three random variables (X1, X2, X3) expectation
## of the form E((X1 ^ 3) * (x2 ^ 1) * (X3 ^ 2)) and calculate the gradient

# Distribution parameters
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)
pol_coefficients_n &lt;- prod(pol_degrees + 1)
pol_coefficients &lt;- rep(1, pol_coefficients_n)

# Set powers for expectation
expectation_powers &lt;- c(3, 1, 2)

# Calculate expectation approximation gradient 
# respect to all parameters
ehpaDiff(pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         expectation_powers = expectation_powers,
         type = "all")

# Let's calculate gradient of E(X1 ^ 3 | (X2 = 1, X3 = 2))
x &lt;- c(0, 1, 2)                  # x[1] may be arbitrary (not NA) values
expectation_powers &lt;- c(3, 0, 0) # expectation_powers[2:3] may be 
                                 # arbitrary (not NA) values
given_ind &lt;- c(2, 3)
ehpaDiff(x = x,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind,
         expectation_powers = expectation_powers,
         type = "all")
## Example demonstrating ihpaDiff function application.
## Let's approximate some three random variables (X1, X2, X3 ) joint interval 
## distribution function (intdf) at lower and upper points (0,1, 0.2, 0.3) 
## and (0,4, 0.5, 0.6) correspondingly with Hermite polynomial of (1, 2, 3) 
## degrees which polynomial coefficients equal 1 except coefficient 
## related to x1*(x^3) polynomial element which equals 2.
## Also suppose that normal density related mean vector equals 
## (1.1, 1.2, 1.3) while standard deviations vector is (2.1, 2.2, 2.3).
## In this example let's calculate interval distribution approximating 
## function gradient respect to polynomial coefficients.

# Prepare initial values
x_lower &lt;- matrix(c(0.1, 0.2, 0.3), nrow=1)
x_upper &lt;- matrix(c(0.4, 0.5, 0.6), nrow=1)
mean &lt;- c(1.1, 1.2, 1.3)
sd &lt;- c(2.1, 2.2, 2.3)
pol_degrees &lt;- c(1, 2, 3)

# Create polynomial powers and indexes correspondence matrix
pol_ind &lt;- polynomialIndex(pol_degrees)

# Set all polynomial coefficients to 1
pol_coefficients &lt;- rep(1, ncol(pol_ind))
pol_degrees_n &lt;- length(pol_degrees)

# Assign coefficient 2 to the polynomial element (x1 ^ 1)*(x2 ^ 0)*(x3 ^ 2)
pol_coefficients[apply(pol_ind, 2, function(x) all(x == c(1, 0, 2)))] &lt;- 2

# Visualize correspondence between polynomial 
# elements and their coefficients
as.data.frame(rbind(pol_ind, pol_coefficients),
              row.names = c("x1 power", "x2 power", 
                            "x3 power", "coefficients"),
              optional = TRUE)
printPolynomial(pol_degrees, pol_coefficients)

# Calculate intdf approximation gradient respect to 
# polynomial coefficients at points x_lower and x_upper
ihpaDiff(x_lower = x_lower, x_upper = x_upper, 
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd)
	
# Condition second component to be 0.7
# Substitute x second component with conditional value 0.7
x_upper &lt;- matrix(c(0.4, 0.7, 0.6), nrow = 1)

# Set TRUE to the second component indicating that it is conditioned
given_ind &lt;- c(FALSE, TRUE, FALSE)

# Calculate conditional (on X2 = 0.5) intdf approximation
# respect to polynomial coefficients at points x_lower and x_upper
ihpaDiff(x_lower = x_lower, x_upper = x_upper,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind)
	
# Consider third component marginal distribution
# conditioned on the second component 0.7 value
# Set TRUE to the first component indicating that it is omitted
omit_ind &lt;- c(TRUE, FALSE, FALSE)

# Calculate conditional (on X2 = 0.5) marginal (for X3) intdf approximation
# respect to:
  # polynomial coefficients
ihpaDiff(x_lower = x_lower, x_upper = x_upper,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, omit_ind = omit_ind)
  # mean
ihpaDiff(x_lower = x_lower, x_upper = x_upper,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, omit_ind = omit_ind,
         type = "mean")
  # sd
ihpaDiff(x_lower = x_lower, x_upper = x_upper,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, omit_ind = omit_ind,
         type = "sd")
  # x_lower
ihpaDiff(x_lower = x_lower, x_upper = x_upper,
         pol_coefficients = pol_coefficients, 
         pol_degrees = pol_degrees,
         mean = mean, sd = sd,
         given_ind = given_ind, omit_ind = omit_ind,
         type = "x_lower")
  # x_upper
ihpaDiff(x_lower = x_lower, x_upper = x_upper,
          pol_coefficients = pol_coefficients, 
          pol_degrees = pol_degrees,
          mean = mean, sd = sd,
          given_ind = given_ind, omit_ind = omit_ind,
          type = "x_upper")
          
## Examples demonstrating qhpa function application.

## Sub-example 1 - univariate distribution
## Consider random variable X

# Distribution parameters
mean &lt;- 1
sd &lt;- 2
pol_degrees &lt;- 2
pol_coefficients &lt;- c(1, 0.1, -0.01)

# The level of quantile
p &lt;- 0.7

# Calculate quantile of X
qhpa(p = p,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd)
     
## Sub-example 2 - marginal distribution
## Consider random vector (X1, X2) and quantile of X1

# Distribution parameters
mean &lt;- c(1, 1.2)
sd &lt;- c(2, 3)
pol_degrees &lt;- c(2, 2)
pol_coefficients &lt;- c(1, 0.1, -0.01, 0.2, 0.012, 
                      0.0013, 0.0042, 0.00025, 0)

# The level of quantile
p &lt;- 0.7

# Calculate quantile of X1
qhpa(p = p,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     omit_ind = 2)                          # set omitted variable index
     
## Sub-example 3 - marginal and conditional distribution
## Consider random vector (X1, X2, X3) and 

## quantiles of X1|X3 and X1|(X2,X3)
mean &lt;- c(1, 1.2, 0.9)
sd &lt;- c(2, 3, 2.5)
pol_degrees &lt;- c(1, 1, 1)
pol_coefficients &lt;- c(1, 0.1, -0.01, 0.2, 0.012, 
                      0.0013, 0.0042, 0.00025)

# The level of quantile
p &lt;- 0.7

# Calculate quantile of X1|X3 = 0.2
qhpa(p = p,
     x = matrix(c(NA, NA, 0.2), nrow = 1),  # set any values to
                                            # unconditioned and 
                                            # omitted components
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     omit_ind = 2,                          # set omitted variable index
     given_ind = 3)                         # set conditioned variable index
     
# Calculate quantile of X1|(X2 = 0.5, X3 = 0.2)
qhpa(p = p,
     x = matrix(c(NA, 0.5, 0.2), nrow = 1), # set any values to 
                                            # unconditioned and 
                                            # omitted components
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd,
     given_ind = c(2, 3))                   # set conditioned
                                            # variables indexes
        
## Examples demonstrating rhpa function application.

# Set seed for reproducibility
set.seed(123)

# Distribution parameters
mean &lt;- 1
sd &lt;- 2
pol_degrees &lt;- 2
pol_coefficients &lt;- c(1, 0.1, -0.01)

# Simulate two observations from this distribution
rhpa(n = 2,
     pol_coefficients = pol_coefficients, 
     pol_degrees = pol_degrees,
     mean = mean, sd = sd)
        
</code></pre>


</div>