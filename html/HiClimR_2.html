<div class="container">

<table style="width: 100%;"><tr>
<td>fastCor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast correlation for large matrices</h2>

<h3>Description</h3>

<p><code>fastCor</code> is a helper function that compute Pearson correlation matrix
for <code>HiClimR</code> and <code>validClimR</code> functions. It is similar
to <code>cor</code> function in R but uses a faster implementation on 64-bit
machines (an optimized <code>BLAS</code> library is highly recommended). <code>fastCor</code>
also uses a memory-efficient algorithm that allows for splitting the data matrix and
only compute the upper-triangular part of the correlation matrix. It can be used to
compute correlation matrix for the columns of any data matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fastCor(xt, nSplit = 1, upperTri = FALSE, optBLAS = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xt</code></td>
<td>
<p>an (<code>M</code> rows by <code>N</code> columns) matrix of 'double' values:
<code>N</code> objects (spatial points or stations) to be clustered by <code>M</code>
observations (temporal points or years). It is the transpose of the input
matrix <code>x</code> required for <code>HiClimR</code> and
<code>validClimR</code> functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSplit</code></td>
<td>
<p>integer number greater than or equal to one, to split the data matrix into
<code>nSplit</code> splits of the total number of columns <code>ncol(xt)</code>. If <code>nSplit = 1</code>,
the default method will be used to compute correlation matrix for the full data matrix
(no splits). If <code>nSplit &gt; 1</code>, the correlation matrix (or the upper-triangular part
if <code>upperTri = TRUE</code>) will be allocated and filled with the computed correlation
sub-matrix for each split. the first <code>n-1</code> splits have equal size while the last
split may include any remaining columns. This is used with <code>upperTri = TRUE</code> to
compute only the upper-triangular part of the correlation matrix. The maximum number of
splits <code>nSplitMax = floor(N / 2)</code> makes splits with 2 columns;
if <code>nSplit &gt; nSplitMax</code>, <code>nSplitMax</code> will be used. Very large number of splits
<code>nSplit</code> makes computation slower but it could handle big data or if the available
memory is not enough to allocate the correlation matrix, which helps in solving the
“Error: cannot allocate vector of size...” memory limitation problem. It is
recommended to start with a small number of splits. If the data is very large
compared to the physical memory, it is highly recommended to use a 64-Bit machine
with enough memory resources and/or use coarsening feature for gridded data by setting
<code>lonStep &gt; 1</code> and <code>latStep &gt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upperTri</code></td>
<td>
<p>logical to compute only the upper-triangular half of the correlation
matrix if <code>upperTri = TRUE</code> and <code>nSplit &gt; 1</code>., which includes all required info
since the correlation/dissimilarity matrix is symmetric. This almost halves memory use,
which can be very important for big data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optBLAS</code></td>
<td>
<p>logical to use optimized BLAS library if installed and <code>optBLAS = TRUE</code>
only on 64-bit machines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical to print processing information if <code>verbose = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>fastCor</code> function computes the correlation matrix by
calling the cross product function in the Basic Linear Algebra Subroutines
(BLAS) library used by R. A significant performance improvement can be
achieved when building R on 64-bit machines with an optimized BLAS library,
such as <em>ATLAS</em>, <em>OpenBLAS</em>, or the commercial <em>Intel MKL</em>.
For big data, the memory required to allocate the square matrix of correlations
may exceed the total amount of physical memory available resulting in
“Error: cannot allocate vector of size...”. <code>fastCor</code> allows
for splitting the data matrix into <code>nSplit</code> splits and only computes the
upper-triangular part of the correlation matrix with <code>upperTri = TRUE</code>.
This almost halves memory use, which can be very important for big data.
If <code>nSplit &gt; 1</code>, the correlation matrix (or the upper-triangular part if
<code>upperTri = TRUE</code>) will be allocated and filled with computed correlation
sub-matrix for each split. the first <code>n-1</code> splits have equal size while
the last split may include any remaining columns.
</p>


<h3>Value</h3>

<p>An (<code>N</code> rows by <code>N</code> columns) correlation matrix.
</p>


<h3>Author(s)</h3>

<p>Hamada S. Badr &lt;badr@jhu.edu&gt;, Benjamin F. Zaitchik &lt;zaitchik@jhu.edu&gt;,
and Amin K. Dezfuli &lt;amin.dezfuli@nasa.gov&gt;.
</p>


<h3>References</h3>

<p>Hamada S. Badr, Zaitchik, B. F. and Dezfuli, A. K. (2015):
A Tool for Hierarchical Climate Regionalization, <em>Earth Science Informatics</em>,
<b>8</b>(4), 949-958, doi: <a href="https://doi.org/10.1007/s12145-015-0221-7">10.1007/s12145-015-0221-7</a>.
</p>
<p>Hamada S. Badr, Zaitchik, B. F. and Dezfuli, A. K. (2014):
Hierarchical Climate Regionalization,
<em>Comprehensive R Archive Network (CRAN)</em>,
<a href="https://cran.r-project.org/package=HiClimR">https://cran.r-project.org/package=HiClimR</a>.
</p>


<h3>See Also</h3>

<p><code>HiClimR</code>, <code>HiClimR2nc</code>, <code>validClimR</code>,
<code>geogMask</code>, <code>coarseR</code>, <code>fastCor</code>,
<code>grid2D</code> and <code>minSigCor</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(HiClimR)

## Load test case data
x &lt;- TestCase$x

## Use fastCor function to compute the correlation matrix
t0 &lt;- proc.time() ; xcor &lt;- fastCor(t(x)) ; proc.time() - t0
## compare with cor function
t0 &lt;- proc.time() ; xcor0 &lt;- cor(t(x)) ; proc.time() - t0

## Not run: 

## Split the data into 10 splits and return upper-triangular half only
xcor10 &lt;- fastCor(t(x), nSplit = 10, upperTri = TRUE)


## End(Not run)
</code></pre>


</div>