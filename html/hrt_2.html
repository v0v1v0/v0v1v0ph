<div class="container">

<table style="width: 100%;"><tr>
<td>critical.value</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Critical Values for Heteroskedasticity Robust Testing</h2>

<h3>Description</h3>

<p>This function provides an implementation of 
Algorithm 3 in Pötscher and Preinerstorfer (2021), based on 
Algorithm 1 (if <code class="reqn">q = 1</code>) or Algorithm 2 
(if <code class="reqn">q &gt; 1</code>) in the same reference as the auxiliary algorithm <code class="reqn">\mathsf{A}</code>.
Which of the two algorithms is used is automatically 
determined as a function of <code class="reqn">q</code>, the number of rows of <code>R</code>.
</p>
<p>The user is referred to
Pötscher and Preinerstorfer (2021) for definitions, 
a detailed description of the problems solved
by the algorithms, and for a detailed description of the algorithms themselves.
</p>
<p>Most of the input parameters to <code>critical.value</code> are actually used
in the auxiliary Algorithm 1 or 2, respectively. 
Algorithm 1 is based on the function 
<code>davies</code> from the package <span class="pkg">CompQuadForm</span>. The parameters
<code>lim</code> and <code>acc</code> for <code>davies</code> can be supplemented by the user.
Algorithms 1 and 2 are implemented using the function <code>constrOptim</code> 
from <span class="pkg">stats</span> in Stages 1 and 2; this function
is used with default parameters, but control parameters can be supplied by the user.
</p>
<p>After determining a critical value for a given testing 
problem via the function <code>critical.value</code>, it is recommended that: (i) the user
applies the function <code>size</code> to compute the size of the test corresponding to the critical value obtained; 
and (ii) to check whether the size obtained does coincide with (or is close to) the targeted level of 
significance (that is <code>alpha</code>). If (ii) is not the case, this is an indication
of numerical issues, which potentially can be avoided by changing the input parameters
responsible for the accuracy of the computations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">critical.value(alpha, R, X, hcmethod, restr.cov, Mp, M1, M2, 
N0 = NULL, N1 = NULL, N2 = NULL, tol = 1e-08, 
control.1 = list("reltol" = 1e-02, "maxit" = dim(X)[1]*20),
control.2 = list("reltol" = 1e-03, "maxit" = dim(X)[1]*30),
cores = 1, lower = 0, eps.close = .0001, lim = 30000, acc = 0.001, 
size.tol = .001, maxit = 25, as.tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level. A real number in the interval <code class="reqn">(0, 1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>The restriction matrix. <code>critical.value</code> computes the (smallest) size-controlling critical value
for a test of the hypothesis <code class="reqn">R \beta = r</code>. <code>R</code> needs to be of
full row rank, and needs to have the same number of columns as <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The design matrix <code>X</code> needs to be of full column rank. 
The number of columns of <code>X</code> must be smaller than the number of rows of 
<code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hcmethod</code></td>
<td>
<p>Integer in [-1, 4]. Determines the method applied in the construction of the covariance estimator
used in the test statistic. The value -1 corresponds to unadjusted (i.e., classical) F statistic without df adjustment; the value 0 
corresponds to the HC0 estimator; ...; the value 4 corresponds to the HC4 estimator. Note that in case <code>restr.cov</code>
is TRUE the null-restricted versions of the covariance estimators are computed. Cf. Pötscher 
and Preinerstorfer (2021) and the references there for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restr.cov</code></td>
<td>
<p>TRUE or FALSE. Covariance matrix estimator based on null-restricted (TRUE) or unrestricted (FALSE) residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mp</code></td>
<td>
<p>This input is used in Algorithm 1 or 2, respectively. <code>Mp</code> is a positive integer 
(should be chosen large, e.g., 50000; but the feasibility depends on the dimension of <code>X</code>, etc). 
<code>Mp</code> determines <code class="reqn">M_0</code> in Algorithm 1 or 2 (i.e., <code class="reqn">\mathsf{A}</code>), respectively, that is, 
the number of initial values chosen in Stage 0 of that algorithm. The way initial values  
(i.e., the sets of variance covariance matrices <code class="reqn">\Sigma_j</code> in Stage 0 of the algorithm; 
the diagonal entries of each <code class="reqn">\Sigma_j</code> sum up to 1) are chosen is as follows:
</p>

<ol>
<li>
<p> If <code class="reqn">q = 1</code> and <code class="reqn">lower = 0</code>, one of the initial values <code class="reqn">\Sigma_j</code> is a matrix which maximizes the expectation of the quadratic form <code class="reqn">y \mapsto y'\Sigma^{1/2}
A_C \Sigma^{1/2}y</code> under an n-variate standard normal distribution. Here, <code class="reqn">A_C</code> is a matrix that is defined Pötscher and Preinerstorfer (2021).
If diagonal entries of this maximizer are 0, then they are replaced by the value of <code>eps.close</code> (and the other values are adjusted
so that the diagonal sums up to 1).
</p>
</li>
<li>
<p> One starting value <code class="reqn">\Sigma_j</code> is a diagonal matrix with constant diagonal entries.
</p>
</li>
<li>
<p> If <code>lower</code> is zero, then (i) <code class="reqn">\lceil Mp/4 \rceil - 1</code> covariance matrices <code class="reqn">\Sigma_j</code> are drawn by sampling their diagonals <code class="reqn">\tau_1^2, ..., \tau_n^2</code> from a uniform distribution 
on the unit simplex in <code class="reqn">R^n</code>; and (ii)  the remaining <code class="reqn">M_p - (\lceil Mp/4 \rceil - 1)</code> covariance matrices <code class="reqn">\Sigma_j</code> are each drawn by first sampling a vector <code class="reqn">(t_1, ..., t_n)'</code> from a uniform distribution 
on the unit simplex in <code class="reqn">R^n</code>, and by then obtaining the diagonal <code class="reqn">\tau_1^2, ..., \tau_n^2</code> of <code class="reqn">\Sigma_j</code> via <code class="reqn">(t_1^2, ..., t_n^2)/\sum_{i = 1}^n t_i^2</code>. If <code>lower</code> is nonzero,
then the initial values are drawn analogously, but from a uniform distribution on the subset of the unit simplex in <code class="reqn">R^n</code> corresponding to the restriction imposed
by the lower bound <code>lower</code>.
</p>
</li>
<li> <p><code class="reqn">n</code> starting values equal to covariance matrices with a single dominant diagonal entry and all other diagonal entries constant. The size of the dominant
diagonal entry is regulated via the input parameters <code>eps.close</code> and <code>lower</code>. In case <code>lower</code> is nonzero,
the size of the dominant diagonal entry equals <code class="reqn">1-(n-1)*(lower + eps.close)</code>. In case <code>lower</code> is zero, the size of the dominant diagonal
entry equals <code class="reqn">1-eps.close</code>.
</p>
</li>
</ol>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M1</code></td>
<td>
<p>This input is used in Algorithm 1 or 2, respectively. A positive integer 
(should be chosen large, e.g., 500; but the feasibility depends on the dimension of <code>X</code>, etc). 
Corresponds to <code class="reqn">M_1</code> in the description of 
Algorithm 1 and 2 in 
Pötscher and Preinerstorfer (2021). M1 must not exceed Mp.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M2</code></td>
<td>
<p>This input is used in Algorithm 1 or 2, respectively.
A positive integer. Corresponds to <code class="reqn">M_2</code> in the description of 
Algorithm 1 and 2 in 
Pötscher and Preinerstorfer (2021). M2 must not exceed M1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N0</code></td>
<td>
<p>This input is needed in Algorithm 2.
Only used in case <code class="reqn">q &gt; 1</code> (i.e., when Algorithm 2 is used). A positive integer. 
Corresponds to <code class="reqn">N_0</code> in the description of Algorithm 2 in 
Pötscher and Preinerstorfer (2021).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N1</code></td>
<td>
<p>This input is needed in Algorithm 2.
Only used in case <code class="reqn">q &gt; 1</code> (i.e., when Algorithm 2 is used). A positive integer. 
Corresponds to <code class="reqn">N_1</code> in the description of Algorithm 2 in 
Pötscher and Preinerstorfer (2021). N1 should be greater than 
N0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N2</code></td>
<td>
<p>This input is needed in Algorithm 2.
Only used in case <code class="reqn">q &gt; 1</code> (i.e., when Algorithm 2 is used). A positive integer. 
Corresponds to <code class="reqn">N_2</code> in the description of Algorithm 2 in 
Pötscher and Preinerstorfer (2021). N2 should be greater than
N1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>This input is used in Algorithm 1 or 2, respectively.
(Small) positive real number. Tolerance parameter used in checking invertibility of the 
covariance matrix in the test statistic. Default is 1e-08.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.1</code></td>
<td>
<p>This input is used in Algorithm 1 or 2, respectively.
Control parameters passed to the <code>constrOptim</code> function in 
Stage 1 of Algorithm 1 or 2, respectively. Default is <code>control.1 = list("reltol" = 1e-02, 
"maxit" = dim(X)[1]*20)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.2</code></td>
<td>
<p>This input is used in Algorithm 1 or 2, respectively.
Control parameters passed to the <code>constrOptim</code> function in 
Stage 2  of Algorithm 1 or 2, respectively. Default is <code>control.2 = list("reltol" = 1e-03, 
"maxit" = dim(X)[1]*30)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of CPU cores used in the (parallelized)
computations. Default is 1. Parallelized computation is enabled only
if the compiler used to build <span class="pkg">hrt</span> supports OpenMP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Number in <code class="reqn">[0, n^{-1})</code> (note that the diagonal of <code class="reqn">\Sigma</code> is normalized
to sum up to <code class="reqn">1</code>; if lower &gt; 0, then lower corresponds to what is denoted <code class="reqn">\tau_*</code> in 
Pötscher and Preinerstorfer (2021)).
<code>lower</code> specifies a lower bound on each diagonal entry of the (normalized) covariance matrix
in the covariance model for which the user wants to obtain a critical value that achieves size control.
If this lower bound is nonzero (which is the non-standard choice), then the size is only computed over all covariance matrices,
which are restricted such that their minimal diagonal entry is not smaller than <code>lower</code>. 
The relevant optimization problems in Algorithm 1 and 2 are then carried out only over this
restricted set of covariance matrices. The size will then in general depend on <code>lower</code>.
See the relevant discussions concerning restricted heteroskedastic covariance models in 
Pötscher and Preinerstorfer (2021). Default is <code class="reqn">0</code>, which is the 
recommended choice, unless there are strong reasons implying a specific lower bound on 
the variance in a given application.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.close</code></td>
<td>
<p>(Small) positive real number. This determines the size of the dominant entry in the choice of the
initial values as discussed in the description of the input <code>Mp</code> above.
Default is 1e-4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lim</code></td>
<td>
<p>This input is needed in Algorithm 1. Only used in case <code class="reqn">q = 1</code> (i.e., when Algorithm 1 is used).
Input parameter for the function <code>davies</code>. Default is 30000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc</code></td>
<td>
<p>This input is needed in Algorithm 1. Only used in case <code class="reqn">q = 1</code> (i.e., when Algorithm 1 is used).
Input parameter for the function <code>davies</code>. Default is 1e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size.tol</code></td>
<td>
<p>(Small) positive real number. <code class="reqn">\epsilon</code> in Algorithm 3. Default is 1e-3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations in the while loop of Algorithm 3. Default is 25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.tol</code></td>
<td>
<p>(Small) positive real number. Tolerance parameter used in checking rank 
conditions for verifying Assumptions 1, 2, and for checking a non-constancy condition
on the test statistic in case <code>hcmethod</code> is not <code class="reqn">-1</code> and <code>restr.cov</code> is
TRUE. <code>as.tol</code> is also used in the rank computations required for
computing lower bounds for size-controlling critical values. 
Furthermore, <code>as.tol</code> is used in checking the sufficient conditions
for existence of a size-controlling critical value provided in Pötscher 
and Preinerstorfer(2021). Default is 1e-08.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For details see the relevant sections in Pötscher 
and Preinerstorfer 
(2021), in particular the description of Algorithms 1 and 2 in the Appendix.
</p>


<h3>Value</h3>

<p>The output of <code>critical.value</code> is the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>critical.value</code></td>
<td>
<p>The critical value obtained by Algorithm 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approximate.size</code></td>
<td>
<p>The approximate size of the test based on the 
returned critical value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of iterations performed. If <code>iter</code> is smaller than <code>maxit</code>, 
then the algorithm determined because the required level of accuracy was achieved.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Pötscher, B. M. and Preinerstorfer, D. (2021). Valid Heteroskedasticity Robust Testing. &lt;arXiv:2104.12597&gt;
</p>


<h3>See Also</h3>

<p><code>davies</code>, <code>constrOptim</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#critical value for the classical (uncorrected) F-test in a location model
#with unrestricted heteroskedasticity

#it is known that (in this very special case) the conventional critical value 
#C &lt;- qt(.975, df = 9)^2
#is size-controlling (thus the resulting size should be 5% (approximately))

R &lt;- matrix(1, nrow = 1)
X &lt;- matrix(rep(1, length = 10), nrow = 10, ncol = 1)
hcmethod &lt;- -1
restr.cov &lt;- FALSE
Mp &lt;- 1000
M1 &lt;- 5
M2 &lt;- 1

#here, the parameters are chosen such that the run-time is low
#to guarantee a high accuracy level in the computation, 
#Mp, M1 and M2 should be chosen much higher

critical.value(alpha = .05, R, X, hcmethod, restr.cov, Mp, M1, M2)
</code></pre>


</div>