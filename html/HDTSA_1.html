<div class="container">

<table style="width: 100%;"><tr>
<td>Coint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identifying cointegration rank of given time series</h2>

<h3>Description</h3>

<p><code>Coint</code> seeks for a contemporaneous linear
transformation for a multivariate time series such that we can identifying 
cointegration rank from the transformed series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Coint(
  Y,
  lag.k = 5,
  type = c("acf", "pptest", "Chang", "all"),
  c0 = 0.3,
  m = 20,
  alpha = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p><code class="reqn">{\bf Y} = \{{\bf y}_1, \dots , {\bf y}_n \}'</code>, a data matrix
with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">n</code> is the sample size and
<code class="reqn">p</code> is the dimension of <code class="reqn">{\bf y}_t</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.k</code></td>
<td>
<p>Time lag <code class="reqn">k_0</code> used to calculate the nonnegative definte
matrix <code class="reqn">\widehat{{\bf W}}_y</code>: </p>
<p style="text-align: center;"><code class="reqn">\widehat{\mathbf{W}}_y\ =\
\sum_{k=0}^{k_0}\widehat{\mathbf{\Sigma}}_y(k)\widehat{\mathbf{\Sigma}}_y(k)'</code>
</p>

<p>where <code class="reqn">\widehat{\bf \Sigma}_y(k)</code> is the sample autocovariance of
<code class="reqn"> \widehat{{\bf y}_t}</code> at lag <code class="reqn">k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The method of identifying cointegration rank after segment 
procedure. Option is <code>'acf'</code>, <code>'all'</code>, <code>'chang'</code> or <code>'pptest'</code>
, the latter two methods use the unit-root test method to identify the 
cointegration rank, and the option <code>type = 'all'</code> means use all three
methods to identify the cointegration rank. Default is <code>type = 'acf'</code>.
See Sections 2.3 in Zhang, Robinson and Yao (2019) for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c0</code></td>
<td>
<p>The prescribed constant for identifying 
cointegration rank using <code>"acf"</code> method. Default is 0.3.[See (2.3) in
Zhang, Robinson and Yao (2019)].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The prescribed constant for identifying 
cointegration rank using <code>"acf"</code> method. Default is 20. [See (2.3) in
Zhang, Robinson and Yao (2019)].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The prescribed significance level for identifying 
cointegration rank using <code>"pptest","chang"</code> method. Default is 0.01.
[See (2.3) in Zhang, Robinson and Yao (2019)].</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class "coint" is a list containing the following
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The transformed series with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coint_rank</code></td>
<td>
<p>A <code class="reqn">1 \times 1</code> matrix representing the cointegration rank.
If <code>type = 'all'</code>, then return a <code class="reqn">1 \times 3</code> matrix representing
the cointegration rank of all three methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.k</code></td>
<td>
<p>a prescribed positive integer which means the time lags used
to calculate the statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string indicating which method was performed.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Zhang, R., Robinson, P. &amp; Yao, Q. (2019).  <em>Identifying 
Cointegration by Eigenanalysis</em>.  Journal of the American Statistical 
Association, Vol. 114, pp. 916â€“927
</p>


<h3>Examples</h3>

<pre><code class="language-R">p &lt;- 10
n &lt;- 1000
r &lt;- 3
d &lt;- 1
X &lt;- mat.or.vec(p, n)
X[1,] &lt;- arima.sim(n-d, model = list(order=c(0, d, 0)))
for(i in 2:3)X[i,] &lt;- rnorm(n)
for(i in 4:(r+1)) X[i, ] &lt;- arima.sim(model = list(ar = 0.5), n)
for(i in (r+2):p) X[i, ] &lt;- arima.sim(n = (n-d), model = list(order=c(1, d, 1), ar=0.6, ma=0.8))
M1 &lt;- matrix(c(1, 1, 0, 1/2, 0, 1, 0, 1, 0), ncol = 3, byrow = TRUE)
A &lt;- matrix(runif(p*p, -3, 3), ncol = p)
A[1:3,1:3] &lt;- M1
Y &lt;- t(A%*%X)
Coint(Y, type = "all")
</code></pre>


</div>