<div class="container">

<table style="width: 100%;"><tr>
<td>glm.npp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior of normalized power prior (NPP)</h2>

<h3>Description</h3>

<p>Sample from the posterior distribution of a GLM using the normalized power prior (NPP) by Duan et al.
(2006) <a href="doi:10.1002/env.752">doi:10.1002/env.752</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glm.npp(
  formula,
  family,
  data.list,
  a0.lognc,
  lognc,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  a0.lower = NULL,
  a0.upper = NULL,
  iter_warmup = 1000,
  iter_sampling = 1000,
  chains = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a two-sided formula giving the relationship between the response variable and covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>an object of class <code>family</code>. See <code>?stats::family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.list</code></td>
<td>
<p>a list of <code>data.frame</code>s. The first element in the list is the current data, and the rest
are the historical data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.lognc</code></td>
<td>
<p>a vector giving values of the power prior parameter for which the logarithm of the normalizing
constant has been evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lognc</code></td>
<td>
<p>an S by T matrix where S is the length of <code>a0.lognc</code>, T is the number of historical data sets, and
the j-th column, j = 1, ..., T, is a vector giving the logarithm of the normalizing constant (as
estimated by <code>glm.npp.lognc()</code> for <code>a0.lognc</code> using the j-th historical data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset.list</code></td>
<td>
<p>a list of vectors giving the offsets for each data. The length of <code>offset.list</code> is equal to
the length of <code>data.list</code>. The length of each element of <code>offset.list</code> is equal to the number
of rows in the corresponding element of <code>data.list</code>. Defaults to a list of vectors of 0s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.mean</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
<code>beta.mean</code> will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.sd</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. If a scalar is provided,
same as for <code>beta.mean</code>. Defaults to a vector of 10s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>disp.mean</code></td>
<td>
<p>location parameter for the half-normal prior on dispersion parameter. Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>disp.sd</code></td>
<td>
<p>scale parameter for the half-normal prior on dispersion parameter. Defaults to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.shape1</code></td>
<td>
<p>first shape parameter for the i.i.d. beta prior on <code class="reqn">a_0</code> vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.shape2</code></td>
<td>
<p>second shape parameter for the i.i.d. beta prior on <code class="reqn">a_0</code> vector. When <code>a0.shape1 == 1</code> and
<code>a0.shape2 == 1</code>, a uniform prior is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.lower</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
lower bounds for each element of the <code class="reqn">a_0</code> vector. If a scalar is provided, <code>a0.lower</code> will be a
vector of repeated elements of the given scalar. Defaults to a vector of 0s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a0.upper</code></td>
<td>
<p>a scalar or a vector whose dimension is equal to the number of historical data sets giving the
upper bounds for each element of the <code class="reqn">a_0</code> vector. If a scalar is provided, same as for <code>a0.lower</code>.
Defaults to a vector of 1s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_warmup</code></td>
<td>
<p>number of warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_warmup</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter_sampling</code></td>
<td>
<p>number of post-warmup iterations to run per chain. Defaults to 1000. See the argument <code>iter_sampling</code>
in <code>sample()</code> method in cmdstanr package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chains</code></td>
<td>
<p>number of Markov chains to run. Defaults to 4. See the argument <code>chains</code> in <code>sample()</code> method
in cmdstanr package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to <code>sample()</code> method in cmdstanr package (e.g., <code>seed</code>, <code>refresh</code>, <code>init</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Before using this function, users must estimate the logarithm of the normalizing constant across a
range of different values for the power prior parameter (<code class="reqn">a_0</code>), possibly smoothing techniques
over a find grid. The power prior parameters (<code class="reqn">a_0</code>'s) are treated as random with independent
beta priors. The initial priors on the regression coefficients are independent normal priors. The
current and historical data sets are assumed to have a common dispersion parameter with a
half-normal prior (if applicable). For normal linear models, the exact normalizing constants for
NPP can be computed. See the implementation in <code>lm.npp()</code>.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>draws_df</code> giving posterior samples, with an attribute called 'data' which includes
the list of variables specified in the data block of the Stan program.
</p>


<h3>References</h3>

<p>Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95â€“106.
</p>


<h3>See Also</h3>

<p><code>glm.npp.lognc()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  if(requireNamespace("parallel")){
    data(actg019)
    data(actg036)
    ## take subset for speed purposes
    actg019 = actg019[1:100, ]
    actg036 = actg036[1:50, ]

    library(parallel)
    ncores    = 2
    data.list = list(data = actg019, histdata = actg036)
    formula   = cd4 ~ treatment + age + race
    family    = poisson()
    a0        = seq(0, 1, length.out = 11)
    if (instantiate::stan_cmdstan_exists()) {
      ## call created function
      ## wrapper to obtain log normalizing constant in parallel package
      logncfun = function(a0, ...){
        hdbayes::glm.npp.lognc(
          formula = formula, family = family, a0 = a0, histdata = data.list[[2]],
          ...
        )
      }

      cl = makeCluster(ncores)
      clusterSetRNGStream(cl, 123)
      clusterExport(cl, varlist = c('formula', 'family', 'data.list'))
      a0.lognc = parLapply(
        cl = cl, X = a0, fun = logncfun, iter_warmup = 500,
        iter_sampling = 1000, chains = 1, refresh = 0
      )
      stopCluster(cl)
      a0.lognc = data.frame( do.call(rbind, a0.lognc) )

      ## sample from normalized power prior
      glm.npp(
        formula = formula,
        family = family,
        data.list = data.list,
        a0.lognc = a0.lognc$a0,
        lognc = matrix(a0.lognc$lognc, ncol = 1),
        chains = 1, iter_warmup = 500, iter_sampling = 1000,
        refresh = 0
      )
    }
  }

</code></pre>


</div>