<div class="container">

<table style="width: 100%;"><tr>
<td>cells_to_multipolygon</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get geometry for a set of H3 cells</h2>

<h3>Description</h3>

<p>This function returns geometry associated with a set of H3 cells, as a
single <code>sfc_MULTIPOLYGON</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cells_to_multipolygon(h3_addresses = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>h3_addresses</code></td>
<td>
<p>Character vector or list of 15-character cell indices
generated by H3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simple</code></td>
<td>
<p>Logical; whether to return an <code>sfc_MULTIPOLYGON</code> or an
<code>sf</code> object including the input cells.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>By default, object of type <code>sfc_MULTIPOLYGON</code> of length 1.
</p>


<h3>Note</h3>

<p>The geometry returned by this function will not be valid where the
addresses supplied overlap at the same resolution. The main use case for
this function appears to be visualising the outputs of
<code>polygon_to_cells</code> and
<code>compact</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Give me the outline of the cells around Brisbane Town Hall at
# resolution 10 (not run as slow-ish)
bth &lt;- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
bth_10 &lt;- point_to_h3(bth, res = 10)
bth_patch &lt;- get_disk(h3_address = bth_10, ring_size = 2)
bth_patch_sf &lt;- cells_to_multipolygon(bth_patch)

## End(Not run)
</code></pre>


</div>