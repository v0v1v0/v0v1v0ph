<div class="container">

<table style="width: 100%;"><tr>
<td>update.homTP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast <code>homTP</code>-update</h2>

<h3>Description</h3>

<p>Update existing <code>homTP</code> model with new observations
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'homTP'
update(
  object,
  Xnew,
  Znew = NULL,
  lower = NULL,
  upper = NULL,
  noiseControl = NULL,
  known = NULL,
  maxit = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>initial model of class <code>homTP</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xnew</code></td>
<td>
<p>matrix of new design locations; <code>ncol(Xnew)</code> must match the input dimension encoded in object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Znew</code></td>
<td>
<p>vector new observations at those new design locations, of length <code>nrow(X)</code>. <code>NA</code>s can be passed, see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper, noiseControl, known</code></td>
<td>
<p>optional bounds for MLE optimization, see <code>mleHomTP</code>.
If not provided, they are extracted from the existing model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations for the internal L-BFGS-B optimization method; see <code>optim</code> for more details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>no other argument for this method.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In case hyperparameters need not be updated, <code>maxit</code> can be set to <code>0</code>. 
In this case it is possible to pass <code>NA</code>s in <code>Znew</code>, then the model can still be used to provide updated variance predictions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
##------------------------------------------------------------
## Example : Sequential Homoskedastic TP moding 
##------------------------------------------------------------
set.seed(42)

## Spatially varying noise function
noisefun &lt;- function(x, coef = 1){
  return(coef * (0.05 + sqrt(abs(x)*20/(2*pi))/10))
}

df_noise &lt;- 3
nvar &lt;- 1
n &lt;- 10
X &lt;- matrix(seq(0, 2 * pi, length=n), ncol = 1)
mult &lt;- sample(1:50, n, replace = TRUE)
X &lt;- rep(X, mult)
Z &lt;- sin(X) + noisefun(X) * rt(length(X), df = df_noise)

testpts &lt;- matrix(seq(0, 2*pi, length = 10*n), ncol = 1)
mod &lt;- mod_init &lt;- mleHomTP(X = X, Z = Z, covtype = "Matern5_2",
                                lower = rep(0.1, nvar), upper = rep(50, nvar))
preds &lt;- predict(x = testpts, object = mod_init) 
plot(X, Z)
lines(testpts, preds$mean, col = "red")


nsteps &lt;- 10
for(i in 1:nsteps){
  newIds &lt;- sort(sample(1:(10*n), 5))
  
  newX &lt;- testpts[rep(newIds, times = sample(1:50, length(newIds), replace = TRUE)), drop = FALSE] 
  newZ &lt;- sin(newX) + noisefun(newX) * rt(length(newX), df = df_noise)
  points(newX, newZ, col = "blue", pch = 20)
  mod &lt;- update(object = mod, newX, newZ)
  X &lt;- c(X, newX)
  Z &lt;- c(Z, newZ)
  plot(X, Z)
  print(mod$nit_opt)
}
p_fin &lt;- predict(x = testpts, object = mod) 
lines(testpts, p_fin$mean, col = "blue")
lines(testpts, p_fin$mean + sqrt(p_fin$sd2) * qt(0.05, df = mod$nu + length(Z)),
      col = "blue", lty = 2)
lines(testpts, p_fin$mean + sqrt(p_fin$sd2) * qt(0.95, df = mod$nu + length(Z)),
      col = "blue", lty = 2)
lines(testpts, p_fin$mean + sqrt(p_fin$sd2 + p_fin$nugs) * qt(0.05, df = mod$nu + length(Z)),
      col = "blue", lty = 3)
lines(testpts, p_fin$mean + sqrt(p_fin$sd2 + p_fin$nugs) * qt(0.95, df = mod$nu + length(Z)),
      col = "blue", lty = 3)

mod_dir &lt;-  mleHomTP(X = X, Z = Z, covtype = "Matern5_2",
                          lower = rep(0.1, nvar), upper = rep(50, nvar))
p_dir &lt;- predict(x = testpts, object = mod_dir)
print(mod_dir$nit_opt)
lines(testpts, p_dir$mean, col = "green")
lines(testpts, p_dir$mean + sqrt(p_dir$sd2) * qt(0.05, df = mod_dir$nu + length(Z)),
      col = "green", lty = 2)
lines(testpts, p_dir$mean + sqrt(p_dir$sd2) * qt(0.95, df = mod_dir$nu + length(Z)),
      col = "green", lty = 2)
lines(testpts, p_dir$mean + sqrt(p_dir$sd2 + p_dir$nugs) * qt(0.05, df = mod_dir$nu + length(Z)),
      col = "green", lty = 3)
lines(testpts, p_dir$mean + sqrt(p_dir$sd2 + p_dir$nugs) * qt(0.95, df = mod_dir$nu + length(Z)),
      col = "green", lty = 3)

lines(testpts, sin(testpts), col = "red", lty = 2)

## Compare outputs
summary(mod_init)
summary(mod)
summary(mod_dir)



## End(Not run)
</code></pre>


</div>