<div class="container">

<table style="width: 100%;"><tr>
<td>plot.mcmcComposite</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot the result of a mcmcComposite object</h2>

<h3>Description</h3>

<p>Plot the results within a mcmcComposite object.<br>
If scale.prior is TRUE, another scale is shown at right.<br>
legend can take these values: <br>
FALSE, TRUE, topleft, topright, bottomleft, bottomright, c(x=, y=)
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'mcmcComposite'
plot(
  x,
  ...,
  chain = 1,
  parameters = 1,
  transform = NULL,
  scale.prior = TRUE,
  legend = "topright",
  ylab = "Posterior density",
  las = 1,
  show.prior = TRUE,
  col.prior = "red",
  lty.prior = 1,
  lwd.prior = 1,
  col.posterior = "white",
  lty.posterior = 1,
  lwd.posterior = 1,
  ylab.prior = "Prior density"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A mcmcComposite object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Graphical parameters to be sent to hist()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain</code></td>
<td>
<p>The chain to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>Name of parameters or "all"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>Function to be used to transform the variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.prior</code></td>
<td>
<p>If TRUE, the prior is scaled at the same size as posterior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>If FALSE, the legend is not shown; see description</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>y-label for posterior</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>las</code></td>
<td>
<p>las parameter (orientation of y-axis graduation)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.prior</code></td>
<td>
<p>whould the prior be shown?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.prior</code></td>
<td>
<p>Color for prior curve</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty.prior</code></td>
<td>
<p>Type of line for prior curve</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd.prior</code></td>
<td>
<p>Width of line for prior curve</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.posterior</code></td>
<td>
<p>Color for posterior histogram</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty.posterior</code></td>
<td>
<p>Type of line for posterior histogram</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd.posterior</code></td>
<td>
<p>Width of line for posterior histogram</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab.prior</code></td>
<td>
<p>y-label for prior</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>plot.mcmcComposite plots the result of a MCMC search
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Marc Girondot <a href="mailto:marc.girondot@gmail.com">marc.girondot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other mcmcComposite functions: 
<code>MHalgoGen()</code>,
<code>as.mcmc.mcmcComposite()</code>,
<code>as.parameters()</code>,
<code>as.quantiles()</code>,
<code>merge.mcmcComposite()</code>,
<code>plot.PriorsmcmcComposite()</code>,
<code>setPriors()</code>,
<code>summary.mcmcComposite()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(HelpersMG)
require(coda)
x &lt;- rnorm(30, 10, 2)
dnormx &lt;- function(data, x) {
 data &lt;- unlist(data)
 return(-sum(dnorm(data, mean=x['mean'], sd=x['sd'], log=TRUE)))
}
parameters_mcmc &lt;- data.frame(Density=c('dnorm', 'dlnorm'), 
Prior1=c(10, 0.5), Prior2=c(2, 0.5), SDProp=c(1, 1), 
Min=c(-3, 0), Max=c(100, 10), Init=c(10, 2), stringsAsFactors = FALSE, 
row.names=c('mean', 'sd'))
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=x, 
adaptive = TRUE,
likelihood=dnormx, n.chains=1, n.adapt=100, thin=1, trace=1)
plot(mcmc_run, xlim=c(0, 20))
plot(mcmc_run, xlim=c(0, 10), parameters="sd")
mcmcforcoda &lt;- as.mcmc(mcmc_run)
#' heidel.diag(mcmcforcoda)
raftery.diag(mcmcforcoda)
autocorr.diag(mcmcforcoda)
acf(mcmcforcoda[[1]][,"mean"], lag.max=20, bty="n", las=1)
acf(mcmcforcoda[[1]][,"sd"], lag.max=20, bty="n", las=1)
batchSE(mcmcforcoda, batchSize=100)
# The batch standard error procedure is usually thought to 
# be not as accurate as the time series methods used in summary
summary(mcmcforcoda)$statistics[,"Time-series SE"]
summary(mcmc_run)
as.parameters(mcmc_run)
lastp &lt;- as.parameters(mcmc_run, index="last")
parameters_mcmc[,"Init"] &lt;- lastp
# The n.adapt set to 1 is used to not record the first set of parameters
# then it is not duplicated (as it is also the last one for 
# the object mcmc_run)
mcmc_run2 &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, data=x, 
adaptive = TRUE,
likelihood=dnormx, n.chains=1, n.adapt=1, thin=1, trace=1)
mcmc_run3 &lt;- merge(mcmc_run, mcmc_run2)
####### no adaptation, n.adapt must be 0
parameters_mcmc[,"Init"] &lt;- c(mean(x), sd(x))
mcmc_run3 &lt;- MHalgoGen(n.iter=1000, parameters=parameters_mcmc, data=x, 
adaptive = TRUE,
likelihood=dnormx, n.chains=1, n.adapt=0, thin=1, trace=1)

#########################
## Example with transform
#########################

x.1&lt;-rnorm(6000, 2.4, 0.6)
x.2&lt;-rlnorm(10000, 1.3,0.1)

X&lt;-c(x.1, x.2)
hist(X,100,freq=FALSE, ylim=c(0,1.5))
Lnormlnorm &lt;- function(par, val) {
  p &lt;- invlogit(par["p"])
  return(-sum(log(p*dnorm(val, par["m1"], abs(par["s1"]), log = FALSE)+
                    (1-p)*dlnorm(val, par["m2"], abs(par["s2"]), log = FALSE))))
}
# Mean 1
m1=2.3; s1=0.5
# Mean 2
m2=1.3; s2=0.1
# proportion of category 1 - logit transform
p=0

par&lt;-c(m1=m1, s1=s1, m2=m2, s2=s2, p=p)

result2&lt;-optim(par, Lnormlnorm, method="BFGS", val=X, 
              hessian=FALSE, control=list(trace=1))
              
lines(seq(from=0, to=5, length=100), 
dnorm(seq(from=0, to=5, length=100), 
      result2$par["m1"], abs(result2$par["s1"])), col="red")

lines(seq(from=0, to=5, length=100), 
      dlnorm(seq(from=0, to=5, length=100), 
             result2$par["m2"], abs(result2$par["s2"])), col="green")

p &lt;- invlogit(result2$par["p"])

paste("Proportion of Gaussian data",  p)

lines(seq(from=0, to=5, length=100), 
      p*dnorm(seq(from=0, to=5, length=100), 
              result2$par["m1"], result2$par["s1"])+
        (1-p)*dlnorm(seq(from=0, to=5, length=100), 
                     result2$par["m2"], result2$par["s2"]), col="blue")               

parameters_mcmc &lt;- data.frame(Density=c('dunif', 'dunif', 'dunif', 'dunif', 'dunif'), 
                                        Prior1=c(0, 0.001, 0, 0.001, -3), 
                                        Prior2=c(10, 10, 10, 10, 3), 
                                        SDProp=c(1, 1, 1, 1, 1), 
                                        Min=c(0, 0.001, 0, 0.001, -3), 
                                        Max=c(10, 10, 10, 10, 3), 
                                        Init=result2$par, stringsAsFactors = FALSE, 
                                        row.names=c('m1', 's1', 'm2', 's2', 'p'))
                                        
mcmc_run &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, val=X, 
                      parameters_name = "par",
                      adaptive = TRUE,
                      likelihood=Lnormlnorm, n.chains=1, 
                      n.adapt=100, thin=1, trace=100)
plot(mcmc_run, parameters="m1", breaks=seq(from=0, to =10, by=0.1), 
     legend=c(x=6, y=0.10))
plot(mcmc_run, parameters="p", transform=invlogit, xlim=c(0,1), 
     breaks=seq(from=0, to=1, by=0.01), legend=c(x=0.6, y=0.10))
plot(mcmc_run, parameters="p", xlim=c(-3,3), 
     breaks=seq(from=-3, to =3, by=0.05), legend=c(x=1, y= 0.10))
     
parameters_mcmc &lt;- data.frame(Density=c('dunif', 'dunif', 'dunif', 'dunif', 'dnorm'), 
                                        Prior1=c(0, 0.001, 0, 0.001, 0.5), 
                                        Prior2=c(10, 10, 10, 10, 1), 
                                        SDProp=c(1, 1, 1, 1, 1), 
                                        Min=c(0, 0.001, 0, 0.001, -3), 
                                        Max=c(10, 10, 10, 10, 3), 
                                        Init=result2$par, stringsAsFactors = FALSE, 
                                        row.names=c('m1', 's1', 'm2', 's2', 'p'))
                                        
mcmc_run_pnorm &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, val=X, 
                      parameters_name = "par",
                      adaptive = TRUE,
                      likelihood=Lnormlnorm, n.chains=1, 
                      n.adapt=100, thin=1, trace=100)
plot(mcmc_run_pnorm, parameters="m1", breaks=seq(from=0, to =10, by=0.1), 
     legend=c(x=6, y=0.10))
plot(mcmc_run_pnorm, parameters="p", transform=invlogit, xlim=c(0,1), 
     breaks=seq(from=0, to=1, by=0.01), legend=c(x=0.6, y=0.10))
plot(x=mcmc_run_pnorm, parameters="p", xlim=c(-3,3), 
     breaks=seq(from=-3, to =3, by=0.05), legend=c(x=1, y= 0.10))
     
     
# Note that it is more logic to use beta distribution for p as a  
# proportion. However p value must be checked to be used in optim
# The use of logit transform can be a problem because it can stuck 
# the p value to 1 or 0 during fit.

Lnormlnorm &lt;- function(par, val) {
  p &lt;- par["p"]
  return(-sum(log(p*dnorm(val, par["m1"], abs(par["s1"]), log = FALSE)+
                    (1-p)*dlnorm(val, par["m2"], abs(par["s2"]), log = FALSE))))
}

# Example of beta distribution

# Mean is alpha/(alpha+beta)
# Variance is (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
alpha = 5
beta = 9
plot(x = seq(0.0001, 1, by = .0001), 
    y = dbeta(seq(0.0001, 1, by = .0001), alpha, beta),
    type = "l", ylab="Density", xlab="p", bty="n")
points(x=alpha/(alpha+beta), y=0, pch=4)
segments(x0=alpha/(alpha+beta)-sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1))), 
        x1=alpha/(alpha+beta)+sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1))),
        y0=0, y1=0)

# Use of optim with L-BFGS-B to limit p between 0 and 1 and s &gt; 0

# Mean 1
m1=2.3; s1=0.5
# Mean 2
m2=1.3; s2=0.1
# proportion of category 1 - logit transform
p=0.5

par &lt;- c(m1=m1, s1=s1, m2=m2, s2=s2, p=p)

result2 &lt;- optim(par, Lnormlnorm, method="L-BFGS-B", val=X, 
              lower = c(-Inf, 0, -Inf, 0, 0), 
              upper = c(Inf, Inf, Inf, Inf, 1),
              hessian=FALSE, control=list(trace=1))

parameters_mcmc &lt;- data.frame(Density=c('dunif', 'dunif', 'dunif', 'dunif', 'dbeta'), 
                                        Prior1=c(0, 0.001, 0, 0.001, 5), 
                                        Prior2=c(10, 10, 10, 10, 9), 
                                        SDProp=c(1, 1, 1, 1, 1), 
                                        Min=c(0, 0.001, 0, 0.001, 0), 
                                        Max=c(10, 10, 10, 10, 1), 
                                        Init=c('m1' = 2.4, 
                                               's1' = 0.6, 
                                               'm2' = 1.3, 
                                               's2' = 0.1, 
                                               'p' = 0.5), stringsAsFactors = FALSE, 
                                        row.names=c('m1', 's1', 'm2', 's2', 'p'))
                                        
mcmc_run_pbeta &lt;- MHalgoGen(n.iter=50000, parameters=parameters_mcmc, val=X, 
                      parameters_name = "par",
                      adaptive = TRUE,
                      likelihood=Lnormlnorm, n.chains=1, 
                      n.adapt=100, thin=1, trace=100)
plot(mcmc_run_pbeta, parameters="m1", breaks=seq(from=0, to =10, by=0.1), 
     legend=c(x=6, y=0.10))
plot(mcmc_run_pbeta, parameters="p", xlim=c(0,1), 
     breaks=seq(from=0, to=1, by=0.01), legend=c(x=0.6, y=2))



## End(Not run)
</code></pre>


</div>