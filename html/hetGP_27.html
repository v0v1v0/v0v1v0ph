<div class="container">

<table style="width: 100%;"><tr>
<td>hetGP-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Package hetGP</h2>

<h3>Description</h3>

<p>Performs Gaussian process regression with heteroskedastic noise following 
Binois, M., Gramacy, R., Ludkovski, M. (2016) &lt;arXiv:1611.05902&gt;. 
The input dependent noise is modeled as another Gaussian process. 
Replicated observations are encouraged as they yield computational savings. 
Sequential design procedures based on the integrated mean square prediction error and lookahead heuristics are provided,
and notably fast update functions when adding new observations.
</p>


<h3>Details</h3>

<p>Important functions: <br><code>mleHetGP</code> as the main function to build a model. <br><code>mleHomGP</code> the equivalent for homoskedastic modeling. <br><code>crit_IMSPE</code> for adding a new design based on the Integrated Mean Square Prediction Error. <br><code>IMSPE_optim</code> for augmenting a design, possibly based on a lookahead heuristic to bias the search toward replication. <br><code>crit_optim</code> is similar to <code>IMSPE_optim</code> but for the optimization or contour finding criterion available.
</p>


<h3>Note</h3>

<p>The authors are grateful for support from National Science Foundation grant DMS-1521702 and DMS-1521743.
</p>


<h3>Author(s)</h3>

<p>Mickael Binois, Robert B. Gramacy
</p>


<h3>References</h3>

<p>M. Binois, Robert B. Gramacy, M. Ludkovski (2018), Practical heteroskedastic Gaussian process modeling for large simulation experiments,
Journal of Computational and Graphical Statistics, 27(4), 808–821.<br> 
Preprint available on arXiv:1611.05902. <br><br></p>
<p>M. Binois, J. Huang, R. B. Gramacy, M. Ludkovski (2019), 
Replication or exploration? Sequential design for stochastic simulation experiments,
Technometrics, 61(1), 7–23.<br> 
Preprint available on arXiv:1710.03206. <br><br></p>
<p>M. Chung, M. Binois, R. B. Gramacy, DJ Moquin, AP Smith, AM Smith (2019). 
Parameter and Uncertainty Estimation for Dynamical Systems Using Surrogate Stochastic Processes.
SIAM Journal on Scientific Computing, 41(4), 2212–2238.<br>
Preprint available on arXiv:1802.00852.<br><br></p>
<p>M. Binois, R. B. Gramacy (2021).
hetGP: Heteroskedastic Gaussian Process Modeling and Sequential Design in R.
Journal of Statistical Software, 98(13), 1–44.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##------------------------------------------------------------
## Example 1: Heteroskedastic GP modeling on the motorcycle data
##------------------------------------------------------------
set.seed(32)

## motorcycle data
library(MASS)
X &lt;- matrix(mcycle$times, ncol = 1)
Z &lt;- mcycle$accel
nvar &lt;- 1
plot(X, Z, ylim = c(-160, 90), ylab = 'acceleration', xlab = "time")

## Model fitting
settings &lt;- list(return.hom = TRUE) # To keep homoskedastic model used for training
model &lt;- mleHetGP(X = X, Z = Z, lower = rep(0.1, nvar), upper = rep(50, nvar),
                  covtype = "Matern5_2", settings = settings)

## A quick view of the fit                  
summary(model)

## Create a prediction grid and obtain predictions
xgrid &lt;- matrix(seq(0, 60, length.out = 301), ncol = 1) 
predictions &lt;- predict(x = xgrid, object =  model)

## Display averaged observations
points(model$X0, model$Z0, pch = 20)

## Display mean predictive surface
lines(xgrid, predictions$mean, col = 'red', lwd = 2)
## Display 95% confidence intervals
lines(xgrid, qnorm(0.05, predictions$mean, sqrt(predictions$sd2)), col = 2, lty = 2)
lines(xgrid, qnorm(0.95, predictions$mean, sqrt(predictions$sd2)), col = 2, lty = 2)
## Display 95% prediction intervals
lines(xgrid, qnorm(0.05, predictions$mean, sqrt(predictions$sd2 + predictions$nugs)), 
  col = 3, lty = 2)
lines(xgrid, qnorm(0.95, predictions$mean, sqrt(predictions$sd2 + predictions$nugs)), 
  col = 3, lty = 2)
  
## Comparison with homoskedastic fit
predictions2 &lt;- predict(x = xgrid, object = model$modHom)
lines(xgrid, predictions2$mean, col = 4, lty = 2, lwd = 2)
lines(xgrid, qnorm(0.05, predictions2$mean, sqrt(predictions2$sd2)), col = 4, lty = 3)
lines(xgrid, qnorm(0.95, predictions2$mean, sqrt(predictions2$sd2)), col = 4, lty = 3)


##------------------------------------------------------------
## Example 2: Sequential design
##------------------------------------------------------------
## Not run: 
library(DiceDesign)

## Design configuration / Parameter settings
N_tot &lt;- 500 # total number of points
n_init &lt;- 10 # number of unique designs

## HetGP options
nvar &lt;- 1 # number of variables
lower &lt;- rep(0.001, nvar)
upper &lt;- rep(1, nvar)

### Problem definition

## Mean function
forrester &lt;- function(x){
 return(((x*6-2)^2)*sin((x*6-2)*2))
}

## Noise field via standard deviation
noiseFun &lt;- function(x, coef = 1.1, scale = 1){
 if(is.null(nrow(x)))
   x &lt;- matrix(x, nrow = 1)
 return(scale*(coef + sin(x * 2 * pi)))
}

### Test function defined in [0,1]
ftest &lt;- function(x){
 if(is.null(nrow(x)))
   x &lt;- matrix(x, ncol = 1)
 return(forrester(x) + rnorm(nrow(x), mean = 0, sd = noiseFun(x)))
}

## Predictive grid
ngrid &lt;- 51
xgrid &lt;- seq(0,1, length.out = ngrid)
Xgrid &lt;- matrix(xgrid, ncol = 1)

par(mar = c(3,3,2,3)+0.1)
plot(xgrid, forrester(xgrid), type = 'l', lwd = 1, col = "blue", lty = 3,
    xlab = '', ylab = '', ylim = c(-8,16))

set.seed(42)

# Initial design
X &lt;- maximinSA_LHS(lhsDesign(n_init, nvar, seed = 42)$design)$design
Z &lt;- apply(X, 1, ftest)

points(X, Z)

model &lt;- model_init &lt;- mleHetGP(X = X, Z = Z, lower = lower, upper = upper)

for(ii in 1:(N_tot - n_init)){
 ##Precalculations
 Wijs &lt;- Wij(mu1 = model$X0, theta = model$theta, type = model$covtype)
 
 ## Adapt the horizon based on the training rmspe/score
   current_horizon &lt;- horizon(model = model, Wijs = Wijs)

 if(current_horizon == -1){
   opt &lt;- IMSPE_optim(model = model, h = 0, Wijs = Wijs)
 }else{
   opt &lt;- IMSPE_optim(model = model, h = current_horizon, Wijs = Wijs)
 }
 
 Xnew &lt;- opt$par
 Znew &lt;- apply(Xnew, 1, ftest)
 X &lt;- rbind(X, Xnew)
 Z &lt;- c(Z, Znew)
 points(Xnew, Znew)
 
 ## Update of the model
 model &lt;- update(object = model, Xnew = Xnew, Znew = Znew, lower = lower, upper = upper)
 if(ii %% 25 == 0 || ii == (N_tot - n_init)){
   model_test &lt;- mleHetGP(X = list(X0 = model$X0, Z0 = model$Z0, mult = model$mult),
    Z = model$Z, lower = lower, upper = upper, maxit = 1000)
   model &lt;- compareGP(model, model_test)
 }
}
### Plot result
preds &lt;- predict(x = Xgrid, model)
lines(Xgrid, preds$mean, col = 'red', lwd = 2)
lines(Xgrid, qnorm(0.05, preds$mean, sqrt(preds$sd2)), col = 2, lty = 2)
lines(Xgrid, qnorm(0.95, preds$mean, sqrt(preds$sd2)), col = 2, lty = 2)
lines(Xgrid, qnorm(0.05, preds$mean, sqrt(preds$sd2 + preds$nugs)), col = 3, lty = 2)
lines(Xgrid, qnorm(0.95, preds$mean, sqrt(preds$sd2 + preds$nugs)), col = 3, lty = 2)
par(new = TRUE)
plot(NA,NA, xlim = c(0, 1), ylim = c(0,max(model$mult)), axes = FALSE, ylab = "", xlab = "")
segments(x0 = model$X, x1 = model$X, y0 = rep(0, nrow(model$X)), y1 = model$mult, col = 'grey')
axis(side = 4)
mtext(side = 4, line = 2, expression(a[i]), cex = 0.8)
mtext(side = 2, line = 2, expression(f(x)), cex = 0.8)
mtext(side = 1, line = 2, 'x', cex = 0.8)

## End(Not run)
</code></pre>


</div>