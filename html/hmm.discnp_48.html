<div class="container">

<table style="width: 100%;"><tr>
<td>misstify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Insert missing values.
</h2>

<h3>Description</h3>

<p>Insert missing values into data simulated by <code>rhmm</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">misstify(y, nafrac, fep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>A data set (vector or matrix with one or two columns, whose
entries consitute discrete data, or a list of such vectors
or matrices) or a list of such data sets (objects of class
<code>"multipleHmmDataSets"</code> such as might be generated by
<code>rhmm()</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nafrac</code></td>
<td>
<p>A numeric vector, some entries of which could
be ignored. (See below.) Those which do not get ignored
must be probabilities <em>strictly</em> less than 1.  (Having
<em>everything</em> missing makes no sense!)
</p>
<p>The vector <code>nafrac</code> will be replicated to have
an “appropriate” length.  If <code>y</code> is of class
<code>"multipleHmmDataSets"</code> then this length is <code>length(y)</code>
if the data are univariate and is <code>2*length(y)</code> if the data
are bivariate.  In the former case the entries of the replicated
vector from the fraction of missing values in the corresponding
data set.  In the latter case the odd numbered entries form the
fraction of missing values for the first variable and the even
numbered entries the fraction for the second variable.  If <code>y</code>
is not of class <code>"multipleHmmDataSets"</code> then this length is
either 1 (univariate case) or 2 (bivariate case).
</p>
<p>Note that replication discards entries that are not needed to
make up the required length, and such entries are thereby ignored.
E.g. <code>rep(c(0.2,0.7,1.6),length=2)</code> yields <code>[1] 0.2 0.7</code>,
i.e. the entry <code>1.6</code> is ignored.
</p>
<p>The fraction(s) of missing values in a given data set may be
determined by <code>nafracCalc()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fep</code></td>
<td>

<p>“First entry present”.  A list with one or two
entries, the first being a logical scalar (which might be named
<code>"present"</code>.  If there is a second entry it should be a scalar
probability (which might be named <code>"p2"</code>).  In an application
of interest, observation sequences always begin at an observed
event, i.e. at a time point at which the “emission” has at
least one non-missing value.  If <code>fep[[1]]</code> is <code>TRUE</code>
the <code>NA</code>s will be inserted in such a way that the resulting
data have this characteristic.  If <code>fep</code> is left <code>NULL</code>
then its first (possibly only) entry is set to <code>TRUE</code>.
</p>
<p>For <em>bivariate</em> data, <code>fep[[2]]</code> specifies the probabilty
that <em>both</em> values of the initial pair of observations are
non-missing.  In this case one of the entries of the initial pair
is chosen to be “potentially” missing, with probabilities
<code>nafrac/sum(nafrac)</code>.  This entry is left non-missing with
probability <code>fep[[2]]</code>.  (The other entry is always left
non-missing.)
</p>
<p>If the data are univariate or if <code>fep[[1]]</code> is <code>FALSE</code>,
then <code>fep[[2]]</code> is ignored.  If the data are bivariate
and <code>fep[[2]]</code> is not specified, it defaults to the (estimated)
conditional probability that both entries of the initial pair
of observations are present given that at least one is present,
under the assumption of independence of these events.  I.e. it is
set equal to <code>prod(1-nafrac)/(1-prod(1-nafrac))</code>.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with a structure similar to that of <code>y</code>, containing
the same data as <code>y</code> but with some of these data having been
replaced by missing values (<code>NA</code>).  In particular, if <code>y</code>
is of class <code>"multipleHmmDataSets"</code> then so is the returned
value.
</p>
<p>Note that <code>rhmm()</code> calls upon <code>misstify()</code> to effect
the replacement of a certain fraction of the simulated observations
by missing values.  If <code>rhmm()</code> is applied to a fitted model,
then by default, this “certain fraction” is determined, using
<code>nafracCalc()</code>, from the data set to which the model was fitted.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a><br></p>


<h3>See Also</h3>

<p><code>rhmm()</code> <code>nafracCalc()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">P &lt;- matrix(c(0.7,0.3,0.1,0.9),2,2,byrow=TRUE)
R &lt;- matrix(c(0.5,0,0.1,0.1,0.3,
              0.1,0.1,0,0.3,0.5),5,2)
set.seed(42)
lll   &lt;- sample(250:350,20,TRUE)
y1    &lt;- rhmm(ylengths=lll,nsim=1,tpm=P,Rho=R)
y1m   &lt;- misstify(y1,nafrac=0.5,fep=list(TRUE))
y2    &lt;- rhmm(ylengths=lll,nsim=5,tpm=P,Rho=R)
set.seed(127)
y2m   &lt;- misstify(y2,nafrac=0.5,fep=list(TRUE))
nafracCalc(y2m) # A list all of whose entries are close to 0.5.
set.seed(127)
y2ma  &lt;- lapply(y2,misstify,nafrac=0.5,fep=list(TRUE))
## Not run: 
    nafracCalc(y2ma) # Throws an error.

## End(Not run)
sapply(y2ma,nafracCalc) # Effectively the same as nafracCalc(y2m).
</code></pre>


</div>