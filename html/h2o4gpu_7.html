<div class="container">

<table style="width: 100%;"><tr>
<td>h2o4gpu.elastic_net_regressor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Elastic Net Regressor</h2>

<h3>Description</h3>

<p>Elastic Net Regressor
</p>


<h3>Usage</h3>

<pre><code class="language-R">h2o4gpu.elastic_net_regressor(alpha = 1, l1_ratio = 0.5,
  fit_intercept = TRUE, normalize = FALSE, precompute = FALSE,
  max_iter = 5000L, copy_X = TRUE, tol = 0.01, warm_start = FALSE,
  positive = FALSE, random_state = NULL, selection = "cyclic",
  n_gpus = -1L, lambda_stop_early = TRUE, glm_stop_early = TRUE,
  glm_stop_early_error_fraction = 1, verbose = FALSE, n_threads = NULL,
  gpu_id = 0L, lambda_min_ratio = 1e-07, n_lambdas = 100L, n_folds = 5L,
  tol_seek_factor = 0.1, store_full_path = 0L, lambda_max = NULL,
  lambdas = NULL, double_precision = NULL, order = NULL,
  backend = "h2o4gpu")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Constant that multiplies the penalty terms. Defaults to 1.0. See the notes for the exact mathematical meaning of this parameter.<code>alpha = 0</code> is equivalent to an ordinary least square, solved by the :class:<code>LinearRegressionSklearn</code> object. For numerical reasons, using <code>alpha = 0</code> with the <code>LassoSklearn</code> object is not advised. Given this, you should use the :class:<code>LinearRegressionSklearn</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l1_ratio</code></td>
<td>
<p>The ElasticNetSklearn mixing parameter, with <code>0 &lt;= l1_ratio &lt;= 1</code>. For <code>l1_ratio = 0</code> the penalty is an L2 penalty. <code>For l1_ratio = 1</code> it is an L1 penalty. For <code>0 &lt; l1_ratio &lt; 1</code>, the penalty is a combination of L1 and L2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit_intercept</code></td>
<td>
<p>Whether the intercept should be estimated or not. If <code>FALSE</code>, the data is assumed to be already centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>This parameter is ignored when <code>fit_intercept</code> is set to FALSE. If TRUE, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:<code>h2o4gpu.preprocessing.StandardScaler</code> before calling <code>fit</code> on an estimator with <code>normalize=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precompute</code></td>
<td>
<p>Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument. For sparse input this option is always <code>TRUE</code> to preserve sparsity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>The maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy_X</code></td>
<td>
<p>If <code>TRUE</code>, X will be copied; else, it may be overwritten.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance for the optimization: if the updates are smaller than <code>tol</code>, the optimization code checks the dual gap for optimality and continues until it is smaller than <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positive</code></td>
<td>
<p>When set to <code>TRUE</code>, forces the coefficients to be positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random_state</code></td>
<td>
<p>The seed of the pseudo random number generator that selects a random feature to update. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>. Used when <code>selection</code> == 'random'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection</code></td>
<td>
<p>If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_gpus</code></td>
<td>
<p>Number of gpu's to use in GLM solver.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_stop_early</code></td>
<td>
<p>Stop early when there is no more relative improvement on train or validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm_stop_early</code></td>
<td>
<p>Stop early when there is no more relative improvement in the primary and dual residuals for ADMM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm_stop_early_error_fraction</code></td>
<td>
<p>Relative tolerance for metric-based stopping criterion (stop if relative improvement is not at least this much).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Print verbose information to the console if set to &gt; 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>Number of threads to use in the gpu. Each thread is an independent model builder.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gpu_id</code></td>
<td>
<p>ID of the GPU on which the algorithm should run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_min_ratio</code></td>
<td>
<p>Minimum lambda ratio to maximum lambda, used in lambda search.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_lambdas</code></td>
<td>
<p>Number of lambdas to be used in a search.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_folds</code></td>
<td>
<p>Number of cross validation folds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_seek_factor</code></td>
<td>
<p>Factor of tolerance to seek once below null model accuracy. Default is 1E-1, so seeks tolerance of 1E-3 once below null model accuracy for tol=1E-2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_full_path</code></td>
<td>
<p>Whether to store full solution for all alphas and lambdas. If 1, then during predict will compute best and full predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_max</code></td>
<td>
<p>Maximum Lambda value to use. Default is NULL, and then internally compute standard maximum</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>overrides n_lambdas, lambda_max, and lambda_min_ratio.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double_precision</code></td>
<td>
<p>Internally set unless using _ptr methods. Value can either be 0 (float32) or 1(float64)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Order of data. Default is NULL, and internally determined (unless using _ptr methods) whether row 'r' or column 'c' major order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td>
</tr>
</table>
</div>