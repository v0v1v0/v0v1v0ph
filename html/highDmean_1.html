<div class="container">

<table style="width: 100%;"><tr>
<td>buildData</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two-sample datasets generator</h2>

<h3>Description</h3>

<p>This function generates simulated high dimensional two-sample data from user specified populations with given mean vectors, covariance structure, sample sizes, and dimension of each observation. It could generate the long-range dependent process proposed by Hall et al. (1998) in additional to some processes provided in arima.sim().
</p>


<h3>Usage</h3>

<pre><code class="language-R">buildData(
  n,
  m,
  p,
  muX,
  muY,
  dep,
  commoncov = TRUE,
  VarScaleY = 1,
  S = 1,
  innov = function(n, ...) stats::rnorm(n, 0, 1),
  heteroscedastic = FALSE,
  het.diag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations in the 1st sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>number of observations in the 2nd sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>the dimensionality of the each observation. The samples from both populations should have the same dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muX</code></td>
<td>
<p><code>p</code> by 1 vector of component means for the 1st population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>muY</code></td>
<td>
<p><code>p</code> by 1 vector of component means for the 2nd population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dep</code></td>
<td>
<p>dependence structure among the <code>p</code> components for both populations.
Possible options are:
</p>
<p>'IND' for independence;
</p>
<p>'SD' for strong dependency, AR(1) with parameter 0.9;
</p>
<p>'WD' for weak dependency, ARMA(2, 2) with AR parameters 0.4 and -0.1, and MA parameters 0.2 and 0.3;
</p>
<p>'LR' for long-range dependency with parameter 0.7.
</p>
<p>For more details about the configurations,  please refer to Zhang and Wang (2020).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>commoncov</code></td>
<td>
<p>a logical indicating whether the two populations have equal covariance matrices. If FALSE, the innovations used in generating data for the 2nd population will be scaled by the square root of the value specified in VarScaleY.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VarScaleY</code></td>
<td>
<p>constant by which innovations are scaled in generating observations for the 2nd sample when commoncov=FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>the number of data sets to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>innov</code></td>
<td>
<p>a function used to generate the innovations, such as <code>innov=function(n,...) rnorm(n,0,1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heteroscedastic</code></td>
<td>
<p>a logical indicating whether the components will be scaled by the entries in the diagonal matrix specified by <code>het.diag</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>het.diag</code></td>
<td>
<p>a <code>p</code> by <code>p</code> diagonal matrix, where the entries on the diagonal will be used to scale the component standard deviations. Only valid when <code>heteroscedastic = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of <code>S</code> lists, each consisting of an <code>n</code> by <code>p</code> matrix <code>X</code>, an <code>m</code> by <code>p</code> matrix <code>Y</code>, the sample sizes, <code>n</code> and <code>m</code>, for each population, and the dimensionality <code>p</code>.
</p>


<h3>References</h3>

<p>Hall, P., Jing, B.-Y., and Lahiri, S. N. (1998). On the sampling window method for long-range dependent data. Statistica Sinica, 8(4):1189-1204.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate 3 two-sample datasets of dimensionality 300
# with sample sizes 45 for one sample &amp; 60 for the other.
buildData(n = 45, m =60, p = 300,
          muX = rep(0,300), muY = rep(0,300),
          dep = 'IND', S = 3, innov = rnorm)
</code></pre>


</div>