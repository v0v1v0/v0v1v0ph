<div class="container">

<table style="width: 100%;"><tr>
<td>rankJumpTest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rank jump test</h2>

<h3>Description</h3>

<p>Calculate the rank jump test of Li et al. (2019).
The procedure tests for the rank of the jump matrix at simultaneous jump events in market returns as well as individual assets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rankJumpTest(
  marketPrice,
  stockPrices,
  alpha = c(5, 3),
  coarseFreq = 10,
  localWindow = 30,
  rank = 1,
  BoxCox = 1,
  quantiles = c(0.9, 0.95, 0.99),
  nBoot = 1000,
  dontTestAtBoundaries = TRUE,
  alignBy = "minutes",
  alignPeriod = 5,
  marketOpen = "09:30:00",
  marketClose = "16:00:00",
  tz = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>marketPrice</code></td>
<td>
<p>data.table or <code>xts</code>containing the market prices in levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stockPrices</code></td>
<td>
<p>list containing the individual stock prices in either data.table or <code>xts</code>format. The format should be the the same as <code>marketPrice</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level (in standard deviations) to use for the jump detections. Default is <code>c(5,3)</code> for 5 and 3 in the market and stocks respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coarseFreq</code></td>
<td>
<p>numeric denoting the coarse sampling frequency. Default is <code>10</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localWindow</code></td>
<td>
<p>numeric denoting the local window for the bootstrap algorithm. Default is <code>30</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>rank of the jump matrix under the null hypothesis. Default is <code>1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BoxCox</code></td>
<td>
<p>numeric of exponents for the Box-Cox transformation, default is <code>1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>numeric denoting which quantiles of the bootstrapped critical values to return and compare against. Default is <code>c(0.9, 0.95, 0.99)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBoot</code></td>
<td>
<p>numeric denoting how many replications to be used for the bootstrap algorithm. Default is <code>1000</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dontTestAtBoundaries</code></td>
<td>
<p>logical determining whether to exclude data across different days. Default is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alignBy</code></td>
<td>
<p>character, indicating the time scale in which <code>alignPeriod</code> is expressed. Possible values are: "secs", "seconds", "mins", "minutes","hours", and "ticks".
To aggregate based on a 5 minute frequency, set <code>alignPeriod</code> to 5 and <code>alignBy</code> to <code>"minutes"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alignPeriod</code></td>
<td>
<p>positive numeric, indicating the number of periods to aggregate over. E.g. to aggregate
based on a 5 minute frequency, set <code>alignPeriod</code> to 5 and <code>alignBy</code> to <code>"minutes"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marketOpen</code></td>
<td>
<p>the market opening time, by default: <code>marketOpen = "09:30:00"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marketClose</code></td>
<td>
<p>the market closing time, by default: <code>marketClose = "16:00:00"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tz</code></td>
<td>
<p>fallback time zone used in case we we are unable to identify the timezone of the data, by default: <code>tz = NULL</code>. 
We attempt to extract the timezone from the DT column (or index) of the data, which may fail. 
In case of failure we use <code>tz</code> if specified, and if it is not specified, we use <code>"UTC"</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let the jump times be defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    {\cal I}_{n} = \left\{ i:\left|\Delta_{i}^{n}Z\right|&gt;u_{n}\right\} 
</code>
</p>

<p>Then the estimated jump matrix is:
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\boldsymbol{J}_{n}}=\left[\Delta_{i,k}^{n}\boldsymbol{X}\right]_{i\in{\cal I}_{n}}
</code>
</p>
   
<p>Let <code class="reqn">\hat{\lambda}_{n,1}^{2}\geq\hat{\lambda}_{n,2}^{2}\geq\cdots\geq\hat{\lambda}_{n,d}^{2}</code> be the ordered eigenvalues of <code class="reqn">\hat{\boldsymbol{J}}_{n}\hat{\boldsymbol{J}}_{n}^{\prime}</code>, then test statistic is
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{S}_{n,t}=\sum_{j=r+1}^{d}\hat{\lambda}_{n,j}^{2}.
</code>
</p>

<p>The critical values are computed by applying a bootstrapping method 
</p>
<p>The singular value decomposition of the jump matrix <code class="reqn">\hat{\boldsymbol{J}}_{n}</code> is:
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\boldsymbol{J}}=\hat{\boldsymbol{U}}_{n}\hat{\boldsymbol{D}}_{n}\hat{\boldsymbol{V}}_{n}^{\prime}
</code>
</p>

<p>then <code class="reqn">\hat{\boldsymbol{U}}_{n}=\left[\hat{\boldsymbol{U}}_{1n}:\hat{\boldsymbol{U}}_{2n}\right]</code> and <code class="reqn">\hat{\boldsymbol{V}}_{n}=\left[\hat{\boldsymbol{V}}_{1n}:\hat{\boldsymbol{V}}_{2n}\right]</code>
</p>
<p><code class="reqn">\boldsymbol{\upsilon}_{n}=\left(\upsilon_{j,n}\right)_{1\leq j\leq d}</code> such that <code class="reqn">\upsilon_{j,n}\asymp\Delta_{n}^{\varpi} for \varpi\in\left(0,1/2\right)</code> which is used to trim jumps. The bootstrapping method is calculated by the following algorithm
</p>

<ul>
<li>
<p>Step 1.
</p>
<p>For each <code class="reqn">i\in{\cal I}_{n}</code>, draw <code class="reqn">\kappa_{i}^{\star}\sim\textrm{Uniform}\left[0,1\right]</code> and draw with equal probability,
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\xi}_{n,i-}^{\star} \textrm{from}\left\{ \min\left(\max\left(\Delta_{i-j}^{n}\boldsymbol{X},-\boldsymbol{\upsilon}_{n}\right),\boldsymbol{\upsilon}_{n}\right):1\leq j\leq k_{n}\right\}, 
</code>
</p>

<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\xi}_{n,i+}^{\star} \textrm{from}\left\{ \min\left(\max\left(\Delta_{i+j}^{n}\boldsymbol{X},-\boldsymbol{\upsilon}_{n}\right),\boldsymbol{\upsilon}_{n}\right):1\leq j\leq k_{n}\right\},
</code>
</p>

<p>and set <code class="reqn">\boldsymbol{\zeta}_{n,i}^{\star}=\sqrt{\kappa_{i}^{\star}}\boldsymbol{\xi}_{n,i-}^{\star}+\sqrt{k-\kappa_{i}^{\star}}\boldsymbol{\xi}_{n,i+}^{\star}</code> and <code class="reqn">\boldsymbol{\zeta}_{n}^{\star}=\left[\boldsymbol{\zeta}_{n,i}^{\star}\right]_{i\in{\cal I}_{n}}</code>
</p>

</li>
<li>
<p>Step 2.
</p>
<p>Repeat 1 for a large number of iterations. Set <code class="reqn">c\upsilon_{n,\alpha}</code> as as the <code class="reqn">1-\alpha</code> quantile of <code class="reqn">\left\Vert \hat{\boldsymbol{U}}_{2n}^{\prime}\boldsymbol{\xi}_{n}^{\star}\hat{\boldsymbol{V}}_{2n}\right\Vert ^{2}</code> in the simulated sample.

</p>
</li>
</ul>
<h3>Value</h3>

<p>A list containing <code>criticalValues</code> which are the bootstrapped critical values, <code>testStatistic</code> the test statistic of the jump test, <code>dimensions</code> which are the dimensions of the jump matrix
<code>marketJumpDetections</code> the jumps detected in the market prices, <code>stockJumpDetections</code> the co-jumps detected in the individual stock prices, and <code>jumpIndices</code> which are the indices of the detected jumps.
</p>


<h3>Author(s)</h3>

<p>Emil Sjoerup, based on Matlab code provided by Li et al. (2019)
</p>


<h3>References</h3>

<p>Li, j., Todorov, V., Tauchen, G., and Lin, H. (2019). Rank Tests at Jump Events. <em>Journal of Business &amp; Economic Statistics</em>, 37, 312-321.
</p>


</div>