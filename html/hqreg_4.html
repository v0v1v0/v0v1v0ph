<div class="container">

<table style="width: 100%;"><tr>
<td>cv.hqreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for hqreg</h2>

<h3>Description</h3>

<p>Perform k-fold cross validation for elastic-net penalized Huber loss regression 
and quantile regression over a sequence of lambda values and find an optimal lambda.</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.hqreg(X, y, ..., FUN = c("hqreg", "hqreg_raw"), ncores = 1, nfolds = 10, fold.id, 
         type.measure = c("deviance", "mse", "mae"), seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The input matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to <code>FUN</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>Model fitting function. The default is "hqreg" which preprocesses the data internally. 
The other option is "hqreg_raw" which uses the raw data as is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p><code>cv.hqreg</code> can be run in parallel across a
cluster using the <code>parallel</code> package. If <code>ncores &gt; 1</code>,a cluster is 
created to run <code>cv.hqreg</code> in parallel. The code is run sequentially if 
<code>ncores = 1</code> (the default). A message is printed if <code>ncores</code> is larger than the
total number of available cores, and all available cores will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>The number of cross-validation folds. Default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold.id</code></td>
<td>
<p>(Optional) a vector of values between 1 and nfold indicating 
which fold each observation belongs to. If supplied, nfolds can be missing. 
By default the observations are randomly assigned by <code>cv.hqreg</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.measure</code></td>
<td>
<p>The default is "deviance", which uses the chosen loss function of the model. 
Other options include "mse" for mean squared error and "mae" for mean absolute error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>(Optional) Seed for the random number generator in order to obtain reproducible results.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function randomly partitions the data in <code>nfolds</code>. It calls <code>hqreg</code> 
<code>nfolds</code>+1 times, the first to obtain the <code>lambda</code> sequence, and the remainder 
to fit with each of the folds left out once for validation. The cross-validation error is 
the average of validation errors for the <code>nfolds</code> fits.
</p>
<p>Note that <code>cv.hqreg</code> does not search for values of <code>alpha</code>, <code>gamma</code> or <code>tau</code>. 
Specific values should be supplied, otherwise the default ones for <code>hqreg</code> are used. 
If users would like to cross-validate <code>alpha</code>, <code>gamma</code> or <code>tau</code> as well, 
they should call <code>cv.hqreg</code> for each combination of these parameters and use the same 
"seed" in these calls so that the partitioning remains the same.
</p>


<h3>Value</h3>

<p>The function returns an object of S3 class <code>"cv.hqreg"</code>, which is a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cve</code></td>
<td>
<p>The error for each value of <code>lambda</code>, averaged across the cross-validation folds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvse</code></td>
<td>
<p>The estimated standard error associated with each value of <code>cve</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.measure</code></td>
<td>
<p>Same as above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The values of <code>lambda</code> used in the cross-validation fits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>The fitted <code>hqreg</code> object for the whole data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>The largest <code>lambda</code> such that the error is within 1 standard 
error of the minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>The value of <code>lambda</code> with the minimum cross-validation error.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Congrui Yi &lt;eric.ycr@gmail.com&gt;</p>


<h3>References</h3>

<p>Yi, C. and Huang, J. (2017) 
<em>Semismooth Newton Coordinate Descent Algorithm for 
Elastic-Net Penalized Huber Loss Regression and Quantile Regression</em>,
doi: <a href="https://doi.org/10.1080/10618600.2016.1256816">10.1080/10618600.2016.1256816</a> <br><em>Journal of Computational and Graphical Statistics</em> <br></p>


<h3>See Also</h3>

<p><code>hqreg</code>, <code>plot.cv.hqreg</code></p>


<h3>Examples</h3>

<pre><code class="language-R">X = matrix(rnorm(1000*100), 1000, 100)
beta = rnorm(10)
eps = 4*rnorm(1000)
y = drop(X[,1:10] %*% beta + eps)
cv = cv.hqreg(X, y, seed = 123)
plot(cv)

cv_raw = cv.hqreg(X, y, FUN = "hqreg_raw", seed = 321)
predict(cv_raw, X[1:5,])

# parallel cross validation
## Not run: 
cv_parallel = cv.hqreg(X, y, ncores = 5)
plot(cv_parallel)

## End(Not run)
</code></pre>


</div>