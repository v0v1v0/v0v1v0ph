<div class="container">

<table style="width: 100%;"><tr>
<td>sim_ev</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expected values from state probabilities</h2>

<h3>Description</h3>

<p>Simulate expected values as a function of simulated state occupancy
probabilities, with simulation of costs and quality-adjusted life-years
(QALYs) as particular use cases.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'stateprobs'
sim_ev(
  object,
  models = NULL,
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  value_name = "value",
  outcome_name = "outcome",
  ...
)

sim_qalys(
  object,
  model,
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right"),
  lys = TRUE
)

sim_costs(
  object,
  models,
  dr = 0.03,
  integrate_method = c("trapz", "riemann_left", "riemann_right")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>stateprobs</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dr</code></td>
<td>
<p>Discount rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integrate_method</code></td>
<td>
<p>Method used to integrate state values when computing
costs or QALYs. Options are <code>trapz</code> (the default) for the trapezoid rule,
<code>riemann_left</code> left for a left Riemann sum, and
<code>riemann_right</code> right for a right Riemann sum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value_name</code></td>
<td>
<p>Name of the column containing values of the outcome. Default
is <code>"value"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome_name</code></td>
<td>
<p>Name of the column indicating the outcome corresponding
to each model. Only used if <code>models</code> is a list. Default is <code>"outcome"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently unused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, models</code></td>
<td>
<p>An object or list of objects of class <code>StateVals</code> used to
model state values. When using <code>sim_qalys()</code>, this should be
a single model for utility. With <code>sim_costs()</code>, a list of models should be
used with one model for each cost category. Finally, with <code>sim_ev()</code>,
this may either be a single model or a list of models. May also be <code>NULL</code>,
in which case length of stay is computed based on the state probabilities
contained in <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lys</code></td>
<td>
<p>If <code>TRUE</code>, then life-years are simulated in addition to
QALYs.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Expected values in cohort models (i.e.,  those implemented with
the <code>CohortDtstm</code> and <code>Psm</code> classes) are mean outcomes for patients comprising
the cohort. The method used to simulate expected values depends on the
<code style="white-space: pre;">⁠$method⁠</code> field in the <code>StateVals</code> object(s) stored in <code>model(s)</code>. If
<code style="white-space: pre;">⁠$method = "starting"⁠</code>, then state values represent a one-time value that
occurs at time 0.
</p>
<p>The more common use case is <code style="white-space: pre;">⁠$method = "wlos"⁠</code>, or a "weighted length of stay".
That is, expected values for each health state can be thought of as state values
weighted by the time a patient spends in each state (and discounted by a
discount factor that depends on the discount rate <code>dr</code>). The
precise computation proceeds in four steps. In the first step, the probability
of being in each health state at each discrete time point is simulated
(this is the output contained in the <code>stateprobs</code> object). Second, a
<code>StateVals</code> model is used to predict state values at each time point.
Third an expected value at each time point is computed by multiplying the
state probability, the state value, and the discount factor. Fourth, the
expected values at each time point are summed across all time points.
</p>
<p>The summation in the fourth step can be thought of as a discrete approximation
of an integral. In particular, the limits of integration can be partitioned
into time intervals, with each interval containing a start and an end.
The <code>integrate_method</code> argument determines the approach used
for this approximation:
</p>

<ol>
<li>
<p> A left Riemann sum (<code>integrate_method = "riemann_left"</code>) uses expected values
at the start of each time interval.
</p>
</li>
<li>
<p> A right Riemann sum (<code>integrate_method = "riemann_right"</code>) uses expected values
at the end of each time interval.
</p>
</li>
<li>
<p> The trapezoid rule (<code>integrate_method = "trapz"</code>) averages expected values
at the start and end of each time interval. (This will generally be the
most accurate and is recommended.)
</p>
</li>
</ol>
<p>Mathematical details are provided in the reference within the "References"
section below.
</p>


<h3>Value</h3>

<p><code>sim_ev()</code> returns a <code>data.table</code> with the following columns:
</p>

<dl>
<dt>sample</dt>
<dd>
<p>A random sample from the PSA.</p>
</dd>
<dt>strategy_id</dt>
<dd>
<p>The treatment strategy ID.</p>
</dd>
<dt>patient_id</dt>
<dd>
<p>The patient ID.</p>
</dd>
<dt>grp_id</dt>
<dd>
<p>The subgroup ID.</p>
</dd>
<dt>state_id</dt>
<dd>
<p>The health state ID.</p>
</dd>
<dt>dr</dt>
<dd>
<p>The rate used to discount costs.</p>
</dd>
<dt>outcome</dt>
<dd>
<p>The outcome corresponding to each model in <code>models</code>.
Only included if <code>models</code> is a list.</p>
</dd>
<dt>value</dt>
<dd>
<p>The expected value.</p>
</dd>
</dl>
<p>The names of the <code>outcome</code> and <code>value</code> columns may be changed with the
<code>value_name</code> and <code>outcome_name</code> arguments. <code>sim_costs()</code> and <code>sim_qalys()</code>
return similar objects, that are of class <code>costs</code> and <code>qalys</code>, respectively.
</p>


<h3>Note</h3>

<p>The ID variables in the state value models in <code>models</code> must be
consistent with the ID variables contained in <code>object</code>. In particular,
the <code>models</code> should predict state values for each non-absorbing health state
in <code>object</code>; that is, the number of health states modeled with the
<code>models</code> should equal the number of health states in <code>object</code> less the number
of absorbing states.
</p>
<p>The absorbing states are saved as an attribute named <code>absorbing</code> to
<code>stateprobs</code> objects. When simulating state probabilities with a
<code>CohortDtstmTrans</code> object, the absorbing state is determined by the
<code>absorbing</code> field in the class; in a <code>Psm</code> (or with
<code>sim_stateprobs.survival()</code>), the absorbing state is always equal to the
final health state.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/2102.09437">Incerti and Jansen (2021)</a>.
See Section 2.1 for mathematical details.
</p>


<h3>See Also</h3>

<p>State probabilities can be simulated using the
<code style="white-space: pre;">⁠$sim_stateprobs()⁠</code> methods from either the <code>CohortDtstmTrans</code>
(or <code>CohortDtstm</code>) or <code>Psm</code> classes. State probabilities can also be
computed directly from survival curves with the generic method
<code>sim_stateprobs.survival()</code>.
</p>
<p>Costs and QALYs are typically computed within the <code>R6</code> model classes
using the <code style="white-space: pre;">⁠$sim_costs()⁠</code> and <code style="white-space: pre;">⁠$sim_qalys()⁠</code> methods. For instance, see the
documentation and examples for the <code>CohortDtstm</code> and <code>Psm</code> classes.
The <code>sim_qalys()</code> and <code>sim_costs()</code> functions are exported to give users
additional flexibility when creating their own modeling pipelines.
<code>sim_ev()</code> may be useful for computing outcomes other than costs or QALYs.
</p>
<p><code>costs</code> and <code>qalys</code> objects can be passed to <code>summarize_ce()</code> to
create a cost-effectiveness object for performing a cost-effectiveness analysis
with <code>cea()</code>. Although note that typically the <code style="white-space: pre;">⁠$summarize()⁠</code> method
belonging to the <code>CohortDtstm</code> or <code>Psm</code> classes would be used instead.
</p>
<p>Use the <code>IndivCtstm</code> class to simulate costs and QALYs with an individual
continuous-time state transition model.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># We need (i) a state probability object and (ii) a model for state values
## We should start by setting up our decision problem
hesim_dat &lt;-  hesim_data(strategies = data.frame(strategy_id = 1:2),
                         patients = data.frame(patient_id = 1:3),
                         states = data.frame(state_id = 1))
input_data &lt;- expand(hesim_dat, by = c("strategies", "patients"))

## (i) Simulate a state probability object
tpmat_id &lt;- tpmatrix_id(input_data, n_samples = 2) 
p_12 &lt;- ifelse(tpmat_id$strategy_id == 1, .15, .1)
tpmat &lt;- tpmatrix(
  C, p_12,
  0, 1
)
transmod &lt;- CohortDtstmTrans$new(params = tparams_transprobs(tpmat, tpmat_id))
stprobs &lt;- transmod$sim_stateprobs(n_cycles = 3)

## Construct model for state values
outcome_tbl &lt;- stateval_tbl(
  data.frame(
    state_id = 1,
    est = 5000
  ),
  dist = "fixed"
)
outmod &lt;- create_StateVals(outcome_tbl, n = 2, hesim_data = hesim_dat)

# We can then simulate expected values
## The generic expected values function
sim_ev(stprobs, models = outmod)

## We can also pass a list of models
sim_ev(stprobs, models = list(`Outcome 1` = outmod))

## Suppose the outcome were a cost category. Then we might
## prefer the following:
sim_costs(stprobs, models = list(drug = outmod))

## Length of stay is computed if there is no state value model
sim_ev(stprobs)
</code></pre>


</div>