<div class="container">

<table style="width: 100%;"><tr>
<td>req_retry</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Control when a request will retry, and how long it will wait between tries</h2>

<h3>Description</h3>

<p><code>req_retry()</code> alters <code>req_perform()</code> so that it will automatically retry
in the case of failure. To activate it, you must specify either the total
number of requests to make with <code>max_tries</code> or the total amount of time
to spend with <code>max_seconds</code>. Then <code>req_perform()</code> will retry if the error is
"transient", i.e. it's an HTTP error that can be resolved by waiting. By
default, 429 and 503 statuses are treated as transient, but if the API you
are wrapping has other transient status codes (or conveys transient-ness
with some other property of the response), you can override the default
with <code>is_transient</code>.
</p>
<p>Additionally, if you set <code>retry_on_failure = TRUE</code>, the request will retry
if either the HTTP request or HTTP response doesn't complete successfully
leading to an error from curl, the lower-level library that httr2 uses to
perform HTTP request. This occurs, for example, if your wifi is down.
</p>
<p>It's a bad idea to immediately retry a request, so <code>req_perform()</code> will
wait a little before trying again:
</p>

<ul>
<li>
<p> If the response contains the <code>Retry-After</code> header, httr2 will wait the
amount of time it specifies. If the API you are wrapping conveys this
information with a different header (or other property of the response)
you can override the default behaviour with <code>retry_after</code>.
</p>
</li>
<li>
<p> Otherwise, httr2 will use "truncated exponential backoff with full
jitter", i.e. it will wait a random amount of time between one second and
<code>2 ^ tries</code> seconds, capped to at most 60 seconds. In other words, it
waits <code>runif(1, 1, 2)</code> seconds after the first failure, <code>runif(1, 1, 4)</code>
after the second, <code>runif(1, 1, 8)</code> after the third, and so on. If you'd
prefer a different strategy, you can override the default with <code>backoff</code>.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">req_retry(
  req,
  max_tries = NULL,
  max_seconds = NULL,
  retry_on_failure = FALSE,
  is_transient = NULL,
  backoff = NULL,
  after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>req</code></td>
<td>
<p>A httr2 request object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_tries, max_seconds</code></td>
<td>
<p>Cap the maximum number of attempts with
<code>max_tries</code> or the total elapsed time from the first request with
<code>max_seconds</code>. If neither option is supplied (the default), <code>req_perform()</code>
will not retry.
</p>
<p><code>max_tries</code> is the total number of attempts make, so this should always
be greater than one.'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retry_on_failure</code></td>
<td>
<p>Treat low-level failures as if they are
transient errors, and can be retried.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is_transient</code></td>
<td>
<p>A predicate function that takes a single argument
(the response) and returns <code>TRUE</code> or <code>FALSE</code> specifying whether or not
the response represents a transient error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backoff</code></td>
<td>
<p>A function that takes a single argument (the number of failed
attempts so far) and returns the number of seconds to wait.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>after</code></td>
<td>
<p>A function that takes a single argument (the response) and
returns either a number of seconds to wait or <code>NULL</code>, which indicates
that a precise wait time is not available that the <code>backoff</code> strategy
should be used instead..</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A modified HTTP request.
</p>


<h3>See Also</h3>

<p><code>req_throttle()</code> if the API has a rate-limit but doesn't expose
the limits in the response.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># google APIs assume that a 500 is also a transient error
request("http://google.com") |&gt;
  req_retry(is_transient = \(resp) resp_status(resp) %in% c(429, 500, 503))

# use a constant 10s delay after every failure
request("http://example.com") |&gt;
  req_retry(backoff = ~10)

# When rate-limited, GitHub's API returns a 403 with
# `X-RateLimit-Remaining: 0` and an Unix time stored in the
# `X-RateLimit-Reset` header. This takes a bit more work to handle:
github_is_transient &lt;- function(resp) {
  resp_status(resp) == 403 &amp;&amp;
    identical(resp_header(resp, "X-RateLimit-Remaining"), "0")
}
github_after &lt;- function(resp) {
  time &lt;- as.numeric(resp_header(resp, "X-RateLimit-Reset"))
  time - unclass(Sys.time())
}
request("http://api.github.com") |&gt;
  req_retry(
    is_transient = github_is_transient,
    after = github_after
  )
</code></pre>


</div>