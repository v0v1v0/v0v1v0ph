<div class="container">

<table style="width: 100%;"><tr>
<td>pool_case</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pool qualified clients from results of multiple definitions</h2>

<h3>Description</h3>

<p>This function filters and pools, i.e., row bind, qualified clients/groups from different source with an option to summarize by client. Unlike <code>bind_source()</code>, no need to supply variable names; the function will guess what should be included and their names from the supplied definition from <code>build_def()</code>. Whether a client is qualified relies on the flag variables set by <code>define_case()</code>. Therefore, this function is intended to be use only with the built-in <code>define_case()</code> as <code>def_fn</code> in <code>build_def()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pool_case(
  data,
  def,
  output_lvl = c("raw", "clnt"),
  include_src = c("all", "has_valid", "n_per_clnt"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A list of data.frame or remote table which should be output from <code>execute_def()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>def</code></td>
<td>
<p>A tibble of case definition generated by <code>build_def()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_lvl</code></td>
<td>
<p>Either:
</p>

<ul>
<li>
<p> "raw" - output all records (default),
</p>
</li>
<li>
<p> or "clnt" - output one record per client with summaries including date of first valid record ('first_valid_date'), date of the latest record ('last_entry_date'), and sources that contain valid records.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_src</code></td>
<td>
<p>Character. It determines records from which sources should be included. This matters when clients were identified only from, not all, but some of the sources. This choice will not impact the number of client that would be identified but has impact on the number of records and the latest entry date. The options are one of:
</p>

<ul>
<li>
<p> "all" - records from all sources are included;
</p>
</li>
<li>
<p> "has_valid" - for each client, records from sources that contain at least one valid record are included;
</p>
</li>
<li>
<p> "n_per_clnt" - for each client, if they had fewer than <code>n_per_clnt</code> records in a source (see <code>restrict_n()</code>), then records from that source are removed.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passing to <code>bind_source()</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data.frame or remote table with clients that satisfied the predefined case definition. Columns started with "raw_in_" are source-specific counts of raw records, and columns started with "valid_in_" are the number of valid entries (or the number of flags) in each source.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># toy data
df1 &lt;- make_test_dat()
df2 &lt;- make_test_dat()

# use build_def to make a toy definition
sud_def &lt;- build_def("SUD", # usually a disease name
  src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
  # functions that filter the data with some criteria
  def_fn = define_case,
  fn_args = list(
    vars = starts_with("diagx"),
    match = "start", # "start" will be applied to all sources as length = 1
    vals = list(c("304"), c("305")),
    clnt_id = "clnt_id", # list()/c() could be omitted for single element
    # c() can be used in place of list
    # if this argument only takes one value for each source
    n_per_clnt = c(2, 3)
  )
)

# save the definition for re-use
# saveRDS(sud_def, file = some_path)

# execute definition
sud_by_src &lt;- sud_def %&gt;% execute_def(with_data = list(src1 = df1, src2 = df2))

# pool results from src1 and src2 together at client level
pool_case(sud_by_src, sud_def, output_lvl = "clnt")
</code></pre>


</div>