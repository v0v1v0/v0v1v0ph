<div class="container">

<table style="width: 100%;"><tr>
<td>probiths</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Horseshoe shrinkage prior in Bayesian Probit regression</h2>

<h3>Description</h3>

<p>This function employs the algorithm provided by Makalic and Schmidt (2016) for 
binary probit model to fit Bayesian probit regression. The observations are updated 
according to the data augmentation of approach of Albert and Chib (1993).
</p>
<p>The model is:
<code class="reqn">z_i</code> is response either 1 or 0,
<code class="reqn">\log \Pr(z_i = 1) = \Phi(X\beta), \Phi \sim N(0,\sigma^2)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">probiths(
  z,
  X,
  method.tau = c("fixed", "truncatedCauchy", "halfCauchy"),
  tau = 1,
  burn = 1000,
  nmc = 5000,
  thin = 1,
  alpha = 0.05,
  Xtest = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Response, a <code class="reqn">n*1</code> vector of 1 or 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of covariates, dimension <code class="reqn">n*p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.tau</code></td>
<td>
<p>Method for handling <code class="reqn">\tau</code>. Select "truncatedCauchy" for full
Bayes with the Cauchy prior truncated to [1/p, 1], "halfCauchy" for full Bayes with
the half-Cauchy prior, or "fixed" to use a fixed value (an empirical Bayes estimate,
for example).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Use this argument to pass the (estimated) value of <code class="reqn">\tau</code> in case "fixed"
is selected for method.tau. Not necessary when method.tau is equal to"halfCauchy" or
"truncatedCauchy". The default (tau = 1) is not suitable for most purposes and should be replaced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>Number of burn-in MCMC samples. Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmc</code></td>
<td>
<p>Number of posterior draws to be saved. Default is 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>Thinning parameter of the chain. Default is 1 (no thinning).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Level for the credible intervals. For example, alpha = 0.05 results in
95% credible intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xtest</code></td>
<td>
<p>test design matrix.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ProbHat</code></td>
<td>
<p>Predictive probability</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BetaHat</code></td>
<td>
<p>Posterior mean of Beta, a <code class="reqn">p</code> by 1 vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LeftCI</code></td>
<td>
<p>The left bounds of the credible intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RightCI</code></td>
<td>
<p>The right bounds of the credible intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BetaMedian</code></td>
<td>
<p>Posterior median of Beta, a <code class="reqn">p</code> by 1 vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LambdaHat</code></td>
<td>
<p>Posterior samples of <code class="reqn">\lambda</code>, a <code class="reqn">p*1</code> vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TauHat</code></td>
<td>
<p>Posterior mean of global scale parameter tau, a positive scalar</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BetaSamples</code></td>
<td>
<p>Posterior samples of <code class="reqn">\beta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TauSamples</code></td>
<td>
<p>Posterior samples of <code class="reqn">\tau</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LikelihoodSamples</code></td>
<td>
<p>Posterior samples of likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIC</code></td>
<td>
<p>Devainace Information Criterion of the fitted model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WAIC</code></td>
<td>
<p>Widely Applicable Information Criterion</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Stephanie van der Pas, James Scott, Antik Chakraborty and Anirban Bhattacharya (2016). horseshoe:
Implementation of the Horseshoe Prior. R package version 0.1.0.
https://CRAN.R-project.org/package=horseshoe
</p>
<p>Enes Makalic and Daniel Schmidt (2016). High-Dimensional Bayesian Regularised Regression with the
BayesReg Package arXiv:1611.06649
</p>
<p>Albert, J. H., &amp; Chib, S. (1993). Bayesian analysis of binary and polychotomous response data. 
Journal of the American statistical Association, 88(422), 669-679.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
burnin &lt;- 100
nmc    &lt;- 200
thin   &lt;- 1
y.sd   &lt;- 1  # statndard deviation of the response

p &lt;- 200  # number of predictors
ntrain &lt;- 250  # training size
ntest  &lt;- 100   # test size
n &lt;- ntest + ntrain  # sample size
q &lt;- 10   # number of true predictos

beta.t &lt;- c(sample(x = c(1, -1), size = q, replace = TRUE), rep(0, p - q))  
x &lt;- mvtnorm::rmvnorm(n, mean = rep(0, p))    
zmean &lt;- x %*% beta.t

y &lt;- rnorm(n, mean = zmean, sd = y.sd)
z &lt;- ifelse(y &gt; 0, 1, 0)
X &lt;- scale(as.matrix(x))  # standarization
z &lt;- as.numeric(as.matrix(c(z)))

# Training set
ztrain &lt;- z[1:ntrain]
Xtrain  &lt;- X[1:ntrain, ]

# Test set
ztest &lt;- z[(ntrain + 1):n]
Xtest &lt;- X[(ntrain + 1):n, ]
 
posterior.fit &lt;- probiths(z = ztrain, X = Xtrain, method.tau = "halfCauchy",
                          burn = burnin, nmc = nmc, thin = 1,
                          Xtest = Xtest)

posterior.fit$BetaHat

# Posterior processing to recover the significant predictors
cluster     &lt;- kmeans(abs(posterior.fit$BetaHat), centers = 2)$cluster  # return cluster indices
cluster1    &lt;- which(cluster == 1)
cluster2    &lt;- which(cluster == 2)
min.cluster &lt;- ifelse(length(cluster1) &lt; length(cluster2), 1, 2)
which(cluster == min.cluster)  # this matches with the true variables


</code></pre>


</div>