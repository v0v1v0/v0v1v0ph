<div class="container">

<table style="width: 100%;"><tr>
<td>PoisMixClus</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Poisson mixture model estimation and model selection
</h2>

<h3>Description</h3>

<p>These functions implement the EM and CEM algorithms for parameter estimation in a Poisson mixture model for clustering high throughput sequencing observations (e.g., genes) for a single number of clusters (<code>PoisMixClus</code>) or a sequence of cluster numbers (<code>PoisMixClusWrapper</code>). Parameters are initialized using a Small-EM strategy as described in Rau et al. (2011) or the splitting small-EM strategy described in Papastamoulis et al. (2014), and model selection is performed using the ICL criteria. Note that these functions implement the PMM-I and PMM-II models described in Rau et al. (2011). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">PoisMixClus(y, g, conds, norm = "TMM", 
    init.type = "small-em", init.runs = 1, init.iter = 10,
    alg.type = "EM", cutoff = 10e-6, iter = 1000, fixed.lambda = NA,
    equal.proportions = FALSE, prev.labels = NA, 
    prev.probaPost = NA, verbose = FALSE, interpretation = "sum",
	EM.verbose = FALSE, wrapper = FALSE, subset.index = NA)

PoisMixClusWrapper(y, gmin = 1, gmax, conds, 
    norm = "TMM", gmin.init.type = "small-em",
    init.runs = 1, init.iter = 10, split.init = TRUE, alg.type = "EM", 
    cutoff = 10e-6, iter = 1000, fixed.lambda = NA, 
    equal.proportions = FALSE, verbose = FALSE, interpretation = "sum",
	EM.verbose = FALSE, subset.index = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>(<em>n</em> x <em>q</em>) matrix of observed counts for <em>n</em> observations and <em>q</em> variables
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>

<p>Number of clusters (a single value). If <code>fixed.lambda</code> contains a list of lambda values to be fixed, 
<code>g</code> corresponds to the number of clusters in addition to those fixed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gmin</code></td>
<td>

<p>The minimum number of clusters in a sequence to be tested. In cases where clusters are included with a fixed value 
of lambda, <code>gmin</code> corresponds to the minimum number of clusters in addition to those that are fixed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gmax</code></td>
<td>

<p>The maximum number of clusters in a sequence to be tested. In cases where clusters are included with a fixed value 
of lambda, <code>gmax</code> corresponds to the maximum number of clusters in addition to those that are fixed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conds</code></td>
<td>

<p>Vector of length <em>q</em> defining the condition (treatment group) for each variable (column) in <code>y</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>

<p>The type of estimator to be used to normalize for differences in library size: (“<code>TC</code>” for total count, “<code>UQ</code>” for upper quantile, “<code>Med</code>” for median, 
“<code>DESeq</code>” for the normalization method in the DESeq package, and “<code>TMM</code>” for the TMM normalization method (Robinson and Oshlack, 2010). Can also
be a vector (of length <em>q</em>) containing pre-estimated library size estimates for each sample. Note that if the user provides
pre-calculated normalization factors, the package will make use of <code>norm/sum(norm)</code> as normalization factors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.type</code></td>
<td>

<p>Type of initialization strategy to be used (“<code>small-em</code>” for the Small-EM strategy described in Rau et al. (2011), and “<code>kmeans</code>” for a simple <em>K</em>-means initialization)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gmin.init.type</code></td>
<td>

<p>Type of initialization strategy to be used for the minimum number of clusters in a sequence (<code>gmin</code>): 
(“<code>small-em</code>” for the Small-EM strategy described in Rau et al. (2011), and “<code>kmeans</code>” for a simple <em>K</em>-means initialization)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.runs</code></td>
<td>

<p>Number of runs to be used for the Small-EM strategy described in Rau et al. (2011), with a default value of 1
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.iter</code></td>
<td>

<p>Number of iterations to be used within each run for the Small-EM strategry, with a default value of 10
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.init</code></td>
<td>

<p>If <code>TRUE</code>, the splitting initialization strategy of Papastamoulis et al. (2014) will be used for cluster sizes
(<code>gmin</code>+1, ..., <code>gmax</code>). If <code>FALSE</code>, the initialization strategy specified in <code>gmin.init.type</code>
is used for all cluster sizes in the sequence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alg.type</code></td>
<td>

<p>Algorithm to be used for parameter estimation (“<code>EM</code>” or “<code>CEM</code>”)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>

<p>Cutoff to declare algorithm convergence (in terms of differences in log likelihoods from one iteration to the next)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>

<p>Maximum number of iterations to be run for the chosen algorithm
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.lambda</code></td>
<td>

<p>If one (or more) clusters with fixed values of lambda is desired, a list containing vectors of length <em>d</em> (the number of conditions). 
specifying the fixed values of lambda for each fixed cluster.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal.proportions</code></td>
<td>

<p>If <code>TRUE</code>, the cluster proportions are set to be equal for all clusters. Default is <code>FALSE</code> (unequal cluster proportions).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prev.labels</code></td>
<td>

<p>A vector of length <em>n</em> of cluster labels obtained from the previous run (g-1 clusters) to be used with the splitting
small-EM strategy described in described in Papastamoulis et al. (2014). For other initialization strategies, this 
parameter takes the value NA
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prev.probaPost</code></td>
<td>

<p>An <em>n</em> x (<em>g</em>-1) matrix of the conditional probabilities of each observation belonging to each of the 
<em>g</em>-1 clusters from the previous run, to be used with the splitting small-EM strategy of described in Papastamoulis 
et al. (2012). For other initialization strategies, this parameter takes the value NA
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>If <code>TRUE</code>, include verbose output
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpretation</code></td>
<td>

<p>If <code>"sum"</code>, cluster behavior is interpreted with respect to overall gene expression level (sums per gene), 
otherwise for <code>"mean"</code>, cluster behavior is interpreted with respect to mean gene expression (means per gene).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EM.verbose</code></td>
<td>

<p>If <code>TRUE</code>, more informative output is printed about the EM algorithm, including the number of iterations run and
the difference between log-likelihoods at the last and penultimate iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset.index</code></td>
<td>

<p>Optional vector providing the indices of a subset of genes that should be used for the co-expression analysis (i.e., row indices
of the data matrix <code>y</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrapper</code></td>
<td>

<p><code>TRUE</code> if the <code>PoisMixClus</code> function is run from within the <code>PoisMixClusWrapper</code> main function, and <code>FALSE</code>
otherwise. This mainly helps to avoid recalculating parameters several times that are used throughout the algorithm (e.g., library
sizes, etc.)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Output of <code>PoisMixClus</code> is an S3 object of class <code>HTSCluster</code>, and output of <code>PoisMixClusWrapper</code> is an S3 object
of class <code>HTSClusterWrapper</code>.
</p>
<p>In a Poisson mixture model, the data <code class="reqn">\mathbf{y}</code> are assumed to come from <em>g</em> distinct subpopulations (clusters), each of which is modeled separately; the overall population is thus a mixture of these subpopulations. In the case of a Poisson mixture model with <em>g</em> components, the model may be written as
</p>
<p style="text-align: center;"><code class="reqn">f(\mathbf{y};g,\boldsymbol{\Psi}_g) = \prod_{i=1}^n \sum_{k=1}^g \pi_k \prod_{j=1}^{d}\prod_{l=1}^{r_j} P(y_{ijl} ; \boldsymbol{\theta}_k)</code>
</p>

<p>for <code class="reqn">i = 1, \ldots, n</code> observations in <code class="reqn">l = 1, \ldots, r_j</code> replicates of <code class="reqn">j = 1, \ldots, d</code> conditions (treatment groups), where <code class="reqn">P(\cdot)</code> is the standard Poisson density, <code class="reqn">\boldsymbol{\Psi}_g = (\pi_1,\ldots,\pi_{g-1}, \boldsymbol{\theta}^\prime)</code>, <code class="reqn">\boldsymbol{\theta}^\prime</code> contains all of the parameters in <code class="reqn">\boldsymbol{\theta}_1,\ldots,\boldsymbol{\theta}_g</code> assumed to be distinct, and <code class="reqn">\boldsymbol{\pi} = (\pi_1,\ldots,\pi_g)^\prime</code> are the mixing proportions such that <code class="reqn">\pi_k</code> is in (0,1) for all <em>k</em> and <code class="reqn">\sum_k \pi_k = 1</code>.
</p>
<p>We consider the following parameterization for the mean <code class="reqn">\boldsymbol{\theta}_k = (\mu_{ijlk})</code>. We consider
</p>
<p style="text-align: center;"><code class="reqn">\mu_{ijlk} = w_i s_{jl} \lambda_{jk}</code>
</p>

<p>where <code class="reqn">w_i</code> corresponds to the expression level of observation <em>i</em>, <code class="reqn">\boldsymbol{\lambda}_k = (\lambda_{1k},\ldots,\lambda_{dk})</code> 
corresponds to the clustering parameters that define the profiles of the genes in cluster <em>k</em> across all variables, and  
<code class="reqn">s_{jl}</code> is the normalized library size (a fixed constant) for replicate <em>l</em> of condition <em>j</em>.
</p>
<p>There are two approaches to estimating the parameters of a finite mixture model and obtaining a clustering of the data: the estimation approach (via the EM algorithm) and the clustering approach (via the CEM algorithm). Parameter initialization is done using a Small-EM strategy as described in Rau et al. (2011) via the <code>emInit</code> function. Model selection may be performed using the BIC or ICL criteria, or the slope heuristics.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lambda </code></td>
<td>
<p>(<em>d</em> x <em>g</em>) matrix containing the estimate of <code class="reqn">\hat{\boldsymbol{\lambda}}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi </code></td>
<td>
<p>Vector of length <em>g</em> containing the estimate of <code class="reqn">\hat{\boldsymbol{\pi}}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels </code></td>
<td>
<p>Vector of length <em>n</em> containing the cluster assignments of the <em>n</em> observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probaPost </code></td>
<td>
<p>Matrix containing the conditional probabilities of belonging to each cluster for all observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.like </code></td>
<td>
<p>Value of log likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC </code></td>
<td>
<p>Value of BIC criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ICL </code></td>
<td>
<p>Value of ICL criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alg.type </code></td>
<td>
<p>Estimation algorithm used; matches the argument <code>alg.type</code> above)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm </code></td>
<td>
<p>Library size normalization factors used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conds </code></td>
<td>
<p>Conditions specified by user</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations </code></td>
<td>
<p>Number of iterations run</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logLikeDiff </code></td>
<td>
<p>Difference in log-likelihood between the last and penultimate iterations of the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset.index </code></td>
<td>
<p>If provided by the user, the indices of subset of genes used for co-expression analyses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike.all </code></td>
<td>
<p>Log likelihoods calculated for each of the fitted models for cluster sizes <code>gmin</code>, ..., <code>gmax</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capushe </code></td>
<td>
<p>Results of capushe model selection, an object of class <code>"Capushe"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ICL.all </code></td>
<td>
<p>ICL values calculated for each of the fitted models for cluster sizes <code>gmin</code>, ..., <code>gmax</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ICL.results </code></td>
<td>
<p>Object of class <code>HTSCluster</code> giving the results from the model chosen via the ICL criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BIC.results </code></td>
<td>
<p>Object of class <code>HTSCluster</code> giving the results from the model chosen via the BIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DDSE.results </code></td>
<td>
<p>Object of class <code>HTSCluster</code> giving the results from the model chosen via the DDSE slope heuristics criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Djump.results </code></td>
<td>
<p>Object of class <code>HTSCluster</code> giving the results from the model chosen via the Djump slope heuristics criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.results </code></td>
<td>
<p>List of objects of class <code>HTSCluster</code> giving the results for all models for cluster sizes <code>gmin</code>, ..., <code>gmax</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.selection </code></td>
<td>
<p>Type of criteria used for model selection, equal to <code>NA</code> for direct calls to <code>PoisMixClus</code> or
<code>"DDSE"</code>, <code>"Djump"</code>, <code>"BIC"</code>, or <code>"ICL"</code> for the respective selected models for calls to <code>PoisMixClusWrapper</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Note that the <code>fixed.lambda</code> argument is primarily intended to be used in the case when a single cluster is fixed to 
have equal clustering parameters lambda across all conditions (i.e., <code class="reqn">\lambda_{j1}=\lambda_{1}=1</code>); this is particularly useful
when identifying genes with non-differential expression across all conditions (see the <code>HTSDiff</code> R package for more details).
Alternatively, this argument could be used to specify a cluster for which genes are only expressed in a single condition 
(e.g., <code class="reqn">\lambda_{11} = 1</code> and <code class="reqn">\lambda_{j1} = 0</code> for all <code class="reqn">j &gt; 1</code>). Other possibilities could be considered,
but note that the fixed values of lambda must satisfy the constraint <code class="reqn">\sum_j \lambda_{jk}s_{j.} = 1</code> for all <code class="reqn">k</code> 
imposed in the model; if this is not the case, a warning message will be printed.
</p>


<h3>Author(s)</h3>

<p>Andrea Rau
</p>


<h3>References</h3>

<p>Anders, S. and Huber, W. (2010) Differential expression analysis for sequence count data. <em>Genome Biology</em>, <b>11</b>(R106), 1-28.
</p>
<p>Papastamoulis, P., Martin-Magniette, M.-L., and Maugis-Rabusseau, C. (2014). On the estimation of mixtures of Poisson regression models with large number of components. <em>Computational Statistics and Data Analysis</em>: 3rd special Issue on Advances in Mixture Models, DOI: 10.1016/j.csda.2014.07.005.
</p>
<p>Rau, A., Maugis-Rabusseau, C., Martin-Magniette, M.-L., Celeux G. (2015). Co-expression analysis of high-throughput transcriptome sequencing data with Poisson mixture models. Bioinformatics, 31(9):1420-1427.
</p>
<p>Rau, A., Celeux, G., Martin-Magniette, M.-L., Maugis-Rabusseau, C (2011). Clustering high-throughput sequencing data with Poisson mixture models. Inria Research Report 7786. Available at <a href="https://inria.hal.science/inria-00638082">https://inria.hal.science/inria-00638082</a>.
</p>


<h3>See Also</h3>

<p><code>probaPost</code> for the calculation of the conditional probability of belonging to a cluster;
<code>PoisMixMean</code> for the calculation of the per-cluster conditional mean of each observation;
<code>logLikePoisMixDiff</code> for the calculation of the log likelihood of a Poisson mixture model;
<code>emInit</code> and <code>kmeanInit</code> for the Small-EM parameter initialization strategy
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(12345)

## Simulate data as shown in Rau et al. (2011)
## Library size setting "A", high cluster separation
## n = 200 observations

simulate &lt;- PoisMixSim(n = 200, libsize = "A", separation = "high")
y &lt;- simulate$y
conds &lt;- simulate$conditions

## Run the PMM model for g = 3
## "TC" library size estimate, EM algorithm

run &lt;- PoisMixClus(y, g = 3, conds = conds, norm = "TC") 

## Estimates of pi and lambda for the selected model

pi.est &lt;- run$pi
lambda.est &lt;- run$lambda


## Not run: PMM for 4 total clusters, with one fixed class
## "TC" library size estimate, EM algorithm
##
## run &lt;- PoisMixClus(y, g = 3, norm = "TC", conds = conds, 
##    fixed.lambda = list(c(1,1,1))) 
##
##
## Not run: PMM model for 4 clusters, with equal proportions
## "TC" library size estimate, EM algorithm
##
## run &lt;- PoisMixClus(y, g = 4, norm = "TC", conds = conds, 
##     equal.proportions = TRUE) 
##
##
## Not run: PMM model for g = 1, ..., 10 clusters, Split Small-EM init
##
## run1.10 &lt;- PoisMixClusWrapper(y, gmin = 1, gmax = 10, conds = conds, 
##	norm = "TC")
##
##
## Not run: PMM model for g = 1, ..., 10 clusters, Small-EM init
##
## run1.10bis &lt;-  &lt;- PoisMixClusWrapper(y, gmin = 1, gmax = 10, conds = conds, 
##	norm = "TC", split.init = FALSE)
##
##
## Not run: previous model equivalent to the following
##
## for(K in 1:10) {
##	run &lt;- PoisMixClus(y, g = K, conds = conds, norm = "TC")
## } 

</code></pre>


</div>