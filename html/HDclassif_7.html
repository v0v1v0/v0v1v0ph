<div class="container">

<table style="width: 100%;"><tr>
<td>hddc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>High Dimensional Data Clustering</h2>

<h3>Description</h3>

<p>HDDC is a model-based clustering method. It is based on the Gaussian Mixture Model and on the idea that the data lives in subspaces with a lower dimension than the dimension of the original space. It uses the Expectation - Maximisation algorithm to estimate the parameters of the model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hddc(
  data,
  K = 1:10,
  model = c("AkjBkQkDk"),
  threshold = 0.2,
  criterion = "bic",
  com_dim = NULL,
  itermax = 200,
  eps = 0.001,
  algo = "EM",
  d_select = "Cattell",
  init = "kmeans",
  init.vector,
  show = getHDclassif.show(),
  mini.nb = c(5, 10),
  scaling = FALSE,
  min.individuals = 2,
  noise.ctrl = 1e-08,
  mc.cores = 1,
  nb.rep = 1,
  keepAllRes = TRUE,
  kmeans.control = list(),
  d_max = 100,
  subset = Inf,
  d
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A matrix or a data frame of observations, assuming the rows are the observations and the columns the variables. Note that NAs are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>A vector of integers specifying the number of clusters for which the BIC and the parameters are to be calculated; the function keeps the parameters which maximises the <code>criterion</code>. Default is 1:10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A character string vector, or an integer vector indicating the models to be used. The available models are: "AkjBkQkDk" (default), "AkBkQkDk", "ABkQkDk", "AkjBQkDk", "AkBQkDk", "ABQkDk", "AkjBkQkD", "AkBkQkD", "ABkQkD", "AkjBQkD", "AkBQkD", "ABQkD", "AjBQD", "ABQD". It is not case sensitive and integers can be used instead of names, see details for more information. Several models can be used, if it is, only the results of the one which maximizes the BIC criterion is kept. To run all models, use model="ALL".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>A float stricly within 0 and 1. It is the threshold used in the Cattell's Scree-Test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>Either “BIC” or “ICL”. If several models are run, the best model is selected using the criterion defined by <code>criterion</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>com_dim</code></td>
<td>
<p>It is used only for common dimensions models. The user can give the common dimension s/he wants. If used, it must be an integer. Its default is set to NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax</code></td>
<td>
<p>The maximum number of iterations allowed. The default is 200.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A positive double, default is 0.001. It is the stopping criterion: the algorithm stops when the difference between two successive log-likelihoods is lower than <code>eps</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>A character string indicating the algorithm to be used. The available algorithms are the Expectation-Maximisation ("EM"), the Classification E-M ("CEM") and the Stochastic E-M ("SEM"). The default algorithm is the "EM".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_select</code></td>
<td>
<p>Either “Cattell” (default) or “BIC”. See details for more information. This parameter selects which method to use to select the intrinsic dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A character string or a vector of clusters. It is the way to initialize the E-M algorithm. There are five possible initialization: “kmeans” (default), “param”, “random”, “mini-em” or “vector”. See details for more information. It can also be directly initialized with a vector containing the prior classes of the observations. If <code>init = "vector"</code>, then you should add the argument <code>init.vector</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.vector</code></td>
<td>
<p>A vector of integers or factors. It is a user-given initialization. It should be of the same length as of the data. Only used when <code>init = "vector"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show</code></td>
<td>
<p>Single logical. To diplay summary information on the results after the algorithm is done: set it to <code>TRUE</code>. By default it takes the value of <code>getHDclassif.show</code> which is FALSE at the loading of the package. To permanently have <code>show=TRUE</code>, use <code>setHDclassif.show(TRUE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mini.nb</code></td>
<td>
<p>A vector of integers of length two. This parameter is used in the “mini-em” initialization. The first integer sets how many times the algorithm is repeated; the second sets the maximum number of iterations the algorithm will do each time. For example, if <code>init="mini-em"</code> and <code>mini.nb=c(5,10)</code>, the algorithm wil be lauched 5 times, doing each time 10 iterations; finally the algorithm will begin with the initialization that maximizes the log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>Logical: whether to scale the dataset (mean=0 and standard-error=1 for each variable) or not. By default the data is not scaled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.individuals</code></td>
<td>
<p>Positive integer greater than 2 (default). This parameter is used to control for the minimum population of a class. If the population of a class becomes stricly inferior to 'min.individuals' then the algorithm stops and gives the message: 'pop&lt;min.indiv.'. Here the meaning of "population of a class" is the sum of its posterior probabilities. The value of 'min.individuals' cannot be lower than 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise.ctrl</code></td>
<td>
<p>This parameter avoids to have a too low value of the 'noise' parameter b. It garantees that the dimension selection process do not select too many dimensions (which leads to a potential too low value of the noise parameter b). When selecting the intrinsic dimensions using Cattell's scree-test or BIC, the function doesn't use the eigenvalues inferior to noise.ctrl, so that the intrinsic dimensions selected can't be higher or equal to the order of these eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>Positive integer, default is 1. If <code>mc.cores&gt;1</code>, then parallel computing is used, using <code>mc.cores</code> cores. Warning for Windows users only: the parallel computing can sometimes be slower than using one single core (due to how <code>parLapply</code> works).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nb.rep</code></td>
<td>
<p>A positive integer (default is 1). Each estimation (i.e. combination of (model, K, threshold)) is repeated <code>nb.rep</code> times and only the estimation with the highest log-likelihood is kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepAllRes</code></td>
<td>
<p>Logical. Should the results of all runs be kept? If so, an argument <code>all_results</code> is created in the results. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmeans.control</code></td>
<td>
<p>A list. The elements of this list should match the parameters of the kmeans initialization (see <code>kmeans</code> help for details). The parameters are “iter.max”, “nstart” and “algorithm”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_max</code></td>
<td>
<p>A positive integer. The maximum number of dimensions to be computed. Default is 100. It means that the instrinsic dimension of any cluster cannot be larger than <code>d_max</code>. It quickens a lot the algorithm for datasets with a large number of variables (e.g. thousands).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An positive integer, default is <code>Inf</code>. In case of large data sets it might be useful to perform HDDC on a subsample of the data: this is the use of this argument. If <code>subset</code> is to a value smaller than the number of observations of the dataset then: HDDC is performed on a random subsample of size <code>subset</code> and once a clustering is obtained on this subsample, the posterior of the clustering is computed on the full sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>DEPRECATED. This parameter is kept for retro compatibility. Now please use the parameter d_select.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Some information on the signification of the model names:
</p>

<dl>
<dt>Akj are the parameters of the classes subspaces:</dt>
<dd>

<ul>
<li>
<p>if Akj: each class has its parameters and there is one parameter for each dimension
</p>
</li>
<li>
<p>if Ak: the classes have different parameters but there is only one per class
</p>
</li>
<li>
<p>if Aj: all the classes have the same parameters for each dimension (it's a particular case with a common orientation matrix)
</p>
</li>
<li>
<p>if A: all classes have the same one parameter
</p>
</li>
</ul>
</dd>
<dt>Bk are the noises of the classes subspaces:</dt>
<dd>

<ul>
<li>
<p>If Bk: each class has its proper noise
</p>
</li>
<li>
<p>if B:  all classes have the same noise
</p>
</li>
</ul>
</dd>
<dt>Qk is the orientation matrix of each class:</dt>
<dd> 

<ul>
<li>
<p>if Qk: all classes have its proper orientation matrix
</p>
</li>
<li>
<p>if Q: all classes have the same orientation matrix
</p>
</li>
</ul>
</dd>
<dt>Dk is the intrinsic dimension of each class:</dt>
<dd> 

<ul>
<li>
<p>if Dk: the dimensions are free and proper to each class
</p>
</li>
<li>
<p>if D: the dimension is common to all classes
</p>
</li>
</ul>
</dd>
</dl>
<p>The model “ALL” will compute all the models, give their BIC and keep the model with the highest BIC value.
Instead of writing the model names, they can also be specified using an integer.  1 represents the most general model (“AkjBkQkDk”) while 14 is the most constrained (“ABQD”), the others  number/name matching are given below. Note also that several models can be run at once, by using a vector of models (e.g. model = c("AKBKQKD","AKJBQKDK","AJBQD") is equivalent to model = c(8,4,13); to run the 6 first models, use model=1:6). If all the models are to be run, model="all" is faster than model=1:14. 
</p>

<table>
<tr>
<td style="text-align: left;">
AkjBkQkDk </td>
<td style="text-align: center;">   1   </td>
<td style="text-align: center;">   </td>
<td style="text-align: left;">  AkjBkQkD </td>
<td style="text-align: center;">   7   </td>
</tr>
<tr>
<td style="text-align: left;"> 
AkBkQkDk </td>
<td style="text-align: center;">   2   </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;">  AkBkQkD </td>
<td style="text-align: center;">   8   </td>
</tr>
<tr>
<td style="text-align: left;">   
ABkQkDk </td>
<td style="text-align: center;">   3   </td>
<td style="text-align: center;">  </td>
<td style="text-align: left;"> ABkQkD </td>
<td style="text-align: center;">   9   </td>
</tr>
<tr>
<td style="text-align: left;">   
AkjBQkDk </td>
<td style="text-align: center;">   4   </td>
<td style="text-align: center;">  </td>
<td style="text-align: left;">  AkjBQkD </td>
<td style="text-align: center;">   10   </td>
</tr>
<tr>
<td style="text-align: left;">   
AkBQkDk </td>
<td style="text-align: center;">   5   </td>
<td style="text-align: center;">  </td>
<td style="text-align: left;">  AkBQkD </td>
<td style="text-align: center;">   11   </td>
</tr>
<tr>
<td style="text-align: left;">   
ABQkDk </td>
<td style="text-align: center;">   6   </td>
<td style="text-align: center;">  </td>
<td style="text-align: left;">  ABQkD </td>
<td style="text-align: center;">   12  </td>
</tr>
<tr>
<td style="text-align: left;">
AjBQD </td>
<td style="text-align: center;"> 13 </td>
<td style="text-align: center;">  </td>
<td style="text-align: left;"> ABQD </td>
<td style="text-align: center;"> 14
</td>
</tr>
</table>
<p>The parameter <code>d_select</code>, is used to select the intrinsic dimensions of the subclasses. Here are its definitions:
</p>

<ul>
<li>
<p>“Cattell”:
The Cattell's scree-test is used to gather the intrinsic dimension of each class. If the model is of common dimension (models 7 to 14), the scree-test is done on the covariance matrix of the whole dataset.

</p>
</li>
<li>
<p>“BIC”:
The intrinsic dimensions are selected with the BIC criterion. See Bouveyron <em>et al.</em> (2010) for a discussion of this topic.
For common dimension models, the procedure is done on the covariance matrix of the whole dataset.

</p>
</li>
<li>
<p>Note that "Cattell" (resp. "BIC") can be abreviated to "C" (resp. "B") and that this argument is not case sensitive.
</p>
</li>
</ul>
<p>The different initializations are:
</p>

<dl>
<dt>“param”:</dt>
<dd>
<p>it is initialized with the parameters, the means being generated by a multivariate normal distribution and the covariance matrix being common to the whole sample</p>
</dd>
<dt>“mini-em”:</dt>
<dd>
<p>it is an initialization strategy, the classes are randomly initialized and the E-M algorithm makes several iterations, this action is repetead a few times (the default is 5 iterations and 10 times), at the end, the initialization choosen is the one which maximise the log-likelihood (see mini.nb for more information about its parametrization)</p>
</dd>
<dt>“random”:</dt>
<dd>
<p>the classes are randomly given using a multinomial distribution</p>
</dd>
<dt>“kmeans”:</dt>
<dd>
<p>the classes are initialized using the kmeans function (with: algorithm="Hartigan-Wong"; nstart=4; iter.max=50); note that the user can use his own arguments for kmeans using the dot-dot-dot argument </p>
</dd> 
<dt>A prior class vector:</dt>
<dd>
<p>It can also be directly initialized with a vector containing the prior classes of the observations. To do so use <code>init="vector"</code> and provide the vector in the argument <code>init.vector</code>.</p>
</dd>
</dl>
<p>The BIC criterion used in this function is to be maximized and is defined as 2*LL-k*log(n) where LL is the log-likelihood, k is the number of parameters and n is the number of observations.
</p>


<h3>Value</h3>

<p>hddc returns an 'hdc' object; it's a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code> model </code></td>
<td>
<p>The name of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> K </code></td>
<td>
<p>The number of classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> d </code></td>
<td>
<p>The dimensions of each class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> a </code></td>
<td>
<p>The parameters of each class subspace.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> b </code></td>
<td>
<p>The noise of each class subspace.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> mu </code></td>
<td>
<p>The mean of each variable for each class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> prop </code></td>
<td>
<p>The proportion of each class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ev </code></td>
<td>
<p>The eigen values of the var/covar matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> Q </code></td>
<td>
<p>The orthogonal matrix of orientation of each class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> loglik </code></td>
<td>
<p>The log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> loglik_all </code></td>
<td>
<p>The log-likelihood of all iterations. Note that if <code>subset</code> was used, then this vector represents the likelihoods evaluations for the subsample on which HDDC was performed (i.e. not the likelihood for the full dataset – so these values are smaller than the on given in ‘loglik’ which concerns the whole sample after the estimation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> posterior </code></td>
<td>
<p>The matrix of the probabilities to belong to a class for each observation and each class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> class </code></td>
<td>
<p>The class vector obtained by the clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> com_ev </code></td>
<td>
<p>Only if this is a common dimension model. The eigenvalues of the var/covar matrix of the whole dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> N </code></td>
<td>
<p>The number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> complexity </code></td>
<td>
<p>The number of parameters of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> threshold </code></td>
<td>
<p>The threshold used for the Cattell scree-test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> d_select </code></td>
<td>
<p>The way the dimensions were selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> BIC </code></td>
<td>
<p>The BIC of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ICL </code></td>
<td>
<p>The ICL of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> criterion </code></td>
<td>
<p>The criterion used to select the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> call </code></td>
<td>
<p>The call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> allCriteria </code></td>
<td>
<p>The data.frame with the combination (model, K, threshold) and the associated values of the likelihood (LL), BIC and ICL, as well as the rank of each of the models with respect to the selection criterion. It also reports the original order in which were estimated the models as well as each model complexity</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> all_results </code></td>
<td>
<p>Only if <code>keepAllRes=TRUE</code>. The parameters of all estimations that were run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> scaling </code></td>
<td>
<p>Only if <code>scaling=TRUE</code>. The centers and the standard deviation of the original dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> id_subset </code></td>
<td>
<p>Only if <code>subset</code> is used. The observation IDs of the subsample on which the HDDC parameters were estimated.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Laurent Berge, Charles Bouveyron and Stephane Girard
</p>


<h3>References</h3>

<p>Bouveyron, C. Girard, S. and Schmid, C. (2007) “High-Dimensional Data Clustering”, <em>Computational Statistics and Data Analysis</em>, vol. <b>52</b> (1), pp. 502–519
</p>
<p>Berge, L. Bouveyron, C. and Girard, S. (2012) “HDclassif: An R Package for 
Model-Based Clustering and Discriminant Analysis of High-Dimensional Data”, 
<em>Journal of Statistical Software</em>, <b>46</b>(6), 1–29, url: 
<a href="https://doi.org/10.18637/jss.v046.i06">doi:10.18637/jss.v046.i06</a>
</p>


<h3>See Also</h3>

<p><code>hdda</code>, <code>predict.hdc</code>, <code>plot.hdc</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1:
data &lt;- simuldata(1000, 1000, 50)
X &lt;- data$X
clx &lt;- data$clx
Y &lt;- data$Y
cly &lt;- data$cly

#clustering of the simulated dataset:
prms1 &lt;- hddc(X, K=3, algo="CEM", init='param')                

#class vector obtained by the clustering:
prms1$class                

#We can look at the adjusted rand index to assess the goodness of fit
res1 &lt;- predict(prms1, X, clx)
res2 &lt;- predict(prms1, Y)       
#the class predicted using hddc parameters on the test dataset:  
res2$class                                                           


# Example 2:
data(Crabs)

# clustering of the Crabs dataset:
prms3 &lt;- hddc(Crabs[,-1], K=4, algo="EM", init='mini-em')        
res3 &lt;- predict(prms3, Crabs[,-1], Crabs[,1])

# another example using the Crabs dataset
prms4 &lt;- hddc(Crabs[,-1], K=1:8, model=c(1,2,7,9))

# model=c(1,2,7,9) is equivalent to:
# model=c("AKJBKQKDK","AKBKQKDK","AKJBKQKD"#' ,"ABKQKD") 
res4 &lt;- predict(prms4, Crabs[,-1], Crabs[,1])

# PARALLEL COMPUTING
## Not run: 
# Same example but with Parallel Computing =&gt; platform specific
# (slower for Windows users)
# To enable it, just use the argument 'mc.cores'
prms5 &lt;- hddc(Crabs[,-1], K=1:8, model=c(1,2,7,9), mc.cores=2)

## End(Not run)

# LARGE DATASETS
# Assume you have a very large data set 
# =&gt; you can use the argument 'subset' to obtain quick results:
## Not run: 
# we take a subset of 10000 observations and run hddc
# once the classification is done, the posterior is computed 
# on the full data
prms = hddc(bigData, subset = 10000)
# You obtain a much faster (although less precise) 
# classification of the full dataset:
table(prms$class)

## End(Not run)


</code></pre>


</div>