<div class="container">

<table style="width: 100%;"><tr>
<td>fit_aenet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model selection for high-dimensional Cox models with adaptive elastic-net penalty</h2>

<h3>Description</h3>

<p>Automatic model selection for high-dimensional Cox models
with adaptive elastic-net penalty, evaluated by penalized partial-likelihood.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_aenet(
  x,
  y,
  nfolds = 5L,
  alphas = seq(0.05, 0.95, 0.05),
  rule = c("lambda.min", "lambda.1se"),
  seed = c(1001, 1002),
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Data matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response matrix made with <code>Surv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Fold numbers of cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphas</code></td>
<td>
<p>Alphas to tune in <code>cv.glmnet</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>Model selection criterion, <code>"lambda.min"</code> or
<code>"lambda.1se"</code>. See <code>cv.glmnet</code>
for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Two random seeds for cross-validation fold division
in two estimation steps.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical. Enable parallel parameter tuning or not,
default is <code>FALSE</code>. To enable parallel tuning, load the
<code>doParallel</code> package and run <code>registerDoParallel()</code>
with the number of CPU cores before calling this function.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">data("smart")
x &lt;- as.matrix(smart[, -c(1, 2)])
time &lt;- smart$TEVENT
event &lt;- smart$EVENT
y &lt;- survival::Surv(time, event)

# To enable parallel parameter tuning, first run:
# library("doParallel")
# registerDoParallel(detectCores())
# then set fit_aenet(..., parallel = TRUE).

fit &lt;- fit_aenet(
  x, y,
  nfolds = 3, alphas = c(0.3, 0.7),
  rule = "lambda.1se", seed = c(5, 7)
)

nom &lt;- as_nomogram(
  fit, x, time, event,
  pred.at = 365 * 2,
  funlabel = "2-Year Overall Survival Probability"
)

plot(nom)
</code></pre>


</div>